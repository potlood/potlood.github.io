{"version":3,"sources":["webpack://Potlood/webpack/universalModuleDefinition","webpack://Potlood/webpack/bootstrap","webpack://Potlood/./src/utils/in-sequence.ts","webpack://Potlood/./src/drawing/shape-bounds.ts","webpack://Potlood/./src/paragraph/tab-stop.ts","webpack://Potlood/./src/text/run-style.ts","webpack://Potlood/./src/paragraph/par-style.ts","webpack://Potlood/./src/text/positioned-text-line.ts","webpack://Potlood/./src/text/word-splitter.ts","webpack://Potlood/./src/paragraph/paragraph.ts","webpack://Potlood/./src/painting/i-painter.ts","webpack://Potlood/./src/table/table-border.ts","webpack://Potlood/./src/chart/chart-axis.ts","webpack://Potlood/./src/chart/chart-space.ts","webpack://Potlood/./src/drawing/drawing-run.ts","webpack://Potlood/./src/chart/bar-chart.ts","webpack://Potlood/./src/math/fraction-style.ts","webpack://Potlood/./src/math/matrix-style.ts","webpack://Potlood/./src/numbering/numbering-level.ts","webpack://Potlood/./src/utils/geometry/point.ts","webpack://Potlood/./src/utils/geometry/box.ts","webpack://Potlood/./src/utils/virtual-flow.ts","webpack://Potlood/./src/utils/metrics.ts","webpack://Potlood/./src/utils/xml.ts","webpack://Potlood/./src/numbering/num-style.ts","webpack://Potlood/./src/text/style.ts","webpack://Potlood/./src/utils/fonts.ts","webpack://Potlood/./src/utils/font-metrics.ts","webpack://Potlood/./src/text/text-fitter.ts","webpack://Potlood/./src/utils/geometry/size.ts","webpack://Potlood/./src/text/text-run.ts","webpack://Potlood/./src/painting/svg-painter.ts","webpack://Potlood/./src/table/table-renderer.ts","webpack://Potlood/./src/text/text-renderer.ts","webpack://Potlood/./src/chart/chart-style.ts","webpack://Potlood/./src/chart/chart-plot-area.ts","webpack://Potlood/./src/chart/chart-legend.ts","webpack://Potlood/./src/utils/geometry/angle.ts","webpack://Potlood/./src/drawing/shape-guide.ts","webpack://Potlood/./src/utils/geometry/ellipse.ts","webpack://Potlood/./src/drawing/shape-path.ts","webpack://Potlood/./src/drawing/shape.ts","webpack://Potlood/./src/drawing/point-guide.ts","webpack://Potlood/./src/chart/chart-renderer.ts","webpack://Potlood/./src/drawing/drawing-renderer.ts","webpack://Potlood/./src/math/math-renderer.ts","webpack://Potlood/./src/math/math-run.ts","webpack://Potlood/./src/paragraph/paragraph-renderer.ts","webpack://Potlood/./src/painting/renderer.ts","webpack://Potlood/./src/package/xml-part.ts","webpack://Potlood/./src/package/package.ts","webpack://Potlood/./src/text/named-styles.ts","webpack://Potlood/./src/section.ts","webpack://Potlood/./src/table/table-border-set.ts","webpack://Potlood/./src/table/table-margin-set.ts","webpack://Potlood/./src/table/table-style.ts","webpack://Potlood/./src/table/table.ts","webpack://Potlood/./src/table/table-column.ts","webpack://Potlood/./src/table/table-row.ts","webpack://Potlood/./src/table/table-cell.ts","webpack://Potlood/./src/text/text-reader.ts","webpack://Potlood/./src/drawing/picture.ts","webpack://Potlood/./src/chart/base-chart.ts","webpack://Potlood/./src/chart/chart-series.ts","webpack://Potlood/./src/chart/chart-value.ts","webpack://Potlood/./src/chart/line-chart.ts","webpack://Potlood/./src/chart/area-chart.ts","webpack://Potlood/./src/chart/pie-chart.ts","webpack://Potlood/./src/drawing/preset-shape-factory.ts","webpack://Potlood/./src/drawing/shape-reader.ts","webpack://Potlood/./src/drawing/shape-bounds-reader.ts","webpack://Potlood/./src/drawing/drawing-reader.ts","webpack://Potlood/./src/chart/chart-reader.ts","webpack://Potlood/./src/numbering/numbering-run.ts","webpack://Potlood/./src/math/equation.ts","webpack://Potlood/./src/math/n-ary-style.ts","webpack://Potlood/./src/math/math-object.ts","webpack://Potlood/./src/math/character-object.ts","webpack://Potlood/./src/math/n-ary-object.ts","webpack://Potlood/./src/math/delimiter-object.ts","webpack://Potlood/./src/math/run-object.ts","webpack://Potlood/./src/math/delimiter-style.ts","webpack://Potlood/./src/math/fraction-object.ts","webpack://Potlood/./src/math/matrix-object.ts","webpack://Potlood/./src/math/function-style.ts","webpack://Potlood/./src/math/function-object.ts","webpack://Potlood/./src/math/radical-style.ts","webpack://Potlood/./src/math/radical-object.ts","webpack://Potlood/./src/math/matrix-column-style.ts","webpack://Potlood/./src/paragraph/paragraph-reader.ts","webpack://Potlood/./src/math/math-reader.ts","webpack://Potlood/./src/document-x.ts","webpack://Potlood/./src/table/table-reader.ts","webpack://Potlood/./src/numbering/numbering.ts","webpack://Potlood/./src/numbering/abstract-numberings.ts","webpack://Potlood/./src/package/relationships.ts","webpack://Potlood/./src/drawing/preset-shape-reader.ts","webpack://Potlood/./src/fields/core-properties.ts","webpack://Potlood/./src/potlood.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","InSequence","ShapeAnchorMode","ShapePositionReference","ShapePositionAlignMode","TabLeader","TabAlignment","UnderlineMode","Justification","LineRule","Emphasis","WordSeperator","ParagraphType","DashMode","TableBorderType","ChartAxisPosition","ChartAxisTickMode","ChartAxisLabelAlignment","ChartAxisCrossMode","ChartType","WrapMode","ChartOrientation","FractionType","MatrixYAlign","MatrixColumnXAlign","MatrixSpacingRule","NumberingFormat","NumberingSuffix","Point","x","y","startPoint","endPoint","offset","factor","factor1","factor2","width","height","left","top","right","bottom","set","margins","_rowOrder","_columnOrder","start","undefined","borderStart","size","cellMarginStart","end","borderEnd","cellMarginEnd","borderTop","cellMarginTop","borderBottom","cellMarginBottom","addBorder","spacing","subtractBorder","arg1","arg2","newX","Math","min","newY","newWidth","max","newHeight","xPos","yPos","Middle","Last","other","point","intersectX","intersectY","offsetX","offsetY","referenceX","None","referenceY","referenceOffsetX","referenceOffsetY","alignX","Start","alignY","sizeX","sizeY","flipHorizontal","flipVertical","rotation","anchor","Inline","flow","_getStartPoint","getReferenceX","getReferenceY","Column","Paragraph","Obstacle","bounds","isFloating","xMin","xMax","position","_lastParPos","_lastCharX","_stops","_nums","_obstacles","_xMin","_xMax","_pos","section","pageWidth","pageHeight","marginLeft","marginRight","needsWidth","obstacle","_getApplicableObstacle","advancePosition","reference","getX","Character","includeFloating","maxY","forEach","pos","push","addObstacle","startDelta","endDelta","delta","numId","level","id","currentNum","index","tabStop","pop","xDelta","cloned","found","length","Metrics","twips","points","convertTwipsToPixels","emu","convertPointToPixels","rot","PI","text","style","getTextWidthFromCanvas","element","document","createElementNS","setAttribute","fontFamily","fontSize","bold","italic","node","createTextNode","appendChild","svg","getComputedTextLength","removeChild","getTextMetrics","italicText","boldText","context","font","round","measureText","canvas","createElement","getContext","body","Xml","url","Promise","resolve","reject","oReq","XMLHttpRequest","open","responseType","onload","_oEvent","status","response","doc","DOMParser","parseFromString","onerror","evt","send","val","attrVal","getAttribute","parent","Array","isArray","getFirstChildOfName","child","children","childNodes","indexOf","nodeName","attr","getStringValue","attributeAsBoolean","getBooleanValue","parseFloat","getNumberValue","levelIndex","_levelIndex","numPrNode","indexAttr","getStringValueFromNode","numIdAttr","parseInt","indices","getText","numberings","numbering","getNumberingById","getLevel","console","log","align","leader","_alignment","tabsNode","stops","tabNode","alignStr","leaderAttr","posAttr","alignment","_readTabAlignment","_readTabLeader","stop","Left","toLowerCase","Numbering","Center","Clear","Right","Dot","justification","center","runPresentationNode","_basedOnId","_bold","_italic","_shadingColor","readShading","underlineMode","_underlineMode","readUnderlineMode","_strike","_dstrike","families","readFontFamily","_fontFamily","tryAddFonts","_fontSize","readFontSize","spacingTwips","_charSpacing","stretchPercent","_charStretch","_color","_caps","_smallCaps","_invisible","_basedOn","_docDefaults","namedStyles","docDefaults","baseStyle","getNamedStyle","toString","fontNode","fonts","asciiFont","split","sizeNode","sizeInPoints","convertPointToFontSize","underlineStr","Dash","DashDotDotHeavy","DashDotHeavy","DashedHeavy","DashLong","DashLongHeavy","DotDash","DotDotDash","Dotted","DottedHeavy","Double","Single","Thick","Wave","WavyDouble","WavyHeavy","Words","parPresentationNode","parStyle","hangingAttr","hanging","leftAttr","indentation","numStyle","fromNumPresentationNode","setLineSpacingFromNode","setParSpacingFromNode","shadingColor","tabStops","fromTabsNode","runStyle","fromPresentationNode","_lineSpacing","_lineRule","auto","atLeast","_parLinesBefore","_parSpacingBefore","_parAutoSpacingBefore","_parLinesAfter","_parSpacingAfter","_parAutoSpacingAfter","applyNumberings","spacingNode","lineAttr","exactly","ruleAttr","beforeAttr","beforeLinesAttr","beforeAutoAttr","afterAttr","afterLinesAttr","afterAutoAttr","docDefaultsNode","runDefaults","runStyleNode","parDefaults","parStyleNode","fromParPresentationNode","styleNode","basedOnId","shadingNode","fillAttr","applyNamedStyles","getValue","complexSpacing","getLineSpacing","inRun","inParagaph","identation","First","Only","emphasis","Normal","Bold","Italic","smallCaps","SmallCaps","getIndentation","strike","doubleStrike","charSpacing","lineSpacing","color","caps","initial","parCb","runCb","getRecursive","tableCb","localRun","runParent","localPar","parRunStyle","parParent","tableStyle","table","basedOn","_initialized","updateFont","testSize","baseline","getTextWidth","testString","_foundFonts","family","testFont","tryAddFont","_getName","availableFonts","_notFoundFonts","widthOfChar","charWidth","averageCharWidth","floor","getFontMetrics","_testString","_testSize","metric","fontBoundingBoxAscent","fontBoundingBoxDescent","_topToBaseFactor","baseToBottomFactor","metrics","_fonts","metricStyle","WordSplitter","texts","_texts","_words","_split","_seperators","results","words","getSeperator","Tab","join","txt","seperators","charAt","Space","LineFeed","run","lastXPadding","_run","_lineHeight","lines","currentXPadding","_getInitialXPadding","isFollowing","_isFollowing","hasEmptyText","_fixYPosition","_fixAllCaps","splitter","strictFit","paragraphType","TableCell","tabIndex","previousIndex","currentLength","numAvailableChars","_getAvailableChars","isLastLine","seperator","isNewLine","isTab","reachedEndOfLine","_fitReasonably","_pushNewLine","combine","_getTabPadding","_getTabJustification","_getIndentation","_finalXPadding","inParagraph","xPadding","isLastRun","stretched","both","getY","getWidth","following","txts","map","toLocaleUpperCase","getTopToBaseline","previousXPos","_isFirstRun","padding","tab","getTab","fitCharacters","nextWord","graceNumber","_isLastRun","getBaselineToBottom","Size","Text","linkTarget","lastXPos","_lines","getUsedWidth","getHeight","maxWidth","getLines","line","Error","_getFlowLines","invisible","fitter","getFlowLines","runs","numberingRun","_type","_runs","_numberingRun","idx","foundRun","type","availableWidth","usedWidth","runsWidth","spacingAfter","spacingBefore","mentionParagraphPosition","startY","performLayout","isClear","removeTabStop","addTabStop","clonedFlow","clone","mentionCharacterPosition","_getLineSpacing","content","svgNS","clientWidth","_svg","_root","newText","_setFont","_setColor","_setHorizontalAlignment","_setVerticalAlignment","textNode","_lastText","rect","box","getBBox","x1","y1","x2","y2","thickness","dashing","_setDashing","path","fillColor","strokeColor","strokeThickness","pic","getImageUrl","then","SVGElement","g","image","catch","error","lastChild","parentElement","heightNum","a","Dashed","LongDash","DashedSmallGap","TableBorder","painter","paragraphRenderer","_painter","_parRenderer","rows","row","cells","cell","numRowsInSpan","renderCellShading","renderCellBorder","pars","par","renderParagraph","shading","paintLine","Solid","outerBorders","borders","innerBorders","cellSpacing","hasBordersDefined","_renderBorderPart","subtractSpacing","border","relativeSize","_renderBorderSubLines","Triple","ThickThinLargeGap","ThickThinMediumGap","ThickThinSmallGap","ThinThickLargeGap","ThinThickMediumGap","ThinThickSmallGap","ThinThickThinLargeGap","ThinThickThinMediumGap","ThinThickThinSmallGap","DashDotStroked","DashSmallGap","subLines","xDirection","yDirection","sub","startLink","_renderText","endLink","_getX","isBold","Boolean","isItalic","paintText","_renderUnderline","textRect","measureLastText","heavy","ChartStyle","lineColor","lineThickness","space","valueAxis","chart","series","hasNumericValues","valueRange","getValueRange","ceil","setValueRange","major","minor","isValueAxis","labelAlignment","crossMode","AutoZero","positionedTexts","positionedLines","_space","majorTickMode","minorTickMode","labelOffset","majorGridStyle","minorGridStyle","_isValueAxis","maxDistance","Bottom","Top","_labelSpacing","textStyle","maxChars","_getTexts","Outwards","_majorOutwardLength","_minorOutwardLength","textLines","plotBounds","plotArea","_hasNumericValues","_getMajorValues","reverse","halfLineSpacing","segmentHeight","currentY","textX","lineX1","lineX2","_createPositionedText","numSegments","applyTextDelta","chartType","Bar","halfSegmentWidth","currentX","textY","lineY1","lineY2","hasNumericCategories","_getCategoryNames","categories","cat","_numMajorTicks","overlayOnPlot","onlySeries","_widgetSize","_widgetSpacing","_getNames","_getSize","spaceBounds","placeInRectangle","colors","names","_promise","_chart","legend","setLineSpacing","areaChart","Area","lineChart","Line","barChart","pieChart","Pie","promise","ensureLoaded","_flow","async","_reject","_performLayout","setPromise","determineRange","_layoutLegend","_subtractAxis","categoryAxis","axis","distance","getMaxDistanceFromPlot","Angle","degrees","_degrees","rad","norm","fullCircle","MultiplyDevideFormula","z","guide","AddSubtractFormula","AddDevideFormula","IfElseFormula","AbsoluteFormula","abs","ArcTanFormula","atan2","CosineArcTanFormula","cos","CosineFormula","getAngleValue","toRadians","MaximumFormula","MinimumFormula","ModuloFormula","sqrt","PinFormula","SineArcTanFormula","sin","SineFormula","SquareRootFormula","TangentFormula","tan","LiteralValueFormula","FunctionFormula","func","shape","_formulas","_variables","formula","parts","form","statement","test","_getVariableValue","fromRotation","_evaluateVariable","find","current","_createNamedVariable","_shape","fromNormalized","toRotation","Number","NaN","evaluate","radiusX","radiusY","angle","radians","radius","_localRadius","localRadius","b","_offset","_scaling","scaling","convertToPoint","scale","translate","_guide","_startPoint","MoveTo","super","convertPoint","LineTo","sweepAngle","startAngle","overrideSweepAngle","_getAngleValue","fromSinglePoint","pointAtAngle","add","clockwise","_clockwise","getEndPoint","_fullRotation","midPoint","_buildInternalPath","variable","addFullRound","toNormalized","CubicBezierTo","control1","control2","control","cubic1","difference","cubic2","filledIn","stroked","segments","_path","segment","currentPoint","buildPath","substr","paths","moveTo","lineTo","arcTo","quadBezierTo","cubicBezierTo","close","scalingX","scalingY","topLeft","_renderBorderAndShading","_renderLegend","_renderAxis","_renderBarChart","_renderLineChart","_renderAreaChart","_renderPieChart","yMax","yMid","getColors","widgetSize","widgetX","widgetSpacing","widgetY","counts","getCounts","catSpacing","numSeries","flowX","topY","bottomY","range","seriesIndex","addSegmentMove","fromPoint","bottomLeft","catIndex","numCats","_normalizeValue","addSegmentLine","bottomRight","paintPolygon","previousVal","getSeriesStyle","seriesSpacing","middle","getValueSum","circle","previousAngle","subtract","addSegmentArc","numeric","_chartRenderer","drawing","picture","picBounds","paintPicture","renderChartSpace","wrapping","getBox","Floating","_addObstacle","TopAndBottom","MathRenderer","equation","objects","obj","render","MathRun","_size","getSize","_textRenderer","_drawingRenderer","_mathRenderer","renderTextRun","renderDrawing","renderMathRun","_paragraphRenderer","_tableRenderer","docx","fromSection","setWidth","paragraphs","parOrTable","renderTable","getMaxY","clear","ensureHeight","XmlPart","jsZip","package","arrayBuffer","_loadFromArrayBuffer","pack","err","files","file","endsWith","reader","FileReader","e2","target","result","readAsArrayBuffer","byteLength","JSZip","loadAsync","unzipped","_loadContentTypes","partContent","partXml","loadPartAsXml","contentTypePart","getRootNode","partName","contentType","replace","ChartContentType","WordDocumentContentType","WordFontTableContentType","WordNumberingContentType","WordSettingsContentType","WordStylesContentType","ExtendedPropertiesContentType","CorePropertiesContentType","RelationshipsContentType","JpegContentType","PngContentType","part","named","_docDefaultStyle","styleType","fromStyleNode","styleId","fromDocDefaultsNode","_doc","sectionNode","parseContent","_pageHeight","_pageWidth","_marginTop","_marginLeft","_marginBottom","_marginRight","defaultHorPadding","_getValue","_justification","_identation","_borders","_margins","_cellSpacing","_columnSpan","columnSpan","_rowSpan","rowSpan","_shading","defaultValue","cb","higherStyle","columns","getPars","maxHeight","rowIndex","columnIndex","rowSpanOrder","_updateRowSpan","cellIndex","_getHeightOfRowSpan","startRowIndex","numRows","currentRow","TableColumn","order","rowOrder","cellHeight","startColumnIndex","_columns","_allColumns","_startColumnIndex","_getColumns","_getWidth","columnOrder","_getColumnOrder","_contentBounds","subtractBordersAndMargins","contentHeight","_performInnerLayout","addBordersAndMargins","slice","col","cellFlow","copyObstaclesFrom","numAllColumns","numColumns","runNode","presentationNode","hasChildNodes","textContent","_pack","_name","picNode","blipFill","blip","relId","relationships","getTarget","_imageUrl","fileParts","fileExtension","binaryProc","mimeType","_hasTiffSupport","_getImageUrlForTiff","_hasWmfSupport","_getImageUrlForWmf","_hasEmfSupport","_getImageUrlForEmf","loadPartAsBase64","loadPartAsBinary","buffer","UTIF","_bounds","ifds","decode","vsns","ma","page","subIFD","concat","img","ar","decodeImage","rgba","toRGBA8","_xhrs","splice","imgd","createImageData","data","putImageData","toDataURL","EMFJS","loggingEnabled","renderer","Renderer","settings","xExt","yExt","mapMode","WMFJS","numValues","values","_rangeMax","_rangeMin","MIN_VALUE","MAX_VALUE","num","categoryIndex","orientation","Horizontal","ChartValue","str","count","PresetShapeFactory","creators","creator","shapeNode","_readCustomShape","_readPresetShape","_readFillColor","firstChild","pathNode","fill","stroke","addPath","segmentNode","nodeType","Node","ELEMENT_NODE","_addAngle","movePointNode","_readPoint","linePointNode","_addCubicBezier","_addQuadBezier","addSegmentClose","presetNode","_presetFactory","createShape","customNode","pathListNode","readPath","widthAttr","heightAttr","fillNode","colorNode","addSegmentQuadBezier","addSegmentCubicBezier","pointNode","xAttr","yAttr","shapePropNode","frame","convertRotationToRadians","convertEmuToPixels","_readExtent","inlineNode","_readHorizontalPosition","_readVerticalPosition","anchorNode","horPos","_readPositionReference","referenceOffset","_readPositionReferenceOffset","_readPositionAlignment","vertPos","relativeFrom","StartMargin","EndMargin","InsideMargin","OutsideMargin","Margin","Page","alignNode","End","Inside","Outside","offsetNode","extent","extentX","extentY","drawingNode","wrapMode","fromAnchorNode","fromInlineNode","graphic","graphicData","_readGraphicData","childNode","fromPicNode","relationship","chartTarget","readChartFromPart","shapeReader","readShape","readingPromise","readChartFromDocument","chartSpaceNode","chartNode","_readStyle","_readPlotArea","_readLegend","plotAreaNode","setAreaChart","_readAreaChart","setLineChart","_readLineChart","setBarChart","_readBarChart","setPieChart","_readPieChart","_readChartAxis","legendNode","_parsePosition","overlay","getBooleanValueFromNode","lineChartNode","_readChartSeries","barChartNode","pieChartNode","angleAttr","axisNode","valAttr","_parseTickMode","_parseLabelAlignment","_parseCrossMode","seriesNode","catStyles","_readStringReference","refName","stringCat","_readNumericReference","numValue","stringValue","getNumberValueFromNode","strRefNode","ref","strCacheNode","valueNode","numRefNode","numCacheNode","tickAttr","tickMode","posMode","_alignAttr","_crossAttr","readChartFromNode","_style","_getIndices","getPrefixText","_advanceIndex","maxIndex","getNumbering","advanceNumbering","Equation","NAryStyle","char","hideSub","hideSuper","MathObject","_list","unshift","addHorizontal","_char","sup","elem","_sub","_super","_elem","elemSize","superSize","subSize","addVertical","delimiterStyle","_begin","beginChar","_end","endChar","DelimiterStyle","numerator","denumerator","_numerator","_denumerator","denominatorSize","numeratorSize","numPadding","denPadding","FractionStyle","NoBar","typeStr","Skewed","Linear","MatrixStyle","baseJustification","hidePlaceholder","rowSpacingRule","rowSpacing","columnGapRule","columnGap","columnMinimalWidth","columnStyles","jcStr","rowSize","_xPadding","FunctionStyle","functionName","_functionName","nameSize","RadicalStyle","hideDegree","degree","_degree","_radical","sdtNode","contentNode","readParagraph","pNode","readStyle","linkId","readDrawingRun","choiceNode","chosenNode","readTextRun","styles","mathRun","mathNode","_readMathElement","naryNode","grandChild","_readNAryStyle","delNode","_readDelimiterStyle","fracNode","_readFractionStyle","setType","_readFunctionStyle","matrixNode","_readMatrixStyle","setJustification","_readMatrixSpacingRule","_readMatrixColumnStyleList","_ruleNode","columnsNode","_readMatrixColumnStyle","columnNode","_readRadicalStyle","_readNAryObject","_readDelimiterObject","_readRunObject","_readFractionObject","_readMatrixObject","_readFunctionObject","_readRadicalObject","fromMathNode","firstRun","lastRun","parPrNode","tableNode","readTableRow","setOrder","readTableStyle","w","rowNode","rowStyle","colIndex","cellNode","readTableCell","readTableCellPresentation","cellPrNode","cellStyle","readBorders","readCellMargins","vMerge","bordersNode","readTableBorder","borderHorizontal","borderVertical","cellMarginNode","borderNode","parseTableBorderType","sz","input","borderType","DoubleWave","Inset","Outset","Emboss3D","Engrave3D","tblPrNode","readTable","_section","sdtPars","readStructuredDocumentTag","_rels","_styles","_numberings","_coreProperties","coreProperties","format","none","suffix","_romanCodes","levelNode","getFormatted","bullet","decimal","lowerLetter","_toDecimal","upperLetter","lowerRoman","_toRoman","upperRoman","String","fromCharCode","numeral","digits","_levels","fromLevelNode","abstractNumberings","abstractNumId","fromAbstractNumNode","numNode","relations","relsNode","relNode","_shapeReader","readPresetShapeDefinition","defNode","_readShapeGuideList","_readPathList","defineShape","shapeGuideListNode","_readShapeGuide","shapeGuideNode","fmla","addFormula","CoreProperties","created","description","language","lastModifiedBy","lastModified","lastPrinted","revision","subject","title","keywords","propsNode","propNode","_parseDateString","year","month","day","hour","sec","Date","UTC","_init","loadFromUrl","_loadFromPackage","loadFromFile","relPart","fromDocument","stylePart","core","hasPart","numPart","_loadDocument","setRelationships","setNamedStyles","setCoreProperties","setNumberings","posY","renderDocument","init","readPresetShapeDefinitions"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAiB,QAAID,IAErBD,EAAc,QAAIC,IARpB,CASGK,MAAM,WACT,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,+BClFrD,IAAYC,ECIAC,EAOAC,EAuBAC,EC7BAC,EAKAC,ECJAC,ECGAC,EAOAC,ECXAC,ECJAC,ECKAC,ECIAC,ECTAC,ECKAC,EAOAC,EAKAC,EAIAC,ECRAC,ECNAC,ECLAC,ECDAC,ECAAC,EASAC,EAQAC,ECfAC,EAiBAC,E,gDhBrBZ,SAAY1B,GACR,uBACA,qBACA,mBACA,mBACA,yBALJ,CAAYA,MAAU,KiBAf,MAAM2B,EAIT,YAAYC,EAAWC,GACnBjE,KAAKgE,EAAIA,EACThE,KAAKiE,EAAIA,EAGN,kBAAkBC,EAAmBC,GACxC,OAAO,IAAIJ,EAAMG,EAAWF,EAAIG,EAASH,EAAGE,EAAWD,EAAIE,EAASF,GAGjE,UAAUG,GACb,OAAO,IAAIL,EAAM/D,KAAKgE,EAAII,EAAOJ,EAAGhE,KAAKiE,EAAIG,EAAOH,GAGjD,MAAMI,GACT,IAAIC,EACAC,EAQJ,OAPIF,aAAkBN,GAClBO,EAAUD,EAAOL,EACjBO,EAAUF,EAAOJ,IAEjBK,EAAUD,EACVE,EAAUF,GAEP,IAAIN,EAAM/D,KAAKgE,EAAIM,EAAStE,KAAKiE,EAAIM,GAGzC,WACH,MAAO,IAAIvE,KAAKgE,MAAMhE,KAAKiE,KAGxB,QACH,OAAO,IAAIF,EAAM/D,KAAKgE,EAAGhE,KAAKiE,IC9B/B,MAAM,EAMT,YAAYD,EAAWC,EAAWO,EAAeC,GAC7CzE,KAAKgE,EAAIA,EACThE,KAAKiE,EAAIA,EACTjE,KAAKwE,MAAQA,EACbxE,KAAKyE,OAASA,EAGlB,WACI,OAAOzE,KAAKgE,EAGhB,UACI,OAAOhE,KAAKiE,EAGhB,YACI,OAAOjE,KAAKgE,EAAIhE,KAAKwE,MAGzB,aACI,OAAOxE,KAAKiE,EAAIjE,KAAKyE,OAGzB,cACI,OAAO,IAAIV,EAAM/D,KAAK0E,KAAM1E,KAAK2E,KAGrC,eACI,OAAO,IAAIZ,EAAM/D,KAAK4E,MAAO5E,KAAK2E,KAGtC,iBACI,OAAO,IAAIZ,EAAM/D,KAAK0E,KAAM1E,KAAK6E,QAGrC,kBACI,OAAO,IAAId,EAAM/D,KAAK4E,MAAO5E,KAAK6E,QAG/B,UAAUb,EAAWC,GACxB,OAAO,IAAI,EAAIjE,KAAKgE,EAAIA,EAAGhE,KAAKiE,EAAIA,EAAGjE,KAAKwE,MAAOxE,KAAKyE,QAGrD,UAAUC,EAAcC,EAAaC,EAAeC,GACvD,OAAO,IAAI,EAAI7E,KAAKgE,EAAIU,EAAM1E,KAAKiE,EAAIU,EAAK3E,KAAKwE,MAAQE,EAAOE,EAAO5E,KAAKyE,OAASE,EAAME,GAGxF,qBAAqBC,EAAqBC,EAAyBC,EAAuBC,GAC7F,MAAMC,QAA8BC,IAApBL,EAAIM,YAA6BN,EAAIM,YAAYC,KAAO,GAAKN,EAAQO,gBAC/EC,QAA0BJ,IAAlBL,EAAIU,UAA2BV,EAAIU,UAAUH,KAAO,GAAKN,EAAQU,cACzEd,QAA0BQ,IAAlBL,EAAIY,UAA2BZ,EAAIY,UAAUL,KAAO,GAAKN,EAAQY,cACzEd,QAAgCM,IAArBL,EAAIc,aAA8Bd,EAAIc,aAAaP,KAAO,GAAKN,EAAQc,iBACxF,OAAO7F,KAAK8F,UAAUZ,EAAOP,EAAKY,EAAKV,GAGpC,WAAWkB,GACd,OAAO/F,KAAK8F,UAAUC,EAASA,EAASA,EAASA,GAG9C,eAAerB,EAAcC,EAAaC,EAAeC,GAC5D,OAAO,IAAI,EAAI7E,KAAKgE,EAAIU,EAAM1E,KAAKiE,EAAIU,EAAK3E,KAAKwE,MAAQE,EAAOE,EAAO5E,KAAKyE,OAASE,EAAME,GAGxF,0BAA0BC,EAAqBC,EAAyBC,EAAuBC,GAClG,MAAMC,QAA8BC,IAApBL,EAAIM,YAA6BN,EAAIM,YAAYC,KAAO,GAAKN,EAAQO,gBAC/EC,QAA0BJ,IAAlBL,EAAIU,UAA2BV,EAAIU,UAAUH,KAAO,GAAKN,EAAQU,cACzEd,QAA0BQ,IAAlBL,EAAIY,UAA2BZ,EAAIY,UAAUL,KAAO,GAAKN,EAAQY,cACzEd,QAAgCM,IAArBL,EAAIc,aAA8Bd,EAAIc,aAAaP,KAAO,GAAKN,EAAQc,iBACxF,OAAO7F,KAAKgG,eAAed,EAAOP,EAAKY,EAAKV,GAGzC,gBAAgBkB,GACnB,OAAO/F,KAAKgG,eAAeD,EAASA,EAASA,EAASA,GAKnD,aAAaE,EAAsBC,GACtC,MAAMlC,EAAKiC,aAAgBlC,EAASkC,EAAKjC,EAAIiC,EACvChC,EAAKgC,aAAgBlC,EAASkC,EAAKhC,EAAIiC,EACvCC,EAAOC,KAAKC,IAAIrG,KAAKgE,EAAGA,GACxBsC,EAAOF,KAAKC,IAAIrG,KAAKiE,EAAGA,GACxBsC,EAAWH,KAAKI,IAAIxG,KAAKgE,EAAIhE,KAAKwE,MAAOR,EAAIhE,KAAKwE,OAAS2B,EAC3DM,EAAYL,KAAKC,IAAIrG,KAAKiE,EAAIjE,KAAKyE,OAAQR,EAAIjE,KAAKyE,QAAU6B,EACpE,OAAO,IAAI,EAAIH,EAAMG,EAAMC,EAAUE,GAGlC,iBAAiBjC,EAAeC,EAAgBiC,EAAkBC,GACrE,IAAI3C,EAAI,EACJC,EAAI,EAWR,OAVIyC,IAAStE,EAAWwE,OACpB5C,EAAIhE,KAAKgE,EAAKhE,KAAKwE,MAAQ,EAAMA,EAAQ,EAClCkC,IAAStE,EAAWyE,OAC3B7C,EAAIhE,KAAK4E,MAAQJ,GAEjBmC,IAASvE,EAAWwE,OACpB3C,EAAIjE,KAAKiE,EAAKjE,KAAKyE,OAAS,EAAMA,EAAS,EACpCiC,IAAStE,EAAWyE,OAC3B5C,EAAIjE,KAAK6E,OAASJ,GAEf,IAAI,EAAIT,EAAGC,EAAGO,EAAOC,GAGzB,WAAWqC,EAAYf,EAAkB,GAC5C,MAAMvB,EAAQ4B,KAAKI,IAAIxG,KAAKwE,MAAOsC,EAAMtC,OACnCC,EAASzE,KAAKyE,OAASqC,EAAMrC,OAASsB,EAC5C,OAAO,IAAI,EAAI/F,KAAKgE,EAAGhE,KAAKiE,EAAGO,EAAOC,GAGnC,aAAaqC,EAAYf,EAAkB,GAC9C,MAAMvB,EAAQxE,KAAKwE,MAAQsC,EAAMtC,MAAQuB,EACnCtB,EAAS2B,KAAKI,IAAIxG,KAAKyE,OAAQqC,EAAMrC,QAC3C,OAAO,IAAI,EAAIzE,KAAKgE,EAAGhE,KAAKiE,EAAGO,EAAOC,GAGnC,WAAWT,GACd,OAAOhE,KAAK0E,MAAQV,GAAKhE,KAAK4E,OAASZ,EAGpC,WAAWC,GACd,OAAOjE,KAAK2E,KAAOV,GAAKjE,KAAK6E,QAAUZ,EAGpC,eAAe8C,GAClB,OAAO/G,KAAKgH,WAAWD,EAAM/C,IAAMhE,KAAKiH,WAAWF,EAAM9C,GAGtD,QACH,OAAO,IAAI,EAAIjE,KAAKgE,EAAGhE,KAAKiE,EAAGjE,KAAKwE,MAAOxE,KAAKyE,QAG7C,WACH,MAAO,IAAIzE,KAAKgE,MAAMhE,KAAKiE,MAAMjE,KAAKwE,UAAUxE,KAAKyE,YjB3I7D,SAAYpC,GAER,uBAEA,2BAJJ,CAAYA,MAAe,KAO3B,SAAYC,GAER,mBAEA,6BAEA,uBAEA,6BAEA,mCAEA,uBAEA,qCAEA,mBAEA,6BAEA,iCApBJ,CAAYA,MAAsB,KAuBlC,SAAYC,GAER,iBAEA,uBAEA,uBAEA,yBAEA,qBAVJ,CAAYA,MAAsB,KAa3B,MAAM,EAAb,cACW,KAAA2E,QAAkB,EAClB,KAAAC,QAAkB,EAClB,KAAAC,WAAa9E,EAAuB+E,KACpC,KAAAC,WAAahF,EAAuB+E,KACpC,KAAAE,iBAA2B,EAC3B,KAAAC,iBAA2B,EAC3B,KAAAC,OAASlF,EAAuBmF,MAChC,KAAAC,OAASpF,EAAuBmF,MAChC,KAAAE,MAAgB,EAChB,KAAAC,MAAgB,EAChB,KAAAC,gBAAiB,EACjB,KAAAC,cAAe,EACf,KAAAC,SAAW,EACX,KAAAC,OAAS5F,EAAgB6F,OAEzB,OAAOC,GACV,MAAMjD,EAAQlF,KAAKoI,eAAeD,GAClC,OAAO,IAAI,EAAIjD,EAAMlB,EAAGkB,EAAMjB,EAAGjE,KAAK4H,MAAO5H,KAAK6H,OAG9C,eAAeM,GACnB,IAAInE,EAAImE,EAAKE,cAAcrI,KAAKoH,WAAYpH,KAAK4H,OAC7C3D,EAAIkE,EAAKG,cAActI,KAAKsH,YAChC,OAAQtH,KAAKoH,YACT,KAAK9E,EAAuB+E,KACxBrD,GAAKhE,KAAKkH,QACV,MACJ,KAAK5E,EAAuBiG,OAC5B,QACIvE,GAAKhE,KAAKuH,iBAGlB,OAAQvH,KAAKsH,YACT,KAAKhF,EAAuB+E,KACxBpD,GAAKjE,KAAKmH,QACV,MACJ,KAAK7E,EAAuBkG,UAC5B,QACIvE,GAAKjE,KAAKwH,iBAGlB,OAAO,IAAIzD,EAAMC,EAAGC,IkBpF5B,MAAMwE,EAIF,YAAYC,EAAaC,GAAsB,GAC3C3I,KAAK0I,OAASA,EACd1I,KAAK2I,WAAaA,GAInB,MAAM,EAqCT,YAAYC,EAAcC,EAAcC,EAAmB,GA/BnD,KAAAC,YAAsB,EACtB,KAAAC,WAAqB,EACrB,KAAAC,OAAoB,GACpB,KAAAC,MAAa,GACb,KAAAC,WAAyB,GA4B7BnJ,KAAKoJ,MAAQR,EACb5I,KAAKqJ,MAAQR,EACb7I,KAAKsJ,KAAOR,EA5BT,mBAAmBS,GACtB,MAAMpB,EAAO,IAAI,EAAY,GAAI,KAGjC,QAAgBhD,IAAZoE,EAAuB,CACvB,IAAIC,EAAY,SACUrE,IAAtBoE,EAAQC,YACRA,EAAYD,EAAQC,WAELD,EAAQE,WAA3B,MAIMC,EAAaH,EAAQG,gBACRvE,IAAfuE,IACAvB,EAAKiB,MAAQM,GAEjB,MAAMC,EAAcJ,EAAQI,iBACRxE,IAAhBwE,IACAxB,EAAKkB,MAAQG,EAAYG,GAGjC,OAAOxB,EASJ,KAAKyB,EAAqB,GAC7B,IAAI5F,EAAIhE,KAAKoJ,MACb,MAAMS,EAAW7J,KAAK8J,yBACtB,QAAiB3E,IAAb0E,EAAwB,CAETA,EAASnB,OAAOlE,OAAWxE,KAAKqJ,MAAQrJ,KAAKoJ,MAASQ,EAEjE5J,KAAK+J,gBAAgBF,EAASnB,OAAOjE,QAGrCT,EAAI6F,EAASnB,OAAO9D,MAG5B,OAAOZ,EAGJ,cAAcgG,EAAmCxF,GACpD,IAAIR,EAAIhE,KAAKiK,KAAKzF,GAElB,OAAOwF,GACH,KAAK1H,EAAuB4H,UACxBlG,EAAIhE,KAAKgJ,WACT,MACJ,KAAK1G,EAAuB+E,KAC5B,KAAK/E,EAAuBiG,OAC5B,QACIvE,EAAIhE,KAAKoJ,MAGjB,OAAOpF,EAGJ,OACH,OAAOhE,KAAKsJ,KAGT,QAAQa,GACX,IAAIC,EAAOpK,KAAKsJ,KAMhB,OALAtJ,KAAKmJ,WAAWkB,QAAQR,MACfA,EAASlB,YAAewB,GAAmBN,EAASlB,cACrDyB,EAAOhE,KAAKI,IAAI4D,EAAMP,EAASnB,OAAO7D,WAGvCuF,EAGJ,cAAcJ,GACjB,IAAIM,EAAMtK,KAAKsJ,KAEf,OAAOU,GACH,KAAK1H,EAAuBkG,UACxB8B,EAAMtK,KAAK+I,YACX,MACJ,QACIuB,EAAMtK,KAAKsJ,KAGnB,OAAOgB,EAGJ,WACH,IAAI9F,EAAQxE,KAAKqJ,MAAQrJ,KAAKoJ,MAC9B,MAAMS,EAAW7J,KAAK8J,yBAItB,YAHiB3E,IAAb0E,IACArF,GAASqF,EAASnB,OAAOlE,OAEtBA,EAGJ,YAAYkE,EAAaC,GAC5B3I,KAAKmJ,WAAWoB,KAAK,IAAI9B,EAASC,EAAQC,IAGvC,kBAAkB7B,GACrBA,EAAMqC,WAAWkB,QAAQR,GACd7J,KAAKwK,YAAYX,EAASnB,OAAQmB,EAASlB,aAInD,SAAS8B,EAAoBC,GAGhC,OAFA1K,KAAKoJ,OAASqB,EACdzK,KAAKqJ,OAASoB,EAAaC,EACpB1K,KAGJ,gBAAgB2K,GAEnB,OADA3K,KAAKsJ,MAAQqB,EACN3K,KAGJ,iBAAiB4K,EAAeC,GACnC,MAAMC,EAAK,GAAGF,KAASC,IACjBE,EAAa/K,KAAKkJ,MAAM4B,GAE1B9K,KAAKkJ,MAAM4B,QADI3F,IAAf4F,EACiB,EAEAA,EAAa,EAI/B,aAAaH,EAAeC,GAC/B,MAAMC,EAAK,GAAGF,KAASC,IACvB,OAAO7K,KAAKkJ,MAAM4B,IAAO,EAGtB,OAAOE,GACV,OAAOhL,KAAKiJ,OAAO+B,GAGhB,WAAWC,GACdjL,KAAKiJ,OAAOsB,KAAKU,GAGd,gBACHjL,KAAKiJ,OAAOiC,MAGT,2BACHlL,KAAK+I,YAAc/I,KAAKsJ,KAGrB,yBAAyB6B,GAC5BnL,KAAKgJ,WAAahJ,KAAKoJ,MAAQ+B,EAG5B,QACH,MAAMC,EAAS,IAAI,EAAYpL,KAAKoJ,MAAOpJ,KAAKqJ,MAAOrJ,KAAKsJ,MAI5D,OAHA8B,EAAOnC,OAASjJ,KAAKiJ,OACrBmC,EAAOlC,MAAQlJ,KAAKkJ,MACpBkC,EAAOjC,WAAanJ,KAAKmJ,WAClBiC,EAGH,yBACJ,IAAIC,OAA8BlG,EAClC,IAAK,IAAI/E,EAAI,EAAGA,EAAIJ,KAAKmJ,WAAWmC,OAAQlL,IACxC,GAAIJ,KAAKmJ,WAAW/I,GAAGsI,OAAOzB,WAAWjH,KAAKsJ,MAAO,CACjD+B,EAAQrL,KAAKmJ,WAAW/I,GACxB,MAGR,OAAOiL,GCrMR,MAAME,EAMJ,4BAA4BC,GAOjC,OAAOA,EAAQ,GAOV,4BAA4BC,GACjC,OAAOF,EAAQG,qBAA8B,GAATD,GAO/B,0BAA0BE,GAI/B,OAAOJ,EAAQK,qBAAqBD,EAAM,OAOrC,8BAA8BF,GACnC,OAAgB,GAATA,EAAc,GAOhB,gCAAgCI,GACrC,OAAQA,EAAMzF,KAAK0F,GAAM,MAGpB,oBAAoBC,EAAcC,GACvC,OAAOhM,KAAKiM,uBAAuBF,EAAMC,GAGpC,2BAA2BD,EAAcC,GAC9C,IAAIE,EAAUC,SAASC,gBAAgB,6BAA8B,QACrEF,EAAQG,aAAa,cAAeL,EAAMM,YAC1CJ,EAAQG,aAAa,YAAa,GAAGL,EAAMO,UACvCP,EAAMQ,MACRN,EAAQG,aAAa,cAAe,QAElCL,EAAMS,QACRP,EAAQG,aAAa,aAAc,UAErC,MAAMK,EAAOP,SAASQ,eAAeZ,GACrCG,EAAQU,YAAYF,GACpB1M,KAAK6M,IAAID,YAAYV,GACrB,MAAM1H,EAAQ0H,EAAQY,wBAItB,OADA9M,KAAK6M,IAAIE,YAAYb,GACd1H,EAGF,8BACLuH,EACAC,GAGA,OADgBhM,KAAKgN,eAAejB,EAAMC,GAC3BxH,MAGV,sBAAsBuH,EAAcC,GACzC,MAAMiB,EAAcjB,EAAY,OAAI,UAAW,GACzCkB,EAAYlB,EAAU,KAAI,QAAS,GAGzC,OAFAhM,KAAKmN,QAAQC,KAAOH,EAAaC,EAAW9G,KAAKiH,MAAMrB,EAAMO,UAAY,MAAQP,EAAMM,WACvEtM,KAAKmN,QAAQG,YAAYvB,GAIpC,mBACe5G,IAAhBnF,KAAKuN,SACPvN,KAAKuN,OAASpB,SAASqB,cAAc,UACrCxN,KAAKmN,QAAUnN,KAAKuN,OAAOE,WAAW,MACtCzN,KAAK6M,IAAMV,SAASC,gBAAgB,6BAA8B,OAClEpM,KAAK6M,IAAIR,aAAa,QAAS,QAC/BrM,KAAK6M,IAAIR,aAAa,SAAU,OAChCrM,KAAK6M,IAAIR,aAAa,aAAc,UACpCF,SAASuB,KAAKd,YAAY5M,KAAK6M,OCrG9B,MAAMc,EAEF,mBAAmBC,GACtB,OAAO,IAAIC,QAAkB,CAACC,EAASC,KACnC,IAAIC,EAAO,IAAIC,eACfD,EAAKE,KAAK,MAAON,GAAK,GACtBI,EAAKG,aAAe,OAEpBH,EAAKI,OAAUC,IACX,GAAoB,MAAhBL,EAAKM,OAAgB,CACrB,IAAIvC,EAAOiC,EAAKO,SAChB,MAAMC,GAAM,IAAIC,WAAYC,gBAAgB3C,EAAM,mBAClD+B,EAAQU,QAERT,EAAO,mBAAmBH,IAGlCI,EAAKW,QAAWC,IACZb,EAAOa,IAEXZ,EAAKa,KAAK,QASX,oBAAoBnC,EAAY/L,GACnC,IAAImO,OAA0B3J,EAC9B,MACM4J,EADUrC,EACQsC,aAAarO,GAIrC,OAHgB,OAAZoO,IACAD,EAAMC,GAEHD,EAQJ,2BAA2BG,EAActO,GAC5C,IAAKuO,MAAMC,QAAQxO,GACf,OAAOX,KAAKoP,oBAAoBH,EAAQ,CAACtO,IAE7C,IAAI0O,OAA+BlK,EACnC,MAAMmK,EAAWL,EAAOM,WACxB,IAAK,IAAInP,EAAI,EAAGA,EAAIkP,EAAShE,OAAQlL,IACjC,IAA4C,IAAxCO,EAAK6O,QAAQF,EAASlP,GAAGqP,UAAkB,CAC3CJ,EAAQC,EAASlP,GACjB,MAGR,OAAOiP,EAMJ,sBAAsB3C,GACzB,IAAIoC,OAA0B3J,EAC1BuK,EAAO/B,EAAIqB,aAAatC,EAAM,SAclC,YAbavH,IAATuK,EACAZ,EAAMY,GAENA,EAAO/B,EAAIqB,aAAatC,EAAM,YACjBvH,IAATuK,EACAZ,EAAMY,GAENA,EAAO/B,EAAIqB,aAAatC,EAAM,cACjBvH,IAATuK,IACAZ,EAAMY,KAIXZ,EAMJ,8BAA8BG,EAAmBtO,GACpD,IAAImO,OAA0B3J,EAC9B,MAAMkK,EAAQ1B,EAAIyB,oBAAoBH,EAAQtO,GAI9C,YAHcwE,IAAVkK,IACAP,EAAMnB,EAAIgC,eAAeN,IAEtBP,EAMJ,uBAAuBpC,GAC1B,IAAIoC,OAA2B3J,EAC/B,MAAMuK,EAAO/B,EAAIgC,eAAejD,GAOhC,OALIoC,OADS3J,IAATuK,GACM/B,EAAIiC,mBAAmBF,GAK1BZ,EAMJ,+BAA+BG,EAAmBtO,GACrD,IAAImO,OAA2B3J,EAC/B,MAAMkK,EAAQ1B,EAAIyB,oBAAoBH,EAAQtO,GAI9C,YAHcwE,IAAVkK,IACAP,EAAMnB,EAAIkC,gBAAgBR,IAEvBP,EAMJ,sBAAsBpC,GACzB,IAAIoC,OAA0B3J,EAC9B,MAAMuK,EAAO/B,EAAIgC,eAAejD,GAIhC,YAHavH,IAATuK,IACAZ,EAAMgB,WAAWJ,IAEdZ,EAMJ,8BAA8BG,EAAmBtO,GACpD,IAAImO,OAA0B3J,EAC9B,MAAMkK,EAAQ1B,EAAIyB,oBAAoBH,EAAQtO,GAI9C,YAHcwE,IAAVkK,IACAP,EAAMnB,EAAIoC,eAAeV,IAEtBP,EAMJ,0BAA0BY,GAC7B,MAAiB,SAATA,GAA8B,MAATA,GC/I9B,MAAM,EAmBT,YAAY9E,EAAeoF,GACvBhQ,KAAK4K,MAAQA,EACb5K,KAAKiQ,YAAcD,EAhBhB,+BAA+BE,GAClC,IAAIlE,OAAoC7G,EACxC,GAAI+K,EAAW,CACX,MAAMC,EAAYxC,EAAIyC,uBAAuBF,EAAW,UAClDG,EAAY1C,EAAIyC,uBAAuBF,EAAW,WACxD,QAAkB/K,IAAdgL,QAAyChL,IAAdkL,EAAyB,CACpD,MAAMrF,EAAQsF,SAASH,GACjBvF,EAAQ0F,SAASD,GACvBrE,EAAQ,IAAI,EAAepB,EAAOI,IAG1C,OAAOgB,EAQJ,cAAcuE,GACjB,OAAQvQ,KAAU,MAAIA,KAAK6K,MAAM2F,QAAQD,GAAW,GAGxD,YACI,IAAIvE,OAA2B7G,EAI/B,YAHmBA,IAAfnF,KAAK6K,QACLmB,EAAQhM,KAAK6K,MAAMmB,OAEhBA,EAGJ,gBAAgByE,GACnB,QAAmBtL,IAAfsL,EAA0B,CAC1B,MAAMC,EAAYD,EAAWE,iBAAiB3Q,KAAK4K,YACjCzF,IAAduL,EACA1Q,KAAK6K,MAAQ6F,EAAUE,SAAS5Q,KAAKiQ,aAErCY,QAAQC,IAAI,+BAA+B9Q,KAAK4K,UpB1ChE,SAAYpI,GACR,mBACA,iBAFJ,CAAYA,MAAS,KAKrB,SAAYC,GACR,qBACA,mBACA,qBACA,uBACA,6BALJ,CAAYA,MAAY,KAQjB,MAAM,EA+DT,YAAY6H,EAAayG,EAAqBC,GA9DvC,KAAAlI,cAA+B3D,EAC/B,KAAA6L,OAAoBxO,EAAU6E,KA8DjCrH,KAAKsJ,KAAOgB,EACZtK,KAAKiR,WAAaF,EAClB/Q,KAAKgR,OAASA,EA5DX,oBAAoBE,GACvB,MAAMC,EAAmB,GAazB,OAZAD,EAAS3B,WAAWlF,QAAQ+G,IACxB,MAAMC,EAAW1D,EAAIgC,eAAeyB,GAC9BE,EAAa3D,EAAIqB,aAAaoC,EAAS,YACvCG,EAAU5D,EAAIqB,aAAaoC,EAAS,SAC1C,QAAiBjM,IAAbkM,QAAsClM,IAAZoM,EAAuB,CACjD,MAAMC,EAAYxR,KAAKyR,kBAAkBJ,GACnCL,EAAShR,KAAK0R,eAAeJ,GAC7BhH,EAAMiB,EAAQG,qBAAqB4E,SAASiB,IAC5CI,EAAO,IAAI,EAAQrH,EAAKkH,EAAWR,GACzCG,EAAM5G,KAAKoH,MAGZR,EAGH,yBAAyBJ,GAC7B,IAAIS,EAAY/O,EAAamP,KAC7B,OAAQb,EAAMc,eACV,IAAK,MACDL,EAAY/O,EAAaqP,UACzB,MACJ,IAAK,SACDN,EAAY/O,EAAasP,OACzB,MACJ,IAAK,QACDP,EAAY/O,EAAauP,MACzB,MACJ,IAAK,OACDR,EAAY/O,EAAamP,KACzB,MACJ,IAAK,QACL,IAAK,UACDJ,EAAY/O,EAAawP,MACzB,MACJ,QACIpB,QAAQC,IAAI,4CAA4CC,GAGhE,OAAOS,EAGH,sBAAsBF,GAC1B,IAAIN,EAASxO,EAAU6E,KACvB,QAAmBlC,IAAfmM,EACA,OAAQA,EAAWO,eACf,IAAK,MACDb,EAASxO,EAAU0P,IAM/B,OAAOlB,EASX,cACI,OAAOhR,KAAKiR,aAAexO,EAAauP,MAG5C,oBACI,IAAIG,EAAgBxP,EAAc+B,KAMlC,OALI1E,KAAKiR,aAAexO,EAAasP,OACjCI,EAAgBxP,EAAcyP,OACvBpS,KAAKiR,aAAexO,EAAawP,QACxCE,EAAgBxP,EAAciC,OAE3BuN,EAGJ,cAAchK,GACbnI,KAAKiR,aAAexO,EAAauP,QACjChS,KAAK8I,SAAWX,EAAK8B,OAASjK,KAAKsJ,QCjG/C,SAAY5G,GACR,mBACA,mBACA,yCACA,mCACA,iCACA,2BACA,qCACA,yBACA,+BACA,uBACA,kCACA,wBACA,wBACA,sBACA,oBACA,gCACA,8BACA,sBAlBJ,CAAYA,MAAa,KAqBlB,MAAM,EAmBF,4BAA4B2P,GAE/B,MAAMrG,EAAQ,IAAI,EAsFlB,OArFAqG,EAAoB9C,WAAWlF,QAAQgF,IACnC,OAAOA,EAAMI,UACT,IAAK,WACDzD,EAAMsG,WAAa3E,EAAIgC,eAAeN,GACtC,MACJ,IAAK,MACDrD,EAAMuG,MAAQ5E,EAAIkC,gBAAgBR,GAClC,MACJ,IAAK,MACDrD,EAAMwG,QAAU7E,EAAIkC,gBAAgBR,GACpC,MACJ,IAAK,QACDrD,EAAMyG,cAAgB,EAAMC,YAAYrD,GACxC,MACJ,IAAK,cAEDrD,EAAMyG,cAAgB,SACtB,MACJ,IAAK,MACD,MAAME,EAAgBhF,EAAIgC,eAAeN,QACnBlK,IAAlBwN,IACA3G,EAAM4G,eAAiB,EAASC,kBAAkBF,IAEtD,MACJ,IAAK,WACD3G,EAAM8G,QAAUnF,EAAIkC,gBAAgBR,GACpC,MACJ,IAAK,YACDrD,EAAM+G,SAAWpF,EAAIkC,gBAAgBR,GACrC,MACJ,IAAK,WACD,MAAM2D,EAAW,EAASC,eAAe5D,GAErCrD,EAAMkH,iBADO/N,IAAb6N,EACoBA,EAAS,EAAMG,YAAYH,SAE3B7N,EAExB,MACJ,IAAK,OACD6G,EAAMoH,UAAY,EAASC,aAAahE,GACxC,MACJ,IAAK,YACD,MAAMiE,EAAe3F,EAAIoC,eAAeV,QACnBlK,IAAjBmO,IACAtH,EAAMuH,aAAehI,EAAQG,qBAAqB4H,IAEtD,MACJ,IAAK,MACD,MAAME,EAAkB7F,EAAIoC,eAAeV,QACpBlK,IAAnBqO,IACAxH,EAAMyH,aAAeD,EAAiB,KAE1C,MACJ,IAAK,UACDxH,EAAM0H,OAAS/F,EAAIgC,eAAeN,GACjC,MACL,IAAK,SACDrD,EAAM2H,MAAQhG,EAAIkC,gBAAgBR,GAClC,MACJ,IAAK,cACDrD,EAAM4H,WAAajG,EAAIkC,gBAAgBR,GACvC,MACJ,IAAK,cACL,IAAK,WACDrD,EAAM6H,YAAa,EACnB,MACJ,IAAK,WACL,IAAK,YACL,IAAK,aACL,IAAK,cACL,IAAK,OAED,MACJ,IAAK,SACL,IAAK,QACL,IAAK,QACL,IAAK,SACL,IAAK,SAED,MACJ,QACIhD,QAAQC,IAAI,2BAA2BzB,EAAMI,wCAIlDzD,EAGX,aACI,OAAOhM,KAAK8T,UAAY9T,KAAK+T,aAG1B,iBAAiBC,GACpB,QAAoB7O,IAAhB6O,IACAhU,KAAK+T,aAAeC,EAAYC,iBACR9O,IAApBnF,KAAKsS,YAA0B,CAC/B,MAAM4B,EAAYF,EAAYG,cAAcnU,KAAKsS,iBAC/BnN,IAAd+O,IACAlU,KAAK8T,SAAWI,IAMzB,WAAW5H,EAAoBE,EAAeD,GACjDvM,KAAKkT,YAAc5G,EACnBtM,KAAKuS,MAAQ/F,EACbxM,KAAKoT,UAAY7G,EAGd,WAaH,MAAO,kBAZqBpH,IAAjBnF,KAAKwS,QAAyB,KAAKxS,KAAKwS,QAAY,WACrCrN,IAAfnF,KAAKuS,MAAuB,KAAKvS,KAAKuS,MAAM6B,WAAe,WACnCjP,IAAxBnF,KAAK4S,eAAgC,KAAK5S,KAAK4S,eAAewB,WAAe,WACvDjP,IAAjBnF,KAAK8S,QAAyB,UAAU9S,KAAK8S,QAAQsB,WAAe,WACjDjP,IAArBnF,KAAKkT,YAA6B,QAAQlT,KAAKkT,YAAYkB,WAAe,WACvDjP,IAAnBnF,KAAKoT,UAA2B,QAAQpT,KAAKoT,UAAUgB,WAAe,WACjDjP,IAAlBnF,KAAK+S,SAA0B,WAAW/S,KAAK+S,SAASqB,WAAe,WAC7CjP,IAAtBnF,KAAKuT,aAA8B,gBAAgBvT,KAAKuT,aAAaa,WAAe,WAC9DjP,IAAtBnF,KAAKyT,aAA8B,gBAAgBzT,KAAKyT,aAAaW,WAAe,WAC1EjP,IAAhBnF,KAAK0T,OAAwB,SAAS1T,KAAK0T,OAAOU,WAAe,WACnDjP,IAAfnF,KAAK2T,MAAuB,QAAQ3T,KAAK2T,MAAMS,WAAe,WACrCjP,IAApBnF,KAAK4T,WAA4B,aAAa5T,KAAK4T,WAAWQ,WAAe,KAO5F,sBAAsBC,GAC1B,IAAIC,OAA8BnP,EAClC,MAAMoP,EAAY5G,EAAIqB,aAAaqF,EAAU,WAI7C,YAHkBlP,IAAdoP,IACAD,EAAQC,EAAUC,MAAM,MAErBF,EAGH,oBAAoBG,GACxB,MAAMC,EAAe/G,EAAIoC,eAAe0E,GACxC,YAAyBtP,IAAjBuP,EAA8BnJ,EAAQoJ,uBAAuBD,QAAgBvP,EAGjF,yBAAyByP,GAC7B,IAAIjC,EACJ,OAAOiC,GACH,IAAK,OACDjC,EAAgBjQ,EAAcmS,KAC9B,MACJ,IAAK,kBACDlC,EAAgBjQ,EAAcoS,gBAC9B,MACJ,IAAK,eACDnC,EAAgBjQ,EAAcqS,aAC9B,MACJ,IAAK,cACDpC,EAAgBjQ,EAAcsS,YAC9B,MACJ,IAAK,WACDrC,EAAgBjQ,EAAcuS,SAC9B,MACJ,IAAK,gBACDtC,EAAgBjQ,EAAcwS,cAC9B,MACJ,IAAK,UACDvC,EAAgBjQ,EAAcyS,QAC9B,MACJ,IAAK,aACDxC,EAAgBjQ,EAAc0S,WAC9B,MACJ,IAAK,SACDzC,EAAgBjQ,EAAc2S,OAC9B,MACJ,IAAK,cACD1C,EAAgBjQ,EAAc4S,YAC9B,MACJ,IAAK,SACD3C,EAAgBjQ,EAAc6S,OAC9B,MACJ,IAAK,SACD5C,EAAgBjQ,EAAc8S,OAC9B,MACJ,IAAK,QACD7C,EAAgBjQ,EAAc+S,MAC9B,MACJ,IAAK,OACD9C,EAAgBjQ,EAAcgT,KAC9B,MACJ,IAAK,aACD/C,EAAgBjQ,EAAciT,WAC9B,MACJ,IAAK,YACDhD,EAAgBjQ,EAAckT,UAC9B,MACJ,IAAK,QACDjD,EAAgBjQ,EAAcmT,MAC9B,MACJ,IAAK,OACL,QACIlD,EAAgBjQ,EAAc2E,KAGtC,OAAOsL,IClPf,SAAYhQ,GACR,kBACA,cACA,cACA,gBAJJ,CAAYA,MAAa,KAOzB,SAAYC,GACR,oBACA,oBACA,cAHJ,CAAYA,MAAQ,KAMb,MAAM,EAAb,cACW,KAAAuP,mBAA2ChN,EAmB3C,+BAA+B2Q,GAClC,MAAMC,EAAW,IAAI,EAwDrB,OAvDAD,EAAoBvG,WAAWlF,QAAQgF,IACnC,OAAQA,EAAMI,UACV,IAAK,WACDsG,EAASzD,WAAa3E,EAAIgC,eAAeN,GACzC,MACJ,IAAK,OACD,MAAM8C,EAAgBxE,EAAIgC,eAAeN,QACnBlK,IAAlBgN,IACA4D,EAAS5D,cAAgBxP,EAAcwP,IAE3C,MACJ,IAAK,QACD,MAAM6D,EAAcrI,EAAIqB,aAAaK,EAAO,kBACxBlK,IAAhB6Q,IACAD,EAASE,QAAU1K,EAAQG,qBAAqB4E,SAAS0F,EAAa,MAE1E,MAAME,EAAWvI,EAAIqB,aAAaK,EAAO,eACxBlK,IAAb+Q,IACAH,EAASI,YAAc5K,EAAQG,qBAAqB4E,SAAS4F,EAAU,MAE3E,MACJ,IAAK,UACDH,EAASK,SAAW,EAAeC,wBAAwBhH,GAC3D,MACJ,IAAK,YACD0G,EAASO,uBAAuBjH,GAChC0G,EAASQ,sBAAsBlH,GAC/B,MACJ,IAAK,QACD0G,EAASS,aAAe,EAAM9D,YAAYrD,GAC1C,MACJ,IAAK,SACD0G,EAASU,SAAW,EAAQC,aAAarH,GACzC,MACJ,IAAK,QACD0G,EAASY,SAAW,EAASC,qBAAqBvH,GAClD,MACJ,IAAK,iBACL,IAAK,eACL,IAAK,WACL,IAAK,SACL,IAAK,sBACL,IAAK,cACL,IAAK,SACL,IAAK,aACL,IAAK,wBACL,IAAK,wBACL,IAAK,eAED,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,wCAIlDsG,EAGX,aACI,OAAO/V,KAAK8T,UAAY9T,KAAK+T,aAG1B,eAAe/H,GAClB,IAAIjG,EAAU/F,KAAK6W,aACnB,QAAgB1R,IAAZY,EAAuB,CAEvB,OADiB/F,KAAK8W,WAElB,KAAKlU,EAASmU,KAGVhR,EADkC,KAAjBiG,EAAMO,SACFxG,EAAU,IACnC,MACA,QAEIA,EAAUwF,EAAQG,qBAAqB3F,IAInD,OAAOA,EAGJ,eAAeA,GAClB/F,KAAK6W,aAAe9Q,EACpB/F,KAAK8W,UAAYlU,EAASoU,QAG9B,oBACI,IAAIjR,EAAkB,EAQtB,YAP6BZ,IAAzBnF,KAAKiX,sBAAuD9R,IAAtBnF,KAAK6W,aAC3C9Q,EAAU/F,KAAKiX,gBAAkBjX,KAAK6W,kBACJ1R,IAA3BnF,KAAKkX,kBACZnR,EAAU/F,KAAKkX,mBACuB,IAA/BlX,KAAKmX,4BAAwDhS,IAAtBnF,KAAK6W,eACnD9Q,EAAU,KAAO/F,KAAK6W,cAEnB9Q,EAGX,mBACI,IAAIA,EAAkB,EAQtB,YAP4BZ,IAAxBnF,KAAKoX,qBAAsDjS,IAAtBnF,KAAK6W,aAC1C9Q,EAAU/F,KAAKoX,eAAiBpX,KAAK6W,kBACJ1R,IAA1BnF,KAAKqX,iBACZtR,EAAU/F,KAAKqX,kBACsB,IAA9BrX,KAAKsX,2BAAuDnS,IAAtBnF,KAAK6W,eAClD9Q,EAAU,KAAO/F,KAAK6W,cAEnB9Q,EAGJ,iBAAiBiO,GACpB,QAAoB7O,IAAhB6O,IACAhU,KAAK+T,aAAeC,EAAYC,iBACR9O,IAApBnF,KAAKsS,YAA0B,CAC/B,MAAM4B,EAAYF,EAAYG,cAAcnU,KAAKsS,iBAC/BnN,IAAd+O,IACAlU,KAAK8T,SAAWI,IAMzB,gBAAgBzD,QACGtL,IAAlBnF,KAAKoW,UACLpW,KAAKoW,SAASmB,gBAAgB9G,GAI/B,QACH,MAAMrF,EAAS,IAAI,EAkBnB,OAjBAA,EAAO2I,aAAe/T,KAAK+T,aAC3B3I,EAAO0I,SAAW9T,KAAK8T,SACvB1I,EAAOkH,WAAatS,KAAKsS,WACzBlH,EAAO+G,cAAgBnS,KAAKmS,cAC5B/G,EAAO+K,YAAcnW,KAAKmW,YAC1B/K,EAAO6K,QAAUjW,KAAKiW,QACtB7K,EAAOyL,aAAe7W,KAAK6W,aAC3BzL,EAAO0L,UAAY9W,KAAK8W,UACxB1L,EAAOgL,SAAWpW,KAAKoW,SACvBhL,EAAOoL,aAAexW,KAAKwW,aAC3BpL,EAAO8L,kBAAoBlX,KAAKkX,kBAChC9L,EAAOiM,iBAAmBrX,KAAKqX,iBAC/BjM,EAAO6L,gBAAkBjX,KAAKiX,gBAC9B7L,EAAOgM,eAAiBpX,KAAKoX,eAC7BhM,EAAO+L,sBAAwBnX,KAAKmX,sBACpC/L,EAAOkM,qBAAuBtX,KAAKsX,qBACnClM,EAAOqL,SAAWzW,KAAKyW,SAChBrL,EAGJ,WAKH,MAAO,kBAJ+BjG,IAApBnF,KAAKsS,WAA4B,QAAQtS,KAAKsS,WAAe,WACtCnN,IAAvBnF,KAAKmS,cAA+B,MAAMnS,KAAKmS,cAAciC,WAAe,WACxDjP,IAArBnF,KAAKmW,YAA6B,OAAOnW,KAAKmW,YAAY/B,WAAe,WAClDjP,IAAtBnF,KAAK6W,aAA8B,QAAQ7W,KAAK6W,aAAazC,WAAe,KAI1F,uBAAuBoD,GAC3B,MAAMC,EAAW9J,EAAIqB,aAAawI,EAAa,eAC9BrS,IAAbsS,IACAzX,KAAK6W,aAAevG,SAASmH,EAAU,IACvCzX,KAAK8W,UAAYlU,EAAS8U,SAE9B,MAAMC,EAAWhK,EAAIqB,aAAawI,EAAa,mBAC9BrS,IAAbwS,IACA3X,KAAK8W,UAAYlU,EAAS+U,IAI1B,sBAAsBH,GAC1B,MAAMI,EAAajK,EAAIqB,aAAawI,EAAa,iBAC9BrS,IAAfyS,IACA5X,KAAKkX,kBAAoB3L,EAAQG,qBAAqB4E,SAASsH,EAAY,MAE/E,MAAMC,EAAkBlK,EAAIqB,aAAawI,EAAa,sBAC9BrS,IAApB0S,IACA7X,KAAKiX,gBAAkB3G,SAASuH,EAAiB,IAAM,KAE3D,MAAMC,EAAiBnK,EAAIqB,aAAawI,EAAa,4BAC9BrS,IAAnB2S,IACA9X,KAAKmX,sBAAwBxJ,EAAIiC,mBAAmBkI,IAExD,MAAMC,EAAYpK,EAAIqB,aAAawI,EAAa,gBAC9BrS,IAAd4S,IACA/X,KAAKqX,iBAAmB9L,EAAQG,qBAAqB4E,SAASyH,EAAW,MAE7E,MAAMC,EAAiBrK,EAAIqB,aAAawI,EAAa,qBAC9BrS,IAAnB6S,IACAhY,KAAKoX,eAAiB9G,SAAS0H,EAAgB,IAAM,KAEzD,MAAMC,EAAgBtK,EAAIqB,aAAawI,EAAa,2BAC9BrS,IAAlB8S,IACAjY,KAAKsX,qBAAuB3J,EAAIiC,mBAAmBqI,MCxO/D,SAAYpV,GACR,uBACA,mBACA,uBACA,6BAJJ,CAAYA,MAAQ,KkBGb,MAAM,EA8FT,YAAYkT,EAAqBY,GAC7B3W,KAAK+V,cAAyB5Q,IAAb4Q,EAA0BA,EAAW,IAAI,EAC1D/V,KAAK2W,cAAyBxR,IAAbwR,EAA0BA,EAAW,IAAI,EAxFvD,2BAA2BuB,GAC9B,IAAInC,OAAiC5Q,EACjCwR,OAAiCxR,EACrC,MAAMgT,EAAcxK,EAAIyB,oBAAoB8I,EAAiB,gBAC7D,QAAoB/S,IAAhBgT,EAA2B,CAC3B,MAAMC,EAAezK,EAAIyB,oBAAoB+I,EAAa,cACrChT,IAAjBiT,IACAzB,EAAW,EAASC,qBAAqBwB,IAGjD,MAAMC,EAAc1K,EAAIyB,oBAAoB8I,EAAiB,gBAC7D,QAAoB/S,IAAhBkT,EAA2B,CAC3B,MAAMC,EAAe3K,EAAIyB,oBAAoBiJ,EAAa,cACrClT,IAAjBmT,IACAvC,EAAW,EAASwC,wBAAwBD,IAGpD,OAAO,IAAI,EAAMvC,EAAUY,GAGxB,qBAAqB6B,GACxB,IAAIzC,OAAiC5Q,EACjCwR,OAAiCxR,EACjCsT,OAAgCtT,EACpCqT,EAAUjJ,WAAWlF,QAAQgF,IAEzB,OAAQA,EAAMI,UACV,IAAK,QACDsG,EAAW,EAASwC,wBAAwBlJ,GAC5C,MACJ,IAAK,QACDsH,EAAW,EAASC,qBAAqBvH,GACzC,MACJ,IAAK,YACDoJ,EAAY9K,EAAIgC,eAAeN,GAC/B,MACJ,IAAK,SACL,IAAK,YACL,IAAK,iBACL,IAAK,YACL,IAAK,eACL,IAAK,eACL,IAAK,mBACL,IAAK,SACL,IAAK,WACL,IAAK,iBACL,IAAK,aACL,IAAK,oBACL,IAAK,kBAED,MACJ,IAAK,UACL,IAAK,YACL,IAAK,UACL,IAAK,WACL,IAAK,SAED,MACJ,IAAK,SACL,IAAK,SACL,IAAK,UACL,IAAK,WACL,IAAK,iBACL,IAAK,WAED,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,qCAIzD,MAAMzD,EAAQ,IAAI,EAAM+J,EAAUY,GAElC,OADA3K,EAAMsG,WAAamG,EACZzM,EAGJ,mBAAmB0M,GACtB,IAAIlC,OAAmCrR,EAEvC,MAAMwT,EAAWhL,EAAIqB,aAAa0J,EAAa,UAI/C,YAHiBvT,IAAbwT,IACAnC,EAAemC,GAEZnC,EAQJ,iBAAiBxC,GACpB,QAAwB7O,IAApBnF,KAAKsS,iBAA4CnN,IAAhB6O,EAA2B,CAC5D,MAAME,EAAYF,EAAYG,cAAcnU,KAAKsS,iBAC/BnN,IAAd+O,IACAlU,KAAK8T,SAAWI,QAGF/O,IAAlBnF,KAAK2W,UACL3W,KAAK2W,SAASiC,iBAAiB5E,QAEb7O,IAAlBnF,KAAK+V,UACL/V,KAAK+V,SAAS6C,iBAAiB5E,GAIvC,aACI,OAAOhU,KAAK6Y,UAAS,OAAO1T,EAAYwR,GAAaA,EAASnE,SAGlE,WACI,OAAOxS,KAAK6Y,UAAS,OAAO1T,EAAYwR,GAAaA,EAASpE,OAGlE,oBACI,OAAOvS,KAAK6Y,SAASnW,EAAc2E,UAAMlC,EAAYwR,GAAaA,EAAS/D,gBAG/E,aACI,OAAO5S,KAAK6Y,UAAS,OAAO1T,EAAYwR,GAAaA,EAAS7D,SAGlE,mBACI,OAAO9S,KAAK6Y,UAAS,OAAO1T,EAAYwR,GAAaA,EAAS5D,UAGlE,iBACI,OAAO/S,KAAK6Y,SAAS,aAAS1T,EAAYwR,GAAaA,EAASzD,aAGpE,eACI,OAAOlT,KAAK6Y,SAAS,QAAI1T,EAAYwR,GAAaA,EAASvD,WAG/D,kBACI,OAAOpT,KAAK6Y,SAAS,OAAG1T,EAAYwR,GAAaA,EAASpD,cAG9D,kBACI,OAAOvT,KAAK6Y,SAAS,OAAG1T,EAAYwR,GAAaA,EAASlD,cAG9D,kBACI,MAAMzH,EAAQhM,KACd,IAAI8Y,EAAiB9Y,KAAK6Y,cACtB1T,EACC4Q,GACUA,EAASgD,eAAe/M,QAEnC7G,GAKJ,YAHuBA,IAAnB2T,IACAA,EAAiC,KAAhB9Y,KAAKuM,UAEnBuM,EAGX,mBACI,OAAO9Y,KAAK6Y,SAAS,SAAW9C,GAAaA,EAASS,aAAeG,GAAaA,EAASlE,eAGxF,eAAeuG,EAAmBC,GACrC,IAAIC,EAAalZ,KAAK6Y,SAAS,EAAI9C,GAAaA,EAASI,iBAAahR,GACtE,KACK8T,IAAe7W,EAAW+W,OAASF,IAAe7W,EAAWgX,MAC7DJ,IAAU5W,EAAW+W,OAASH,IAAU5W,EAAWgX,MACtD,CACE,MAAMnD,EAAUjW,KAAK6Y,cAAS1T,EAAY4Q,GAAaA,EAASE,aAAS9Q,QACzDA,IAAZ8Q,IACAiD,GAAcjD,GAGtB,OAAOiD,EAGX,WACI,OAAOlZ,KAAK6Y,UAAS,OAAO1T,EAAYwR,GAAaA,EAAShD,OAGlE,gBACI,OAAO3T,KAAK6Y,UAAS,OAAO1T,EAAYwR,GAAaA,EAAS/C,YAGlE,YACI,OAAO5T,KAAK6Y,SAAS,cAAU1T,EAAYwR,GAAaA,EAASjD,QAGrE,oBACI,OAAO1T,KAAK6Y,SAASlW,EAAc+B,KAAOqR,GAAaA,EAAS5D,mBAAehN,GAGnF,gBACI,OAAOnF,KAAK6Y,UAAS,OAAO1T,EAAYwR,GAAaA,EAAS9C,YAGlE,eACI,IAAIwF,EAAWxW,EAASyW,OAUxB,OATItZ,KAAKwM,OACL6M,GAAYxW,EAAS0W,MAErBvZ,KAAKyM,SACL4M,GAAYxW,EAAS2W,QAErBxZ,KAAKyZ,YACLJ,GAAYxW,EAAS6W,WAElBL,EAGX,WAII,OAHoBrZ,KAAW,OAAI,UAAW,KAC5BA,KAAS,KAAI,QAAS,IACHoG,KAAKiH,MAAMrN,KAAKuM,UAAY,MAAQvM,KAAKsM,WAI3E,WAiBH,MAAO,eAhB2BnH,IAApBnF,KAAKsS,WAA4B,QAAQtS,KAAKsS,WAAe,MAC9D,MAAMtS,KAAKmS,cAAciC,cAC1B,OAAOpU,KAAK2Z,eAAevX,EAAW+W,MAAO/W,EAAW+W,OAAO/E,cAC9D,OAAOpU,KAAK2Z,eAAevX,EAAWwE,OAAQxE,EAAWwE,QAAQwN,cACpE,KAAKpU,KAAKyM,UACV,KAAKzM,KAAKwM,KAAK4H,cACf,KAAKpU,KAAK2S,cAAcyB,cACnB,UAAUpU,KAAK4Z,OAAOxF,cACxB,QAAQpU,KAAKsM,WAAW8H,cACxB,QAAQpU,KAAKuM,SAAS6H,cACnB,WAAWpU,KAAK6Z,aAAazF,cACzB,gBAAgBpU,KAAK8Z,YAAY1F,cACjC,gBAAgBpU,KAAK+Z,YAAY3F,cACvC,SAASpU,KAAKga,MAAM5F,cACrB,QAAQpU,KAAKia,KAAK7F,cACb,aAAapU,KAAKyZ,UAAUrF,aAI1C,SAAY8F,EAAYC,EAA+CC,GAC3E,IAAItL,EAAM9O,KAAKqa,aAAaF,EAAOC,GAKnC,YAHYjV,IAAR2J,IACAA,EAAMoL,GAEHpL,EAGH,aACJqL,EACAC,EACAE,GAUA,IAAIxL,OAAqB3J,EAEzB,QAAsBA,IAAlBnF,KAAK2W,SAAwB,CAC7B,QAAcxR,IAAViV,EAAqB,CACrB,MAAMG,EAAWH,EAAMpa,KAAK2W,eACXxR,IAAboV,IACAzL,EAAMyL,GAGd,MAAMC,EAAYxa,KAAK2W,SAAS1H,YACpB9J,IAAR2J,QAAmC3J,IAAdqV,IAErB1L,EAAM0L,EAAUH,aAAgBF,EAAOC,IAI/C,QAAYjV,IAAR2J,QACsB3J,IAAlBnF,KAAK+V,SAAwB,CAC7B,QAAc5Q,IAAVgV,EAAqB,CACrB,MAAMM,EAAWN,EAAMna,KAAK+V,eACX5Q,IAAbsV,IACA3L,EAAM2L,GAGd,MAAMC,EAAc1a,KAAK+V,SAASY,SAIlC,QAHYxR,IAAR2J,QAA+B3J,IAAViV,QAAuCjV,IAAhBuV,IAC5C5L,EAAMsL,EAAMM,SAEJvV,IAAR2J,QAAgD3J,IAA3BnF,KAAK+V,SAASK,SAAwB,CAE3D,MAAMA,EAAWpW,KAAK+V,SAASK,SAASpK,WACvB7G,IAAbiR,IACAtH,EAAMsH,EAASiE,aAAgBF,EAAOC,IAG9C,MAAMO,EAAY3a,KAAK+V,SAAS9G,YACpB9J,IAAR2J,QAAmC3J,IAAdwV,IAErB7L,EAAM6L,EAAUN,aAAgBF,EAAOC,IAKnD,QAAYjV,IAAR2J,QACwB3J,IAApBnF,KAAK4a,iBACWzV,IAAZmV,EAAuB,CACvB,MAAMO,EAAQP,EAAQta,KAAK4a,iBACbzV,IAAV0V,IACA/L,EAAM+L,GAMtB,QAAY1V,IAAR2J,EAAmB,CACnB,MAAMgM,EAAU9a,KAAK8T,cACL3O,IAAZ2V,IACAhM,EAAMgM,EAAQT,aAAgBF,EAAOC,IAG7C,OAAOtL,GC3UR,MAAM,EAWJ,wBACL,IAAK,EAAMiM,aAAc,CACvB,EAAMA,cAAe,EACrB,MAAM/H,EAAW,CACf,QACA,YACA,QACA,UACA,UACA,UACA,WACA,gBACA,eACA,cACA,UAEIhH,EAAQ,IAAI,EAClBA,EAAM2K,SAASqE,WAAW,mBAAmB,EAAO,EAAMC,UAC1D,EAAMC,SAAW3P,EAAQ4P,aAAa,EAAMC,WAAYpP,GAAS,EAAMoP,WAAW9P,OAClF,EAAM+P,YAAY,mBAAqB,EAAMH,SAC7ClI,EAAS3I,QAAQiR,IACf,EAAMC,SAASD,GAAQ,KAG3B,OAAO,EAAMD,YAGR,mBAAmBrI,GACxB,IAAK,IAAI5S,EAAI,EAAGA,EAAI4S,EAAS1H,OAAQlL,IACnC,GAAIJ,KAAKwb,WAAWxI,EAAS5S,IAAI,GAC/B,OAAOA,EAGX,OAAQ,EAGH,kBAAkBkb,EAAgB9O,GACvC,MAAM7L,EAAO,EAAM8a,SAASH,EAAQ9O,GAEpC,UADqDrH,IAAjC,EAAMuW,iBAAiB/a,IACzB,CAEhB,aADsDwE,IAA/B,EAAMwW,eAAehb,KAEnC,EAAM4a,SAASD,EAAQ9O,GAIlC,OAAO,EAGD,gBAAgB8O,EAAgB9O,GACtC,MAAMR,EAAQ,IAAI,EAClBA,EAAM2K,SAASqE,WAAWM,EAAQ9O,EAAM,EAAMyO,UAC9C,MAAMta,EAAO,EAAM8a,SAASH,EAAQ9O,GAE9BoP,EADgBrQ,EAAQ4P,aAAa,EAAMC,WAAYpP,GACzB,EAAMoP,WAAW9P,OACrD,OAAIsQ,IAAgB,EAAMV,UACxB,EAAMG,YAAY1a,GAAQib,GACnB,IAEP,EAAMD,eAAehb,GAAQib,GACtB,GAIH,gBAAgBN,EAAgB9O,GACtC,OAAO8O,GAAU,EAAS,QAAU,KA3EvB,EAAAP,cAAe,EACf,EAAAM,YAAyC,GACzC,EAAAM,eAA4C,GAC5C,EAAAP,WAAa,cACb,EAAAH,SAAW,GACX,EAAAC,cAA+B/V,ECLzC,MAAM,EAMF,qBAAqBX,EAAewH,GACvC,MAAM6P,EAAY,EAAYC,iBAAiB9P,GAC/C,OAAO5F,KAAK2V,MAAMvX,EAAQqX,GAGvB,wBAAwB7P,GAC3B,MAAMO,EAAWP,EAAMO,SACjBD,EAAaN,EAAMM,WAKzB,OAJA,EAAMkP,WAAWlP,EAAYN,EAAMQ,MACpBxM,KAAKgc,eAAehQ,GACdxH,MAAQxE,KAAKic,YAAY3Q,OACpBiB,EAAWvM,KAAKkc,UAIvC,sBAAsBlQ,GACzB,MAAMmQ,EAASnc,KAAKgc,eAAehQ,GAEnC,OADmBmQ,EAAOC,sBAAwBD,EAAOE,wBACrCrQ,EAAMO,SAAWvM,KAAKkc,UAGvC,wBAAwBlQ,GAG3B,OAFehM,KAAKgc,eAAehQ,GACToQ,uBAAyBpc,KAAKkc,UAAY,EAAYI,kBAC5DtQ,EAAMO,SAAWvM,KAAKkc,UAGvC,2BAA2BlQ,GAC9B,MAAMmQ,EAASnc,KAAKgc,eAAehQ,GAC7BuQ,EAAqB,EAAI,EAAYD,iBAE3C,OADmBH,EAAOE,wBAA0Brc,KAAKkc,UAAYK,GACjDvQ,EAAMO,SAAWvM,KAAKkc,UAGtC,sBAAsBlQ,GAC1B,MAAMlB,EAAKkB,EAAMM,WAAcN,EAAU,KAAI,QAAU,GACvD,IAAIwQ,EAAU,EAAYC,OAAO3R,GACjC,QAAgB3F,IAAZqX,EAAuB,CACvB,MAAME,EAAc,IAAI,EACxBA,EAAY/F,SAASqE,WAAWhP,EAAMM,WAAYN,EAAMQ,KAAMxM,KAAKkc,WACnEM,EAAUjR,EAAQyB,eAAe,EAAYiP,YAAaS,GAE9D,OAAOF,GA/CI,EAAAC,OAAyC,GACzC,EAAAR,YAAc,4CACd,EAAAC,UAAY,GACZ,EAAAI,iBAAmB,GAAK,GnBP3C,SAAYxZ,GACR,qBACA,mBACA,iBACA,2BAJJ,CAAYA,MAAa,KAOlB,MAAM6Z,EAKT,YAAYC,GACR5c,KAAK6c,OAASD,EAGlB,YAII,YAHoBzX,IAAhBnF,KAAK8c,QACL9c,KAAK+c,SAEF/c,KAAK8c,QAAU,GAGnB,aAAa9R,GAIhB,YAHoB7F,IAAhBnF,KAAK8c,QACL9c,KAAK+c,SAEF/c,KAAKgd,YAAahS,GAMtB,QAAQ9F,EAAeK,GAC1B,MAAM0X,EAAoB,QACN9X,IAAhBnF,KAAK8c,QACL9c,KAAK+c,SAET,MAAMG,EAAQld,KAAK8c,OACnB,IAAK,IAAI1c,EAAI8E,EAAO9E,GAAKmF,EAAKnF,IAAK,CAG/B,OAFA6c,EAAQ1S,KAAK2S,EAAO9c,IACRJ,KAAKmd,aAAa/c,IAE1B,KAAK0C,EAAc+R,KACfoI,EAAQ1S,KAAK,KACb,MACJ,KAAKzH,EAAcsa,IAEf,MACJ,QACIH,EAAQ1S,KAAK,MAIzB,OAAO0S,EAAQI,KAAK,IAGhB,SACJ,MAAMC,EAAMtd,KAAK6c,OAAOQ,KAAK,IAC7Brd,KAAK8c,OAASQ,EAAI9I,MAAM,WACxB,MAAM+I,EAA8B,GACpC,IAAIvS,EAAQ,EACZ,IAAK,IAAI5K,EAAI,EAAGA,EAAIJ,KAAK8c,OAAOxR,OAAQlL,IAAK,CAGzC,OAFA4K,GAAShL,KAAK8c,OAAO1c,EAAI,GAAGkL,OACRgS,EAAIE,OAAOxS,IAE3B,IAAK,IACDuS,EAAWhT,KAAKzH,EAAc2a,OAC9B,MACJ,IAAK,IACDF,EAAWhT,KAAKzH,EAAc+R,MAC9B,MACJ,IAAK,KACD0I,EAAWhT,KAAKzH,EAAcsa,KAC9B,MACJ,IAAK,KACL,IAAK,KACDG,EAAWhT,KAAKzH,EAAc4a,UAC9B,MACJ,QACI7M,QAAQC,IAAI,wDACZyM,EAAWhT,KAAKzH,EAAc2a,OAGtCzS,IAEJhL,KAAKgd,YAAcO,GoB5EpB,MAAM,EAMT,YAAYI,GAJL,KAAAC,aAAe,EAKlB5d,KAAK6d,KAAOF,EACZ3d,KAAK8d,YAAc9d,KAAK6d,KAAK7R,MAAM+N,YACnC/Z,KAAK+d,MAAQ,GAGV,aAAa5V,GAChB,IAAI6Q,EAAQ5W,EAAW+W,MACnB6E,EAAkBhe,KAAKie,sBACvBC,EAAcle,KAAKme,aACvB,GAAIne,KAAK6d,KAAKO,aAEV,YADApe,KAAK4d,aAAeI,GAGxBhe,KAAKqe,cAAcH,EAAa/V,GAChC,MAAMyU,EAAQ5c,KAAKse,YAAYte,KAAK6d,KAAKjB,OACnC2B,EAAW,IAAI5B,EAAaC,GAC5BM,EAAQqB,EAASrB,MACvB,GAA+B,IAA3Bld,KAAK6d,KAAKjB,MAAMtR,QAAuC,MAAvBtL,KAAK6d,KAAKjB,MAAM,GAEhD,YADA5c,KAAK4d,aAAeI,EAAkB,EAAYlC,iBAAiB9b,KAAK6d,KAAK7R,QAGjF,MAAMwS,EAAYxe,KAAK6d,KAAKY,gBAAkB1b,EAAc2b,UAC5D,IAAIC,EAAW,EACXC,EAAgB,EAChBC,EAAgB,EAChBC,EAAoB9e,KAAK+e,mBAAmBf,EAAiB7V,GAC7D6W,GAAa,EACb7M,EAAgBnS,KAAK6d,KAAK7R,MAAMmG,cACpC,IAAI,IAAI/R,EAAI,EAAGA,EAAI8c,EAAM5R,OAAQlL,IAAK,CAClCye,GAAiB3B,EAAM9c,GAAGkL,OAAS,EACnC0T,EAAc5e,IAAM8c,EAAM5R,OAAS,EACnC,MAAM2T,EAAYV,EAASpB,aAAa/c,GAClC8e,EAAYD,IAAcnc,EAAc4a,SACxCyB,EAAQF,IAAcnc,EAAcsa,IAC1C,IAAIgC,EAAmBJ,GAAcE,GAAaC,EAC7CC,GAAqBpf,KAAKqf,eAAeR,EAAeC,EAAmBN,EAAWtB,EAAM9c,EAAI,MAEjGgf,GAAmB,GAEnBA,IACApG,EAAQ,EAAe5W,EAAWyE,KAAOmS,EAEzChZ,KAAKsf,aAAaf,EAASgB,QAAQX,EAAexe,GAAI+H,EAAM+V,EAAaiB,EAAOnG,EAAOgF,EAAiB7L,EAAenS,KAAK6d,KAAK7R,OAE5HgT,IACDd,GAAc,EACdlF,EAAQ5W,EAAWwE,OACfuY,GACAnB,EAAkBhe,KAAKwf,eAAeb,EAAUxW,GAChDgK,EAAgBnS,KAAKyf,qBAAqBd,EAAU3e,KAAK6d,KAAK7R,MAAO7D,GACrEwW,MAEAX,EAAkBhe,KAAK0f,gBAAgB1G,GACvC2F,EAAW,GAEfG,EAAoB9e,KAAK+e,mBAAmBf,EAAiB7V,GAC7D0W,EAAgB,EAChBD,EAAgBxe,EAAI,IAIhCJ,KAAK4d,aAAe5d,KAAK2f,eAAe3B,EAAiB7V,GAG7D,kBACI,OAAQnI,KAAK6d,KAAK+B,cAAgBxd,EAAW+W,OAASnZ,KAAK6d,KAAK+B,cAAgBxd,EAAWgX,KAG/F,iBACI,OAAQpZ,KAAK6d,KAAK+B,cAAgBxd,EAAWyE,MAAQ7G,KAAK6d,KAAK+B,cAAgBxd,EAAWgX,KAGtF,aACJkE,EACAnV,EACA+V,EACAiB,EACAnG,EACA6G,EACA1N,EACAnG,GAEA,MAAMgT,EAAchG,IAAU5W,EAAWyE,MAAQmS,IAAU5W,EAAWgX,KAChE0G,EAAa9f,KAAK6d,KAAK+B,cAAgBxd,EAAWyE,MAAQ7G,KAAK6d,KAAK+B,cAAgBxd,EAAWgX,KAC/F2G,EAAa/T,EAAMmG,gBAAkBxP,EAAcqd,OAAUhB,EACnEhf,KAAK+d,MAAMxT,KAAK,CACZwB,KAAMuR,EACNtZ,EAAGmE,EAAK8B,OAAS4V,EACjB5b,EAAGkE,EAAK8X,OACRzb,MAAO2D,EAAK+X,WAAaL,EACzBE,UAAWA,EACXI,UAAWjC,EACXlE,MAAOhO,EAAMgO,MACb1N,WAAYN,EAAMM,WAClBC,SAAUP,EAAMO,SAChB8M,SAAUrN,EAAMqN,SAChBlH,cAAeA,IAEdgN,IAAUW,GAAcd,GACzB7W,EAAK4B,gBAAgB/J,KAAK8d,aAI1B,YAAYsC,GAIhB,OAHIpgB,KAAK6d,KAAK7R,MAAMiO,MAAQja,KAAK6d,KAAK7R,MAAMyN,aACxC2G,EAAOA,EAAKC,IAAK/C,GAAQA,EAAIgD,sBAE1BF,EAGH,cAAclC,EAAsB/V,GACnC+V,GAED/V,EAAK4B,gBAAgB,EAAYwW,iBAAiBvgB,KAAK6d,KAAK7R,QAIpE,mBACI,IAAIkS,EAMJ,OAJIA,OAD2B/Y,IAA3BnF,KAAK6d,KAAK2C,eAA8BxgB,KAAKygB,YAK1CvC,EAGH,gBAAgBlF,GACpB,OAAOhZ,KAAK6d,KAAK7R,MAAM2N,eAAeX,EAAOhZ,KAAK6d,KAAK+B,aAGnD,eAAejB,EAAkBxW,GACrC,IAAIuY,EAAU,EACd,MAAMC,EAAMxY,EAAKyY,OAAOjC,GAIxB,YAHYxZ,IAARwb,QAAsCxb,IAAjBwb,EAAI7X,WACzB4X,EAAUC,EAAI7X,UAEX4X,EAGH,qBAAqB/B,EAAkB3S,EAAc7D,GACzD,IAAIgK,EAAgBnG,EAAMmG,cAC1B,MAAMwO,EAAMxY,EAAKyY,OAAOjC,GAIxB,YAHYxZ,IAARwb,IACAxO,EAAgBwO,EAAIxO,eAEjBA,EAGH,mBAAmB0N,EAAkB1X,GACzC,OAAO,EAAY0Y,cAAc1Y,EAAK+X,WAAaL,EAAU7f,KAAK6d,KAAK7R,OAMnE,eAAeV,EAAgBwT,EAA2BN,EAAoBsC,GAClF,QAAiB3b,IAAb2b,EACA,OAAO,EAEX,MAAMC,EAAcvC,EAAY,EAAI,EAGpC,OAFmBlT,EAASwV,EAASxV,QACVwT,EAAoBiC,EAI3C,sBACJ,IAAIlB,EAAW,EAMf,OAJIA,OAD2B1a,IAA3BnF,KAAK6d,KAAK2C,cAA8BxgB,KAAKygB,YAClCzgB,KAAK0f,gBAAgBtd,EAAW+W,OAEhCnZ,KAAK6d,KAAK2C,aAElBX,EAGH,eAAe7B,EAAyB7V,GAK5C,OAJInI,KAAKghB,YACL7Y,EAAK4B,gBAAgB,EAAYkX,oBAAoBjhB,KAAK6d,KAAK7R,QAG5DgS,EADezS,EAAQ4P,aAAanb,KAAK+d,MAAM/d,KAAK+d,MAAMzS,OAAS,GAAGS,KAAM/L,KAAK6d,KAAK7R,QCrM9F,MAAMkV,EAIT,YAAY1c,EAAeC,GACvBzE,KAAKwE,MAAQA,EACbxE,KAAKyE,OAASA,EAGX,YAAYqC,EAAaf,EAAkB,GAC9C,MAAMQ,EAAWH,KAAKI,IAAIxG,KAAKwE,MAAOsC,EAAMtC,OACtCiC,EAAYzG,KAAKyE,OAASqC,EAAMrC,OAASsB,EAC/C,OAAO,IAAImb,EAAK3a,EAAUE,GAGvB,cAAcK,EAAaf,EAAkB,GAChD,MAAMQ,EAAWvG,KAAKwE,MAAQsC,EAAMtC,MAAQuB,EACtCU,EAAYL,KAAKI,IAAIxG,KAAKyE,OAAQqC,EAAMrC,QAC9C,OAAO,IAAIyc,EAAK3a,EAAUE,GAGvB,QACH,OAAO,IAAIya,EAAKlhB,KAAKwE,MAAOxE,KAAKyE,SCdlC,MAAM,EAUT,YAAYmY,EAAiB5Q,GAPtB,KAAA4T,YAA0Bxd,EAAWgX,KACrC,KAAAqF,cAAgB1b,EAAcoe,KAC9B,KAAAC,gBAAiCjc,EAEjC,KAAAkc,SAAW,EACV,KAAAC,YAA4Cnc,EAGhDnF,KAAKgM,MAAQA,EACbhM,KAAK4c,MAAQA,EAGV,UACH,OAAO,IAAIsE,EAAKlhB,KAAKuhB,eAAgBvhB,KAAKwhB,aAGvC,eACH,IAAIC,EAAW,EAEf,OADAzhB,KAAK0hB,WAAWrX,QAAQsX,GAAQF,EAAWrb,KAAKI,IAAIib,EAAUE,EAAKnd,QAC5Did,EAGJ,qBACH,MAAM1D,EAAQ/d,KAAK0hB,WACnB,OAAOnW,EAAQ4P,aAAa4C,EAAMA,EAAMzS,OAAS,GAAGS,KAAM/L,KAAKgM,OAG5D,YACH,OAAOhM,KAAK0hB,WAAWpW,OAAStL,KAAKgM,MAAM+N,YAGxC,WACH,IAAIgE,EACJ,QAAoB5Y,IAAhBnF,KAAKshB,OAGL,MAAM,IAAIM,MAAM,uDAEpB,OAJI7D,EAAQ/d,KAAKshB,OAIVvD,EAGX,mBACI,OAA6B,IAAtB/d,KAAK4c,MAAMtR,OAGf,cAAcnD,QACGhD,IAAhBnF,KAAKshB,SACLthB,KAAKshB,OAASthB,KAAK6hB,cAAc1Z,IAIjC,cAAcA,GAClB,IAAI4V,EAA+B,GACnC,GAAK/d,KAAKgM,MAAM8V,UAMZ9hB,KAAKqhB,SAAW,MANO,CACvB,MAAMU,EAAS,IAAI,EAAW/hB,MAC9B+hB,EAAOC,aAAa7Z,GACpBnI,KAAKqhB,SAAWU,EAAOnE,aACvBG,EAAQgE,EAAOhE,MAInB,OAAOA,IrBnEf,SAAYhb,GACR,mBACA,6BACA,yBAHJ,CAAYA,MAAa,KAalB,MAAM,EAKT,YAAYkf,EAAcC,GACtBliB,KAAKmiB,MAAQpf,EAAcoe,KAC3BnhB,KAAKoiB,MAAQH,EACbjiB,KAAKqiB,cAAgBH,EAGzB,YACI,IAAII,EAAM,EACV,KAAMA,EAAMtiB,KAAKoiB,MAAM9W,UAAYtL,KAAKoiB,MAAME,aAAgB,IAE1D,GADAA,IACIA,GAAOtiB,KAAKoiB,MAAM9W,OAClB,OAAO,IAAI,EAGnB,MAAMiX,EAAWviB,KAAKoiB,MAAME,GAC5B,YAAiBnd,IAAbod,EACO,IAAI,EAEPA,EAAqBvW,MAAM+J,SAGvC,WACI,OAAO/V,KAAKoiB,MAGhB,mBACI,OAAOpiB,KAAKqiB,cAGhB,WACI,OAAOriB,KAAKmiB,MAGhB,SAAgBK,GACZxiB,KAAKmiB,MAAQK,EACbxiB,KAAKoiB,MAAM/X,QAAQsT,IACXA,aAAe,IACfA,EAAIc,cAAgB+D,KAKzB,aAAaC,GAChB,IAAIC,EAAY,EAChB,MAAMT,EAAOjiB,KAAKiiB,KAClB,IAAI,IAAI7hB,EAAI,EAAGA,EAAI6hB,EAAK3W,OAAQlL,IAAK,CACjC,MAAMuiB,EAAYV,EAAK7hB,GAAGmhB,eAC1B,GAAIoB,GAAaF,EAAgB,CAC7BC,EAAYD,EACZ,MAEJC,GAAaC,EAEjB,OAAOvc,KAAKC,IAAIqc,EAAWD,GAGxB,YACH,MAAMzW,EAAQhM,KAAKgM,MACnB,IAAIvH,OAAoBU,IAAV6G,EAAuBA,EAAM4W,aAAe5W,EAAM6W,cAAgB,EAIhF,OAHA7iB,KAAKiiB,KAAK5X,QAAQsT,IACdlZ,GAAUkZ,EAAI6D,cAEX/c,EAGJ,cAAc0D,GACjBA,EAAK2a,2BACL,MAAMC,EAAS5a,EAAK8X,OACpB,IAAIO,EAAmC,EAcvC,QAbmBrb,IAAfnF,KAAKgM,OACL7D,EAAK4B,gBAAgB/J,KAAKgM,MAAM6W,oBAER1d,IAAxBnF,KAAKgM,MAAMyK,UACXzW,KAAKgM,MAAMyK,SAASpM,QAAQsH,IACxBA,EAAKqR,cAAc7a,GACfwJ,EAAKsR,QACL9a,EAAK+a,gBAEL/a,EAAKgb,WAAWxR,UAIDxM,IAAvBnF,KAAKqiB,cAA6B,CAClC,MAAMe,EAAajb,EAAKkb,QAExBD,EAAWrZ,iBAAiB,EAAYwW,iBAAiBvgB,KAAKqiB,cAAcrW,QAC5EhM,KAAKqiB,cAAcW,cAAcI,GACjC5C,EAAexgB,KAAKqiB,cAAchB,SAEtCrhB,KAAKiiB,KAAK5X,QAAQsT,IACdA,EAAI6C,aAAeA,EACnB7C,EAAIqF,cAAc7a,GAClBqY,EAAe7C,EAAI0D,SACnBlZ,EAAKmb,yBAAyB3F,EAAI0D,iBAEnBlc,IAAfnF,KAAKgM,OACL7D,EAAK4B,gBAAgB/J,KAAKgM,MAAM4W,cAEpC,MAAM7I,EAAc/Z,KAAKujB,kBACrBpb,EAAK8X,OAAS8C,EAAShJ,GACvB5R,EAAK4B,gBAAgBgQ,GAIrB,kBACJ,OAAQ/Z,KAAKiiB,KAAK,aAAc,EAAYjiB,KAAKiiB,KAAK,GAAejW,MAAM+N,YAAc,KCvHjG,SAAY/W,GACR,qBACA,uBACA,uBACA,uCACA,yBACA,+BACA,2BAPJ,CAAYA,MAAQ,KqBLb,MAAM,EAMT,YAAYwgB,GACR,MAAM9jB,EAAOyM,SAASC,gBAAgB,EAAWqX,MAAO,OAClDjf,EAAQgf,EAAQE,YAAYtP,WAClC1U,EAAK2M,aAAa,KAAM,OACxB3M,EAAK2M,aAAa,QAAS7H,GAC3B9E,EAAK2M,aAAa,SAAU,OAC5B3M,EAAK2M,aAAa,QAAS,mBAC3BmX,EAAQ5W,YAAYlN,GACpBM,KAAK2jB,KAAOjkB,EACZM,KAAK4jB,MAAQlkB,EAGjB,UACI,OAAOM,KAAK2jB,KAGT,UAAU3f,EAAWC,EAAWO,EAAeub,EAAoBhU,EAAciO,EAAe7H,EAA8B7F,EAAoBC,EAAkBC,EAAeC,GACtL,MAAMoX,EAAU1X,SAASC,gBAAgB,EAAWqX,MAAO,QAC3DzjB,KAAK8jB,SAASD,EAASvX,EAAYC,EAAUC,EAAMC,GACnDzM,KAAK+jB,UAAUF,EAAS7J,GACxBha,KAAKgkB,wBAAwBH,EAAS7f,EAAGQ,EAAO2N,EAAe4N,GAC/D/f,KAAKikB,sBAAsBJ,EAAS5f,EAAGsI,GACvC,MAAM2X,EAAW/X,SAASQ,eAAeZ,GACzC8X,EAAQjX,YAAYsX,GACpBlkB,KAAK2jB,KAAK/W,YAAYiX,GACtB7jB,KAAKmkB,UAAYN,EAGd,kBACH,IAAIO,EACJ,QAAuBjf,IAAnBnF,KAAKmkB,UAAyB,CAC9B,MAAME,EAAMrkB,KAAKmkB,UAAUG,UAC3BF,EAAO,CACHpgB,EAAGqgB,EAAIrgB,EACPC,EAAGogB,EAAIpgB,EACPO,MAAO6f,EAAI7f,MACXC,OAAQ4f,EAAI5f,aAGhB2f,EAAO,CACHpgB,EAAG,EACHC,EAAG,EACHO,MAAO,EACPC,OAAQ,GAGhB,OAAO2f,EAGJ,UAAUG,EAAYC,EAAYC,EAAYC,EAAY1K,EAAe2K,EAAmBC,GAC/F,MAAMjD,EAAOxV,SAASC,gBAAgB,EAAWqX,MAAO,QACxD9B,EAAKtV,aAAa,KAAMkY,EAAGnQ,YAC3BuN,EAAKtV,aAAa,KAAMmY,EAAGpQ,YAC3BuN,EAAKtV,aAAa,KAAMoY,EAAGrQ,YAC3BuN,EAAKtV,aAAa,KAAMqY,EAAGtQ,YAC3BuN,EAAKtV,aAAa,SAAU,IAAI2N,GAChC2H,EAAKtV,aAAa,eAAgBsY,EAAUvQ,YAC5CpU,KAAK6kB,YAAYlD,EAAMiD,GACvB5kB,KAAK2jB,KAAK/W,YAAY+U,GAGnB,aAAamD,EAAcC,EAA+BC,EAAiCC,EAAqCL,GACnI,MAAM1Y,EAAUC,SAASC,gBAAgB,EAAWqX,MAAO,QAC3DvX,EAAQG,aAAa,IAAKyY,QACR3f,IAAd4f,GACA7Y,EAAQG,aAAa,OAAQ,IAAI0Y,QAEjB5f,IAAhB6f,GACA9Y,EAAQG,aAAa,SAAU,IAAI2Y,GAEvC9Y,EAAQG,aAAa,eAAgB,GAAG4Y,GACxCjlB,KAAK6kB,YAAY3Y,EAAS0Y,GAC1B5kB,KAAK2jB,KAAK/W,YAAYV,GAGnB,aAAalI,EAAWC,EAAWO,EAAeC,EAAgBygB,QACzD/f,IAAR+f,GACAA,EAAIC,cAAcC,KAAKxX,IACnB,GAAIA,aAAeyX,WAAY,CAC3B,MAAMC,EAAInZ,SAASC,gBAAgB,EAAWqX,MAAO,KACrD7V,EAAIvB,aAAa,IAAK,GAAGrI,GACzB4J,EAAIvB,aAAa,IAAK,GAAGpI,GACzB2J,EAAIvB,aAAa,QAAS,GAAG7H,GAC7BoJ,EAAIvB,aAAa,SAAU,GAAG5H,GAC9BzE,KAAK6M,IAAID,YAAY0Y,GACrBA,EAAE1Y,YAAYgB,OACX,CACH,MAAM2X,EAAQpZ,SAASC,gBAAgB,EAAWqX,MAAO,SACzD8B,EAAMlZ,aAAa,IAAK,GAAGrI,GAC3BuhB,EAAMlZ,aAAa,IAAK,GAAGpI,GAC3BshB,EAAMlZ,aAAa,QAAS,GAAG7H,GAC/B+gB,EAAMlZ,aAAa,SAAU,GAAG5H,GAChCzE,KAAK6M,IAAID,YAAY2Y,GACrBA,EAAMlZ,aAAa,aAAc,GAAGuB,GACpC2X,EAAMlZ,aAAa,OAAQ,GAAGuB,MAEnC4X,MAAMC,IACL5U,QAAQC,IAAI,2BAA2B2U,KAK5C,QACH,KAAOzlB,KAAK6M,IAAI6Y,WACd1lB,KAAK6M,IAAIE,YAAY/M,KAAK6M,IAAI6Y,WAI7B,SAASnf,GAEZ,QAAcpB,IADAwI,EAAIqB,aAAahP,KAAK6M,IAAK,SAChB,CACrB7M,KAAK2jB,KAAKtX,aAAa,QAAS,GAAG9F,GACnC,MAAM7G,EAAOM,KAAK2jB,KAAKgC,cACV,OAATjmB,GACAA,EAAK2M,aAAa,QAAS,GAAG9F,IAKnC,aAAaE,GAChB,MAAMhC,EAASkJ,EAAIqB,aAAahP,KAAK6M,IAAK,UAC1C,QAAe1H,IAAXV,EAAsB,CACtB,MAAMmhB,EAAY9V,WAAWrL,GACvB2F,EAAOhE,KAAKI,IAAIof,EAAWnf,GACjC,GAAI2D,EAAOwb,EAAW,CAClB5lB,KAAK2jB,KAAKtX,aAAa,SAAU,GAAGjC,GACpC,MAAM1K,EAAOM,KAAK2jB,KAAKgC,cACV,OAATjmB,GACAA,EAAK2M,aAAa,SAAU,GAAGjC,KAMxC,UAAUwD,GACb,MAAMiY,EAAI1Z,SAASC,gBAAgB,EAAWqX,MAAO,KACrDoC,EAAExZ,aAAa,OAAQuB,GACvB5N,KAAK2jB,KAAOkC,EACZ7lB,KAAK4jB,MAAMhX,YAAY5M,KAAK2jB,MAGzB,UACC3jB,KAAK2jB,OAAS3jB,KAAK4jB,QACnB5jB,KAAK2jB,KAAO3jB,KAAK4jB,OAIjB,SAASM,EAAmB5X,EAAoBC,EAAkBC,EAAeC,GACrFyX,EAAS7X,aAAa,cAAeC,GACrC4X,EAAS7X,aAAa,YAAaE,EAAS6H,YACxC5H,GACA0X,EAAS7X,aAAa,cAAe,QAErCI,GACAyX,EAAS7X,aAAa,aAAc,UAIpC,UAAU6X,EAAmBlK,GACjCkK,EAAS7X,aAAa,OAAQ,IAAI2N,GAG9B,YAAYtN,EAAekY,GAC/B,OAAOA,GACH,KAAK5hB,EAAS8iB,OACVpZ,EAAKL,aAAa,mBAAoB,OACtC,MACJ,KAAKrJ,EAAS+iB,SACVrZ,EAAKL,aAAa,mBAAoB,OACtC,MACJ,KAAKrJ,EAASqS,OACV3I,EAAKL,aAAa,mBAAoB,KACtC,MACJ,KAAKrJ,EAASgjB,eACVtZ,EAAKL,aAAa,mBAAoB,OACtC,MACJ,KAAKrJ,EAASmS,QACVzI,EAAKL,aAAa,mBAAoB,WACtC,MACJ,KAAKrJ,EAASoS,WACV1I,EAAKL,aAAa,mBAAoB,gBAK1C,wBAAwB6X,EAAmBlgB,EAAWQ,EAAe2N,EAA8B4N,GACvG,OAAO5N,GACH,KAAKxP,EAAcqd,KACfkE,EAAS7X,aAAa,IAAKrI,EAAEoQ,YACzB2L,IACAmE,EAAS7X,aAAa,aAAc7H,EAAM4P,YAC1C8P,EAAS7X,aAAa,eAAgB,YAE1C,MACJ,KAAK1J,EAAciC,MACf,MAAMA,EAAQZ,EAAIQ,EAClB0f,EAAS7X,aAAa,IAAKzH,EAAMwP,YACjC8P,EAAS7X,aAAa,cAAe,OACrC,MACJ,KAAK1J,EAAcyP,OACf,MAAMA,EAASpO,EAAIQ,EAAQ,EAC3B0f,EAAS7X,aAAa,IAAK+F,EAAOgC,YAClC8P,EAAS7X,aAAa,cAAe,UACrC,MACJ,KAAK1J,EAAc+B,KACnB,QACIwf,EAAS7X,aAAa,IAAKrI,EAAEoQ,YAC7B8P,EAAS7X,aAAa,cAAe,UAKzC,sBAAsB6X,EAAmBjgB,EAAWmP,GACxD8Q,EAAS7X,aAAa,IAAKpI,EAAEmQ,aA1NT,EAAAqP,MAAQ,6BpBLpC,SAAYxgB,GACR,mBACA,uBACA,uCACA,uBACA,mCACA,yBACA,+BACA,uBACA,uBACA,+BACA,sBACA,wBACA,sBACA,8CACA,gDACA,8CACA,8CACA,gDACA,8CACA,sDACA,wDACA,sDACA,4BACA,8BACA,wBACA,oBA1BJ,CAAYA,MAAe,KA6BpB,MAAMgjB,EAMT,cACIjmB,KAAKwiB,KAAOvf,EAAgBoE,KAC5BrH,KAAKqF,KAAO,EACZrF,KAAK+F,QAAU,EACf/F,KAAKga,MAAQ,UqBlBd,MAAM,EAIT,YAAYkM,EAAmBC,GAC3BnmB,KAAKomB,SAAWF,EAChBlmB,KAAKqmB,aAAeF,EAGjB,YAAYtL,GACfA,EAAMyL,KAAKjc,QAAQkc,IACfA,EAAIC,MAAMnc,QAAQoc,IACVA,EAAKC,cAAgB,IACrB1mB,KAAK2mB,kBAAkBF,GACvBzmB,KAAK4mB,iBAAiBH,EAAM5L,EAAM7O,OAClCya,EAAKI,KAAKxc,QAAQyc,IACd9mB,KAAKqmB,aAAaU,gBAAgBD,UAO9C,kBAAkBL,GACtB,MAAM/d,EAAS+d,EAAK/d,OACpB,GAA2B,KAAvB+d,EAAKza,MAAMgb,cAA6B7hB,IAAXuD,EAAsB,CACnD,MAAMzE,EAAIyE,EAAOzE,EAAKyE,EAAOjE,OAAS,EACtCzE,KAAKomB,SAASa,UACVve,EAAOhE,KACPT,EACAyE,EAAO9D,MACPX,EACAwiB,EAAKza,MAAMgb,QACXte,EAAOjE,OACPzB,EAASkkB,QAKb,iBAAiBT,EAAiBza,GACtC,IAAImb,EAA2Cnb,EAAMob,QACrD,MAAMC,EAAeZ,EAAKza,MAAMob,QAEN,IAAtBpb,EAAMsb,aAAqBb,EAAKza,MAAMub,oBAEtCJ,OAAehiB,GAEnB,IAAIuD,EAAS+d,EAAK/d,YACHvD,IAAXuD,SAGiBvD,IAAjBgiB,SAC+BhiB,IAA3BgiB,EAAazhB,WACb1F,KAAKwnB,kBACDL,EAAazhB,UACb,CACI6e,GAAI7b,EAAOhE,KACX8f,GAAI9b,EAAO/D,IACX8f,GAAI/b,EAAO9D,MACX8f,GAAIhc,EAAO/D,IACXqV,MAAOmN,EAAazhB,UAAUsU,aAIR7U,IAA9BgiB,EAAavhB,cACb5F,KAAKwnB,kBACDL,EAAavhB,aACb,CACI2e,GAAI7b,EAAO9D,MACX4f,GAAI9b,EAAO7D,OACX4f,GAAI/b,EAAOhE,KACXggB,GAAIhc,EAAO7D,OACXmV,MAAOmN,EAAavhB,aAAaoU,aAIZ7U,IAA7BgiB,EAAa/hB,aACbpF,KAAKwnB,kBACDL,EAAa/hB,YACb,CACImf,GAAI7b,EAAO1E,EACXwgB,GAAI9b,EAAO7D,OACX4f,GAAI/b,EAAO1E,EACX0gB,GAAIhc,EAAO/D,IACXqV,MAAOmN,EAAa/hB,YAAY4U,aAIb7U,IAA3BgiB,EAAa3hB,WACbxF,KAAKwnB,kBACDL,EAAa3hB,UACb,CACI+e,GAAI7b,EAAO9D,MACX4f,GAAI9b,EAAO/D,IACX8f,GAAI/b,EAAO9D,MACX8f,GAAIhc,EAAO7D,OACXmV,MAAOmN,EAAa3hB,UAAUwU,cAKzB7U,IAAjBkiB,IACA3e,EAAO+e,gBAAgBzb,EAAMsb,kBACEniB,IAA3BkiB,EAAa3hB,WACb1F,KAAKwnB,kBACDH,EAAa3hB,UACb,CACI6e,GAAI7b,EAAOhE,KACX8f,GAAI9b,EAAO/D,IACX8f,GAAI/b,EAAO9D,MACX8f,GAAIhc,EAAO/D,IACXqV,MAAOqN,EAAa3hB,UAAUsU,aAIR7U,IAA9BkiB,EAAazhB,cACb5F,KAAKwnB,kBACDH,EAAazhB,aACb,CACI2e,GAAI7b,EAAO9D,MACX4f,GAAI9b,EAAO7D,OACX4f,GAAI/b,EAAOhE,KACXggB,GAAIhc,EAAO7D,OACXmV,MAAOqN,EAAazhB,aAAaoU,aAIZ7U,IAA7BkiB,EAAajiB,aACbpF,KAAKwnB,kBACDH,EAAajiB,YACb,CACImf,GAAI7b,EAAO1E,EACXwgB,GAAI9b,EAAO7D,OACX4f,GAAI/b,EAAO1E,EACX0gB,GAAIhc,EAAO/D,IACXqV,MAAOqN,EAAajiB,YAAY4U,aAIb7U,IAA3BkiB,EAAa7hB,WACbxF,KAAKwnB,kBACDH,EAAa7hB,UACb,CACI+e,GAAI7b,EAAO9D,MACX4f,GAAI9b,EAAO/D,IACX8f,GAAI/b,EAAO9D,MACX8f,GAAIhc,EAAO7D,OACXmV,MAAOqN,EAAa7hB,UAAUwU,UAO1C,kBAAkB0N,EAAqB/F,GAC3C,IAAIgG,EAAeD,EAAOriB,KAC1B,OAAQqiB,EAAOlF,MACX,KAAKvf,EAAgBoE,KACjB,MACJ,KAAKpE,EAAgBsS,OACjBvV,KAAK4nB,sBAAsBjG,EAAM,CAAC,CAAErX,IAAK,EAAG9F,MAAqB,EAAdkjB,EAAOriB,KAAUuf,QAAS5hB,EAASkkB,SACtF,MACJ,KAAKjkB,EAAgB4kB,OACjB7nB,KAAK4nB,sBAAsBjG,EAAM,CAAC,CAAErX,IAAK,EAAG9F,MAAqB,EAAdkjB,EAAOriB,KAAUuf,QAAS5hB,EAASkkB,SACtF,MACJ,KAAKjkB,EAAgB6kB,kBACjBH,GAAgB,GAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAAErX,IAAK,IAAMqd,EAAcnjB,MAAO,EAAImjB,EAAc/C,QAAS5hB,EAASkkB,OACtE,CAAE5c,IAAK,KAAOqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,SAEvE,MACJ,KAAKjkB,EAAgB8kB,mBACjBJ,GAAgB,GAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAAErX,IAAK,IAAMqd,EAAcnjB,MAAO,EAAImjB,EAAc/C,QAAS5hB,EAASkkB,OACtE,CAAE5c,IAAK,IAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,SAEtE,MACJ,KAAKjkB,EAAgB+kB,kBACjBL,GAAgB,EAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAAErX,IAAK,IAAMqd,EAAcnjB,MAAO,EAAImjB,EAAc/C,QAAS5hB,EAASkkB,OACtE,CAAE5c,IAAK,IAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,SAEtE,MACJ,KAAKjkB,EAAgBglB,kBACjBN,GAAgB,GAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAAErX,IAAK,GAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,OAClE,CAAE5c,IAAK,IAAMqd,EAAcnjB,MAAO,EAAImjB,EAAc/C,QAAS5hB,EAASkkB,SAE1E,MACJ,KAAKjkB,EAAgBilB,mBACjBP,GAAgB,GAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAAErX,IAAK,GAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,OAClE,CAAE5c,IAAK,IAAMqd,EAAcnjB,MAAO,EAAImjB,EAAc/C,QAAS5hB,EAASkkB,SAE1E,MACJ,KAAKjkB,EAAgBklB,kBACjBR,GAAgB,EAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAAErX,IAAK,GAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,OAClE,CAAE5c,IAAK,IAAMqd,EAAcnjB,MAAO,EAAImjB,EAAc/C,QAAS5hB,EAASkkB,SAE1E,MACJ,KAAKjkB,EAAgBmlB,sBACjBT,GAAgB,GAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAAErX,IAAK,GAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,OAClE,CAAE5c,IAAK,IAAMqd,EAAcnjB,MAAO,EAAImjB,EAAc/C,QAAS5hB,EAASkkB,OACtE,CAAE5c,IAAK,KAAOqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,SAEvE,MACJ,KAAKjkB,EAAgBolB,uBACjBV,GAAgB,GAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAAErX,IAAK,GAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,OAClE,CAAE5c,IAAK,IAAMqd,EAAcnjB,MAAO,EAAImjB,EAAc/C,QAAS5hB,EAASkkB,OACtE,CAAE5c,IAAK,KAAOqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,SAEvE,MACJ,KAAKjkB,EAAgBqlB,sBACjBX,GAAgB,GAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAAErX,IAAK,GAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,OAClE,CAAE5c,IAAK,IAAMqd,EAAcnjB,MAAO,EAAImjB,EAAc/C,QAAS5hB,EAASkkB,OACtE,CAAE5c,IAAK,IAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASkkB,SAEtE,MACJ,KAAKjkB,EAAgBslB,eACjBZ,GAAgB,EAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAACrX,IAAK,GAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAAS8iB,QACjE,CAACxb,IAAK,IAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASqS,UAErE,MACJ,KAAKpS,EAAgB6iB,OACjB9lB,KAAK4nB,sBAAsBjG,EAAM,CAAC,CAACrX,IAAK,EAAG9F,MAAOkjB,EAAOriB,KAAMuf,QAAS5hB,EAAS8iB,UACjF,MACJ,KAAK7iB,EAAgBulB,aACjBxoB,KAAK4nB,sBAAsBjG,EAAM,CAAC,CAACrX,IAAK,EAAG9F,MAAOkjB,EAAOriB,KAAMuf,QAAS5hB,EAASgjB,kBACjF,MACJ,KAAK/iB,EAAgBkS,QACjBwS,GAAgB,EAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAACrX,IAAK,GAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASqS,QACjE,CAAC/K,IAAK,IAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAAS8iB,UAErE,MACJ,KAAK7iB,EAAgBmS,WACjBuS,GAAgB,EAChB3nB,KAAK4nB,sBAAsBjG,EAAM,CAC7B,CAACrX,IAAK,GAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASqS,QACjE,CAAC/K,IAAK,IAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAASqS,QACjE,CAAC/K,IAAK,IAAMqd,EAAcnjB,MAAOmjB,EAAc/C,QAAS5hB,EAAS8iB,UAErE,MACJ,KAAK7iB,EAAgBoS,OACjBrV,KAAK4nB,sBAAsBjG,EAAM,CAAC,CAACrX,IAAK,EAAG9F,MAAOkjB,EAAOriB,KAAMuf,QAAS5hB,EAASqS,UACjF,MACJ,KAAKpS,EAAgBuS,OACrB,QACIxV,KAAK4nB,sBAAsBjG,EAAM,CAAC,CAACrX,IAAK,EAAG9F,MAAOkjB,EAAOriB,KAAMuf,QAAS5hB,EAASkkB,UAKrF,sBAAsBvF,EAAoB8G,GAC9C,MAAMC,EAAc/G,EAAK4C,KAAO5C,EAAK8C,GAAQ9C,EAAK6C,GAAK7C,EAAK+C,IAAO,EAAI,EAAK,EACtEiE,EAAchH,EAAK6C,KAAO7C,EAAK+C,GAAQ/C,EAAK4C,GAAK5C,EAAK8C,IAAO,EAAI,EAAK,EAC5EgE,EAASpe,QAAQue,IACb5oB,KAAKomB,SAASa,UACVtF,EAAK4C,GAAKmE,EAAaE,EAAIte,IAC3BqX,EAAK6C,GAAKmE,EAAaC,EAAIte,IAC3BqX,EAAK8C,GAAKiE,EAAaE,EAAIte,IAC3BqX,EAAK+C,GAAKiE,EAAaC,EAAIte,IAC3BqX,EAAK3H,MACL4O,EAAIpkB,MACJokB,EAAIhE,YCvSb,MAAM,EAGT,YAAYsB,GACRlmB,KAAKomB,SAAWF,EAGb,cAAcvI,GACjB,MAAMyD,EAAazD,EAAIyD,gBACJjc,IAAfic,GACAphB,KAAKomB,SAASyC,UAAUzH,GAE5BzD,EAAI+D,WAAWrX,QAASsX,IACpB3hB,KAAK8oB,YAAYnH,EAAMhE,EAAI3R,cAEZ7G,IAAfic,GACAphB,KAAKomB,SAAS2C,UAId,YAAYpH,EAA2B3V,GAC3C,MAAMhI,EAAIhE,KAAKgpB,MAAMrH,GACrB,GAA2B,WAAvB3V,EAAMwK,aAA2B,CACjC,MAAMuD,EAAc/N,EAAM+N,YACpB9V,EAAI0d,EAAK1d,EAAI,EAAYsc,iBAAiBvU,GAAS+N,EAAc,EACvE/Z,KAAKomB,SAASa,UAAUjjB,EAAGC,EAAGD,EAAI2d,EAAKnd,MAAOP,EAAG+H,EAAMwK,aAAcuD,EAAa/W,EAASkkB,OAE/F,MAAM/U,OAAwChN,IAAvBwc,EAAKxP,cAA+BwP,EAAKxP,cAAgBnG,EAAMmG,cAChF8W,EAASC,QAAQvH,EAAKtI,SAAWxW,EAAS0W,MAC1C4P,EAAWD,QAAQvH,EAAKtI,SAAWxW,EAAS2W,QAClDxZ,KAAKomB,SAASgD,UAAUplB,EAAG2d,EAAK1d,EAAG0d,EAAKnd,MAAOmd,EAAK5B,UAAW4B,EAAK5V,KAAM4V,EAAK3H,MAAO7H,EAAewP,EAAKrV,WAAYqV,EAAKpV,SAAU0c,EAAQE,IACzInd,EAAM2G,gBAAkBjQ,EAAc2E,MAAQ2E,EAAM4N,QAAU5N,EAAM6N,eAEpE7Z,KAAKqpB,iBAAiBrd,GAItB,iBAAiBA,GAErB,MAAMsd,EAAWtpB,KAAKomB,SAASmD,kBACzBhd,EAAWP,EAAMO,SACjBtI,EAAIqlB,EAASrlB,EAAIsI,EACjByN,EAAyB,SAAhBhO,EAAMgO,MAAoB,SAAWhO,EAAMgO,MACpD2K,EAAYpY,EAAW,GACvBid,EAAQ,EAAI7E,EAClB,OAAO3Y,EAAM2G,eACT,KAAKjQ,EAAc6S,OACfvV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAGqlB,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAG+V,EAAO2K,EAAW3hB,EAASkkB,OAClGlnB,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAI,EAAI0gB,EAAW2E,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAI,EAAI0gB,EAAW3K,EAAO2K,EAAW3hB,EAASkkB,OAClI,MACJ,KAAKxkB,EAAc+S,MACfzV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAI0gB,EAAW2E,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAI0gB,EAAW3K,EAAOwP,EAAOxmB,EAASkkB,OACtH,MACJ,KAAKxkB,EAAc2S,OACfrV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAGqlB,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAG+V,EAAO2K,EAAW3hB,EAASqS,QAClG,MACJ,KAAK3S,EAAc4S,YACftV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAI0gB,EAAW2E,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAI0gB,EAAW3K,EAAOwP,EAAOxmB,EAASqS,QACtH,MACJ,KAAK3S,EAAcmS,KACf7U,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAGqlB,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAG+V,EAAO2K,EAAW3hB,EAAS8iB,QAClG,MACJ,KAAKpjB,EAAcsS,YACfhV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAI0gB,EAAW2E,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAI0gB,EAAW3K,EAAOwP,EAAOxmB,EAAS8iB,QACtH,MACJ,KAAKpjB,EAAcyS,QACfnV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAGqlB,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAG+V,EAAO2K,EAAW3hB,EAASmS,SAClG,MACJ,KAAKzS,EAAcqS,aACf/U,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAI0gB,EAAW2E,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAI0gB,EAAW3K,EAAOwP,EAAOxmB,EAASmS,SACtH,MACJ,KAAKzS,EAAc0S,WACfpV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAGqlB,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAG+V,EAAO2K,EAAW3hB,EAASoS,YAClG,MACJ,KAAK1S,EAAcoS,gBACf9U,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAI0gB,EAAW2E,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAI0gB,EAAW3K,EAAOwP,EAAOxmB,EAASoS,YACtH,MACJ,KAAK1S,EAAcuS,SACfjV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAGqlB,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAG+V,EAAO2K,EAAW3hB,EAAS+iB,UAClG,MACJ,KAAKrjB,EAAcwS,cACflV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAI0gB,EAAW2E,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAI0gB,EAAW3K,EAAOwP,EAAOxmB,EAAS+iB,UACtH,MACJ,KAAKrjB,EAAc2E,KAEf,MACJ,QACA,KAAK3E,EAAc8S,OACfxV,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAGqlB,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAG+V,EAAO2K,EAAW3hB,EAASkkB,OAGtGlb,EAAM4N,QACN5Z,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAIsI,EAAW,EAAG+c,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAIsI,EAAW,EAAGyN,EAAO,EAAGhX,EAASkkB,OAExHlb,EAAM6N,eACN7Z,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAGqlB,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAKsI,EAAW,EAAK,EAAGyN,EAAO,EAAGhX,EAASkkB,OAC/GlnB,KAAKomB,SAASa,UAAUqC,EAAStlB,EAAGC,EAAGqlB,EAAStlB,EAAIslB,EAAS9kB,MAAOP,EAAKsI,EAAW,EAAK,EAAGyN,EAAO,EAAGhX,EAASkkB,QAI/G,MAAMvF,GACV,IAAI3d,EAAI2d,EAAK3d,EACb,GAAI2d,EAAKxB,UAAW,CAChB,MAAMiE,EAAOpkB,KAAKomB,SAASmD,kBAC3BvlB,EAAIoC,KAAKI,IAAIxC,EAAGogB,EAAKpgB,EAAIogB,EAAK5f,OAElC,OAAOR,GCjHR,MAAMylB,EAAb,cACW,KAAA1E,eAAgC5f,EAChC,KAAAukB,eAAgCvkB,EAChC,KAAAwkB,cAAwB,GCE5B,MAAM,GAOT,YAAYC,GALL,KAAA5d,MAAQ,IAAIyd,EAGZ,KAAA/gB,OAAc,IAAI,EAAI,EAAG,EAAG,EAAG,GAGlC1I,KAAK4pB,MAAQA,EAGV,iBACH,QAAuBzkB,IAAnBnF,KAAK6pB,WAA2B7pB,KAAK4pB,MAAME,MAAMC,OAAO,GAAGC,iBAAkB,CAC7E,MAAMC,EAAajqB,KAAK4pB,MAAME,MAAMI,gBACpCD,EAAWzjB,IAAMJ,KAAK+jB,KAAK,IAAMF,EAAWzjB,KAC5CxG,KAAK4pB,MAAME,MAAMM,cAAcH,EAAW5jB,IAAK4jB,EAAWzjB,QvBdtE,SAAYtD,GACR,iBACA,uBACA,mBACA,qBAJJ,CAAYA,MAAiB,KAO7B,SAAYC,GACR,mBACA,2BAFJ,CAAYA,MAAiB,KAK7B,SAAYC,GACR,uBADJ,CAAYA,MAAuB,KAInC,SAAYC,GACR,2BADJ,CAAYA,MAAkB,KAIvB,MAAM,GAmBT,YAAYumB,EAAmB5d,EAAmB1B,EAAwB+f,EAA0BC,EAA0BlmB,EAAgBmmB,GAbvI,KAAAC,eAA0CpnB,EAAwB2O,OAElE,KAAA0Y,UAAgCpnB,EAAmBqnB,SAEnD,KAAAC,qBAAqDxlB,EACrD,KAAAylB,qBAAiDzlB,EASpDnF,KAAK6qB,OAASjB,EACd5pB,KAAKgM,MAAQA,EACbhM,KAAK8I,SAAWwB,EAChBtK,KAAK8qB,cAAgBT,EACrBrqB,KAAK+qB,cAAgBT,EACrBtqB,KAAKgrB,YAAc5mB,EACnBpE,KAAKirB,eAAiB,IAAIxB,EAC1BzpB,KAAKkrB,eAAiB,IAAIzB,EAC1BzpB,KAAKmrB,aAAeZ,EAGxB,kBACI,OAAOvqB,KAAKmrB,aAGhB,qBACI,OAAQnrB,KAAKmrB,aAGV,yBACH,IAAIC,EACJ,GAAIprB,KAAK8I,WAAa5F,EAAkBmoB,QAAUrrB,KAAK8I,WAAa5F,EAAkBooB,IAClFF,EAAc,GAAUG,cAAgBvrB,KAAK6qB,OAAOW,UAAUzR,gBAC3D,CACH,IAAI0R,EAAW,EACfzrB,KAAK0rB,YAAYrhB,QAAQ0B,IACrB0f,EAAWrlB,KAAKI,IAAIilB,EAAU1f,EAAKT,UAEvC8f,EAAcK,EAAW,EAAY3P,iBAAiB9b,KAAK6qB,OAAOW,WAClEJ,GAAe,GAAUG,cAO7B,OALIvrB,KAAK8qB,gBAAkB3nB,EAAkBwoB,SACzCP,GAAe,GAAUQ,oBAClB5rB,KAAK+qB,gBAAkB5nB,EAAkBwoB,WAChDP,GAAe,GAAUS,qBAEtBT,EAGJ,gBACHprB,KAAK2qB,gBAAkB,GACvB3qB,KAAK4qB,gBAAkB,GACvB,MAAMkB,EAAY9rB,KAAK2qB,gBACjB5M,EAAQ/d,KAAK4qB,gBACbmB,EAAa/rB,KAAK6qB,OAAOmB,SAAStjB,OAClCshB,EAAmBhqB,KAAKisB,oBAC9B,OAAOjsB,KAAK8I,UACR,KAAK5F,EAAkB0O,KACnB,GAAIoY,EAAkB,CAClB,MAAM,IAAE3jB,EAAG,IAAEG,GAAQxG,KAAK6qB,OAAOf,MAAMI,gBACjCtN,EAAQ5c,KAAKksB,gBAAgB7lB,EAAKG,GAAK2lB,UACvCC,EAAkBpsB,KAAK6qB,OAAOW,UAAUjf,SAAW,EACnD8f,EAAgBN,EAAWtnB,QAAUmY,EAAMtR,OAAS,GAC1D,IAAIghB,EAAWP,EAAWpnB,IACtB4nB,EAAQR,EAAWrnB,KAAO,GAAU6mB,cACpCiB,EAAST,EAAWrnB,KACpB+nB,EAASV,EAAWrnB,KACpB1E,KAAK8qB,gBAAkB3nB,EAAkBwoB,UACzCY,GAAS,GAAUX,oBACnBa,GAAU,GAAUb,qBACb5rB,KAAK+qB,gBAAkB5nB,EAAkBwoB,WAChDY,GAAS,GAAUV,oBACnBY,GAAU,GAAUZ,0BAEc1mB,IAAlCnF,KAAKirB,eAAevB,YACpB8C,EAAST,EAAWnnB,OAExBgY,EAAMvS,QAAQ0B,IACV+f,EAAUvhB,KAAKvK,KAAK0sB,sBAAsBH,EAAOD,EAAWF,EAAiBrgB,EAAMpJ,EAAciC,QACjGmZ,EAAMxT,KAAK,CACPga,GAAIiI,EACJ/H,GAAIgI,EACJjI,GAAI8H,EACJ5H,GAAI4H,IAERA,GAAYD,IAGpB,MACJ,KAAKnpB,EAAkB+O,MAGvB,KAAK/O,EAAkBooB,IAEnB,MACJ,KAAKpoB,EAAkBmoB,OACnB,IAAKrB,EAAkB,CACnB,MAAMpN,EAAQ5c,KAAK0rB,YACnB,IAAIiB,EAAc/P,EAAMtR,OACpBshB,EAAiB,EACjB5sB,KAAK6qB,OAAOgC,YAAcvpB,EAAUwpB,MACpCH,IACAC,EAAiB,GAErB,MAAMG,EAAoBhB,EAAWvnB,MAAQmoB,EAAe,EAC5D,IAAIK,EAAWjB,EAAW/nB,EACtBipB,EAAQlB,EAAWlnB,OAAS,GAAU0mB,cAAgB,EAAYhL,iBAAiBvgB,KAAK6qB,OAAOW,WAC/F0B,EAASnB,EAAWlnB,OACpBsoB,EAASpB,EAAWlnB,OACpB7E,KAAK8qB,gBAAkB3nB,EAAkBwoB,UACzCsB,GAAS,GAAUrB,oBACnBuB,GAAU,GAAUvB,qBACb5rB,KAAK+qB,gBAAkB5nB,EAAkBwoB,WAChDsB,GAAS,GAAUpB,oBACnBsB,GAAU,GAAUtB,0BAEc1mB,IAAlCnF,KAAKirB,eAAevB,YACpBwD,EAASnB,EAAWpnB,KAExBiY,EAAMvS,QAAQ0B,IACV+f,EAAUvhB,KAAKvK,KAAK0sB,sBAAsBM,EAAWJ,EAAiBG,EAAkBE,EAAOlhB,EAAMpJ,EAAcyP,SACnH2L,EAAMxT,KAAK,CACPga,GAAIyI,EACJvI,GAAIuI,EACJxI,GAAI0I,EACJxI,GAAIyI,IAERH,GAAY,EAAID,IAEpBhP,EAAMxT,KAAK,CACPga,GAAIyI,EACJvI,GAAIuI,EACJxI,GAAI0I,EACJxI,GAAIyI,MAOhB,oBACJ,MAAMrD,EAAQ9pB,KAAK6qB,OAAOf,MAC1B,OAAQ9pB,KAAgB,YAAI8pB,EAAMC,OAAO,GAAGC,iBAAmBF,EAAMC,OAAO,GAAGqD,qBAG3E,YACJ,MAAM,IAAE/mB,EAAG,IAAEG,GAAQxG,KAAK6qB,OAAOf,MAAMI,gBACvC,OAAQlqB,KAAgB,YAAIA,KAAKksB,gBAAgB7lB,EAAKG,GAAOxG,KAAKqtB,oBAG9D,oBACJ,OAAOrtB,KAAK6qB,OAAOf,MAAMC,OAAO,GAAGuD,WAAWjN,IAAIkN,GACvCA,EAAInZ,YAIX,gBAAgB/N,EAAaG,GACjC,MAAMoW,EAAkB,GAClBjS,GAASnE,EAAMH,GAAO,GAAUmnB,eACtC,IAAK,IAAIptB,EAAIiG,EAAKjG,GAAKoG,EAAKpG,GAAKuK,EAC7BiS,EAAMrS,KAAKnK,EAAEgU,YAEjB,OAAOwI,EAGH,sBAAsB5Y,EAAWC,EAAW8H,EAAcoG,GAC9D,MAAMqZ,EAAYxrB,KAAK6qB,OAAOW,UAC9B,MAAO,CACHzf,KAAMA,EACN/H,EAAGA,EACHC,EAAGA,EACHO,MAAO,EACPub,WAAW,EACXI,WAAW,EACXhO,cAAeA,EACf6H,MAAOwR,EAAUxR,MACjB1N,WAAYkf,EAAUlf,WACtBC,SAAUif,EAAUjf,SACpB8M,SAAUmS,EAAUnS,WA9Kb,GAAAkS,cAAgB,EAChB,GAAAK,oBAAsB,EACtB,GAAAC,oBAAsB,EACtB,GAAA2B,eAAiB,EwBnC7B,MAAM,GAWT,YAAY5D,GATL,KAAA5d,MAAoB,IAAIyd,EACxB,KAAA3gB,SAA8B5F,EAAkB+O,MAChD,KAAAwb,eAAyB,EACzB,KAAAC,gBAAiCvoB,EACjC,KAAAuD,OAAc,IAAI,EAAI,EAAG,EAAG,EAAG,GAMlC1I,KAAK4pB,MAAQA,EAGjB,iBACI,OAAO,GAAY+D,YAGvB,oBACI,OAAO,GAAYC,eAGhB,WACH,MAAM7P,EAA+B,GAC/ByN,EAAYxrB,KAAK4pB,MAAM4B,UACvBxnB,EAAIhE,KAAK0I,OAAO1E,EAAI,GAAY2pB,YAAc,GAAYC,eAChE,IAAI3pB,EAAIjE,KAAK0I,OAAOzE,EAAI,EAAYsc,iBAAiBiL,GAgBrD,OAfAxrB,KAAK6tB,YAAYxjB,QAAQ1J,IACrBod,EAAMxT,KAAK,CACPwB,KAAMpL,EACNqD,EAAGA,EACHC,EAAGA,EACHO,MAAOxE,KAAK0I,OAAOlE,MACnBub,WAAW,EACXI,WAAW,EACXnG,MAAOwR,EAAUxR,MACjB1N,WAAYkf,EAAUlf,WACtBC,SAAUif,EAAUjf,SACpB8M,SAAUmS,EAAUnS,WAExBpV,GAAKunB,EAAUzR,cAEZgE,EAGJ,gBACH,MAAM1Y,EAAOrF,KAAK8tB,WACZC,EAAc/tB,KAAK4pB,MAAMlhB,OAC/B,IAAIhC,EAAOtE,EAAWyE,KAClBF,EAAOvE,EAAWwE,OACtB,OAAO5G,KAAK8I,UACR,KAAK5F,EAAkB0O,KACnBlL,EAAOtE,EAAW+W,MAClBxS,EAAOvE,EAAWwE,OAClB,MACJ,KAAK1D,EAAkB+O,MACnBvL,EAAOtE,EAAWyE,KAClBF,EAAOvE,EAAWwE,OAClB,MACJ,KAAK1D,EAAkBooB,IACnB5kB,EAAOtE,EAAWwE,OAClBD,EAAOvE,EAAW+W,MAClB,MACJ,KAAKjW,EAAkB+O,MACnBvL,EAAOtE,EAAWwE,OAClBD,EAAOvE,EAAWyE,KAG1B7G,KAAK0I,OAASqlB,EAAYtG,gBAAgB,GAAY1hB,SAASioB,iBAAiB3oB,EAAKb,MAAOa,EAAKZ,OAAQiC,EAAMC,GAG5G,YACH,IAAIsnB,EAYJ,OAVIA,OADoB9oB,IAApBnF,KAAK0tB,WACI1tB,KAAK4pB,MAAME,MAAMC,OAAO1J,IAAK0J,GAAWA,EAAO/d,MAAM0d,WAAaK,EAAO/d,MAAM+Y,WAAa,UAE5F/kB,KAAK4pB,MAAME,MAAMC,OAAO/pB,KAAK0tB,YAAYJ,WAAWjN,IAAKkN,IAC9D,IAAIvT,EAAQ,SAIZ,YAHkB7U,IAAdooB,EAAIvhB,QACJgO,EAAQuT,EAAIvhB,MAAM0d,WAAa6D,EAAIvhB,MAAM+Y,WAAa,UAEnD/K,IAGRiU,EAGH,YACJ,IAAIC,EAMJ,OAJIA,OADoB/oB,IAApBnF,KAAK0tB,WACG1tB,KAAK4pB,MAAME,MAAMC,OAAO1J,IAAK0J,GAAWA,EAAOppB,MAE/CX,KAAK4pB,MAAME,MAAMC,OAAO/pB,KAAK0tB,YAAYJ,WAAWjN,IAAKkN,GAAQA,EAAIxhB,MAAQ,IAElFmiB,EAGH,WACJ,MAAMrS,EAAY,EAAYC,iBAAiB9b,KAAK4pB,MAAM4B,WAC1D,IAAIC,EAAW,EACf,MAAMyC,EAAQluB,KAAK6tB,YACnBK,EAAM7jB,QAAQ1J,IACV8qB,EAAWrlB,KAAKI,IAAIilB,EAAU9qB,EAAK2K,UAEvC,MAAMyO,EAAc/Z,KAAK4pB,MAAM4B,UAAUzR,YACnCtV,EAASypB,EAAM5iB,OAASyO,EAG9B,MAAO,CAAEvV,OAFUinB,EAAW,GAAK5P,GACf,GAAY8R,YAAc,GAAYC,gBACjBnpB,OAAQA,IAtGtC,GAAAkpB,YAAc,GACd,GAAAC,eAAiB,EAClB,GAAA7nB,QAAU,EvBH5B,SAAYzC,GACR,iBACA,mBACA,mBACA,iBAJJ,CAAYA,MAAS,KAOd,MAAM,GAUT,cATQ,KAAA6qB,cAAsChpB,EACtC,KAAAipB,YAAgCjpB,EAChC,KAAAgd,MAAQ7e,EAAUwpB,IACnB,KAAA9gB,MAAoB,IAAIyd,EACxB,KAAA+B,UAAmB,IAAI,EAEvB,KAAA6C,YAAkClpB,EAClC,KAAAuD,OAAc,IAAI,EAAI,EAAG,EAAG,EAAG,GAIlC1I,KAAKwrB,UAAU7U,SAASqE,WAAW,SAAS,EAAO,IACnDhb,KAAKwrB,UAAUzV,SAASuY,eAAe,KACvCtuB,KAAKgsB,SAAW,IAAI,GAAchsB,MAG/B,0BACmBmF,IAAlBnF,KAAKmuB,iBACCnuB,KAAKmuB,SACXnuB,KAAKmuB,cAAWhpB,GAIxB,gBACI,OAAOnF,KAAKmiB,MAGhB,YACI,OAAOniB,KAAKouB,OAGT,aAAaG,GAChBvuB,KAAKouB,OAASG,EACdvuB,KAAKmiB,MAAQ7e,EAAUkrB,KAGpB,aAAaC,GAChBzuB,KAAKouB,OAASK,EACdzuB,KAAKmiB,MAAQ7e,EAAUorB,KAGpB,YAAYC,GACf3uB,KAAKouB,OAASO,EACd3uB,KAAKmiB,MAAQ7e,EAAUwpB,IAGpB,YAAY8B,GACf5uB,KAAKouB,OAASQ,EACd5uB,KAAKmiB,MAAQ7e,EAAUurB,IAGpB,WAAWC,GACd9uB,KAAK+uB,eACL/uB,KAAKmuB,SAAWW,EAGb,cAAcE,GAEjB,MAAMF,EAAU,IAAIjhB,QAAcohB,MAAOnhB,EAASohB,WACxClvB,KAAKmuB,SACXnuB,KAAKmvB,iBACLrhB,MAEJ9N,KAAKovB,WAAWN,GAGZ,iBACJ9uB,KAAKgsB,SAASqD,iBACd,IAAItD,EAAa/rB,KAAK0I,OAAO+e,gBAAgB,SACzBtiB,IAAhBnF,KAAKquB,SACLtC,EAAa/rB,KAAKsvB,cAAcvD,EAAY/rB,KAAKquB,cAErBlpB,IAA5BnF,KAAKgsB,SAASnC,YACdkC,EAAa/rB,KAAKuvB,cAAcxD,EAAY/rB,KAAKgsB,SAASnC,iBAE3B1kB,IAA/BnF,KAAKgsB,SAASwD,eACdzD,EAAa/rB,KAAKuvB,cAAcxD,EAAY/rB,KAAKgsB,SAASwD,eAE9DxvB,KAAKgsB,SAAStjB,OAASqjB,OACS5mB,IAA5BnF,KAAKgsB,SAASnC,WACd7pB,KAAKgsB,SAASnC,UAAU7G,qBAEO7d,IAA/BnF,KAAKgsB,SAASwD,cACdxvB,KAAKgsB,SAASwD,aAAaxM,gBAI3B,cAAc+I,EAAiBsC,GAEnC,GADAA,EAAOrL,iBACFqL,EAAOZ,cAAe,CACvB,IAAI/oB,EAAO,EACPE,EAAQ,EACRD,EAAM,EACNE,EAAS,EACb,OAAQwpB,EAAOvlB,UACX,KAAK5F,EAAkB0O,KACnBlN,GAAQ2pB,EAAO3lB,OAAOlE,MAAQ,GAAYuB,QAC1C,MACJ,KAAK7C,EAAkB+O,MACnBrN,GAASypB,EAAO3lB,OAAOlE,MAAQ,GAAYuB,QAC3C,MACJ,KAAK7C,EAAkBooB,IACnB3mB,GAAO0pB,EAAO3lB,OAAOjE,OAAS,GAAYsB,QAC1C,MACJ,KAAK7C,EAAkBmoB,OACnBxmB,GAAUwpB,EAAO3lB,OAAOjE,OAAS,GAAYsB,QAGrD,OAAOgmB,EAAW/lB,eAAetB,EAAMC,EAAKC,EAAOC,GAGvD,OAAOknB,EAGH,cAAcA,EAAiB0D,GACnC,MAAMC,EAAWD,EAAKE,yBACtB,IAAIjrB,EAAO,EACPE,EAAQ,EACRD,EAAM,EACNE,EAAS,EACb,OAAQ4qB,EAAK3mB,UACT,KAAK5F,EAAkB0O,KACnBlN,GAAQgrB,EACR,MACJ,KAAKxsB,EAAkB+O,MACnBrN,GAAS8qB,EACT,MACJ,KAAKxsB,EAAkBooB,IACnB3mB,GAAO+qB,EACP,MACJ,KAAKxsB,EAAkBmoB,OACnBxmB,GAAU6qB,EAGlB,OAAO3D,EAAW/lB,eAAetB,EAAMC,EAAKC,EAAOC,IwB5JpD,MAAM+qB,GAGT,YAAoBC,GAFZ,KAAAC,SAAmB,EAGvB9vB,KAAK8vB,SAAWD,EAGb,oBAAoBhkB,GACvB,OAAO,IAAI+jB,GAAM/jB,EAAM,KAGpB,mBAAmBgkB,GACtB,OAAO,IAAID,GAAMC,GAGd,mBAAmBE,GACtB,OAAO,IAAIH,GAAY,IAANG,EAAY3pB,KAAK0F,IAG/B,sBAAsBkkB,GACzB,OAAO,IAAIJ,GAAa,IAAPI,GAGd,IAAIlpB,GACP,OAAO,IAAI8oB,GAAM5vB,KAAK8vB,SAAWhpB,EAAMgpB,UAGpC,SAAShpB,GACZ,OAAO,IAAI8oB,GAAM5vB,KAAK8vB,SAAWhpB,EAAMgpB,UAGpC,MAAMG,GACJA,GAAgC,MAAlBjwB,KAAK8vB,WACpB9vB,KAAK8vB,UAAY9vB,KAAK8vB,SAAW,KAAO,KAIzC,YACH,OAAO9vB,KAAK8vB,SAGT,eACH,OAAO9vB,KAAK8vB,SAAW,IAGpB,YACH,OAAO9vB,KAAK8vB,SAAW1pB,KAAK0F,GAAK,IAG9B,aACH,OAAuB,IAAhB9L,KAAK8vB,SAGT,WACH,OAAU9vB,KAAK8vB,SAAR,KC7Cf,MAAMI,GAEF,YAAmBvvB,EAAsBqD,EAAmBC,EAAmBksB,GAA5D,KAAAxvB,OAAsB,KAAAqD,IAAmB,KAAAC,IAAmB,KAAAksB,IAGxE,SAASC,GAIZ,OAHUA,EAAMvX,SAAS7Y,KAAKgE,GACpBosB,EAAMvX,SAAS7Y,KAAKiE,GACpBmsB,EAAMvX,SAAS7Y,KAAKmwB,GAI3B,WACH,MAAO,GAAGnwB,KAAKW,YAAYX,KAAKgE,KAAKhE,KAAKiE,KAAKjE,KAAKmwB,KAI5D,MAAME,GAEF,YAAmB1vB,EAAsBqD,EAAmBC,EAAmBksB,GAA5D,KAAAxvB,OAAsB,KAAAqD,IAAmB,KAAAC,IAAmB,KAAAksB,IAGxE,SAASC,GAIZ,OAHUA,EAAMvX,SAAS7Y,KAAKgE,GACpBosB,EAAMvX,SAAS7Y,KAAKiE,GACpBmsB,EAAMvX,SAAS7Y,KAAKmwB,GAI3B,WACH,MAAO,GAAGnwB,KAAKW,YAAYX,KAAKgE,KAAKhE,KAAKiE,KAAKjE,KAAKmwB,KAI5D,MAAMG,GAEF,YAAmB3vB,EAAsBqD,EAAmBC,EAAmBksB,GAA5D,KAAAxvB,OAAsB,KAAAqD,IAAmB,KAAAC,IAAmB,KAAAksB,IAGxE,SAASC,GAIZ,OAHUA,EAAMvX,SAAS7Y,KAAKgE,GACpBosB,EAAMvX,SAAS7Y,KAAKiE,IACpBmsB,EAAMvX,SAAS7Y,KAAKmwB,GAI3B,WACH,MAAO,GAAGnwB,KAAKW,YAAYX,KAAKgE,KAAKhE,KAAKiE,KAAKjE,KAAKmwB,KAI5D,MAAMI,GAEF,YAAmB5vB,EAAsBqD,EAAmBC,EAAmBksB,GAA5D,KAAAxvB,OAAsB,KAAAqD,IAAmB,KAAAC,IAAmB,KAAAksB,IAGxE,SAASC,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GACxBksB,EAAIC,EAAMvX,SAAS7Y,KAAKmwB,GAC9B,OAAQnsB,EAAI,EAAKC,EAAIksB,EAGlB,WACH,MAAO,GAAGnwB,KAAKW,YAAYX,KAAKgE,KAAKhE,KAAKiE,KAAKjE,KAAKmwB,KAI5D,MAAMK,GAEF,YAAmB7vB,EAAsBqD,GAAtB,KAAArD,OAAsB,KAAAqD,IAGlC,SAASosB,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GAC9B,OAAOoC,KAAKqqB,IAAIzsB,GAGb,WACH,MAAO,GAAGhE,KAAKW,aAAaX,KAAKgE,KAIzC,MAAM0sB,GAEF,YAAmB/vB,EAAsBqD,EAAmBC,GAAzC,KAAAtD,OAAsB,KAAAqD,IAAmB,KAAAC,IAGrD,SAASmsB,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GAC9B,OAAOmC,KAAKuqB,MAAM1sB,EAAGD,GAGlB,WACH,MAAO,GAAGhE,KAAKW,aAAaX,KAAKgE,KAAKhE,KAAKiE,KAInD,MAAM2sB,GAEF,YAAmBjwB,EAAsBqD,EAAmBC,EAAmBksB,GAA5D,KAAAxvB,OAAsB,KAAAqD,IAAmB,KAAAC,IAAmB,KAAAksB,IAGxE,SAASC,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GACxBksB,EAAIC,EAAMvX,SAAS7Y,KAAKmwB,GAC9B,OAAQnsB,EAAIoC,KAAKyqB,IAAIzqB,KAAKuqB,MAAMR,EAAGlsB,IAGhC,WACH,MAAO,GAAGjE,KAAKW,cAAcX,KAAKgE,KAAKhE,KAAKiE,KAAKjE,KAAKmwB,KAI9D,MAAMW,GAEF,YAAmBnwB,EAAsBqD,EAAmBC,GAAzC,KAAAtD,OAAsB,KAAAqD,IAAmB,KAAAC,IAGrD,SAASmsB,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMW,cAAc/wB,KAAKiE,GACnC,OAAOD,EAAIoC,KAAKyqB,IAAI5sB,EAAE+sB,aAGnB,WACH,MAAO,GAAGhxB,KAAKW,aAAaX,KAAKgE,KAAKhE,KAAKiE,KAInD,MAAMgtB,GAEF,YAAmBtwB,EAAsBqD,EAAmBC,GAAzC,KAAAtD,OAAsB,KAAAqD,IAAmB,KAAAC,IAGrD,SAASmsB,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GAC9B,OAAOmC,KAAKI,IAAIxC,EAAGC,GAGhB,WACH,MAAO,GAAGjE,KAAKW,aAAaX,KAAKgE,KAAKhE,KAAKiE,KAInD,MAAMitB,GAEF,YAAmBvwB,EAAsBqD,EAAmBC,GAAzC,KAAAtD,OAAsB,KAAAqD,IAAmB,KAAAC,IAGrD,SAASmsB,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GAC9B,OAAOmC,KAAKC,IAAIrC,EAAGC,GAGhB,WACH,MAAO,GAAGjE,KAAKW,aAAaX,KAAKgE,KAAKhE,KAAKiE,KAInD,MAAMktB,GAEF,YAAmBxwB,EAAsBqD,EAAmBC,EAAmBksB,GAA5D,KAAAxvB,OAAsB,KAAAqD,IAAmB,KAAAC,IAAmB,KAAAksB,IAGxE,SAASC,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GACxBksB,EAAIC,EAAMvX,SAAS7Y,KAAKmwB,GAC9B,OAAO/pB,KAAKgrB,KAAKptB,EAAIA,EAAIC,EAAIA,EAAIksB,EAAIA,GAGlC,WACH,MAAO,GAAGnwB,KAAKW,aAAaX,KAAKgE,KAAKhE,KAAKiE,KAAKjE,KAAKmwB,KAI7D,MAAMkB,GAEF,YAAmB1wB,EAAsBqD,EAAmBC,EAAmBksB,GAA5D,KAAAxvB,OAAsB,KAAAqD,IAAmB,KAAAC,IAAmB,KAAAksB,IAGxE,SAASC,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GACxBksB,EAAIC,EAAMvX,SAAS7Y,KAAKmwB,GAC9B,OAAQlsB,EAAID,EAAKA,EAAKC,EAAIksB,EAAKA,EAAIlsB,EAGhC,WACH,MAAO,GAAGjE,KAAKW,aAAaX,KAAKgE,KAAKhE,KAAKiE,KAAKjE,KAAKmwB,KAI7D,MAAMmB,GAEF,YAAmB3wB,EAAsBqD,EAAmBC,EAAmBksB,GAA5D,KAAAxvB,OAAsB,KAAAqD,IAAmB,KAAAC,IAAmB,KAAAksB,IAGxE,SAASC,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GACxBksB,EAAIC,EAAMvX,SAAS7Y,KAAKmwB,GAC9B,OAAOnsB,EAAIoC,KAAKmrB,IAAInrB,KAAKuqB,MAAMR,EAAGlsB,IAG/B,WACH,MAAO,GAAGjE,KAAKW,cAAcX,KAAKgE,KAAKhE,KAAKiE,KAAKjE,KAAKmwB,KAI9D,MAAMqB,GAEF,YAAmB7wB,EAAsBqD,EAAmBC,GAAzC,KAAAtD,OAAsB,KAAAqD,IAAmB,KAAAC,IAGrD,SAASmsB,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMW,cAAc/wB,KAAKiE,GACnC,OAAOD,EAAIoC,KAAKmrB,IAAIttB,EAAE+sB,aAGnB,WACH,MAAO,GAAGhxB,KAAKW,aAAaX,KAAKgE,KAAKhE,KAAKiE,KAInD,MAAMwtB,GAEF,YAAmB9wB,EAAsBqD,GAAtB,KAAArD,OAAsB,KAAAqD,IAGlC,SAASosB,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GAC9B,OAAOoC,KAAKgrB,KAAKptB,GAGd,WACH,MAAO,GAAGhE,KAAKW,cAAcX,KAAKgE,KAI1C,MAAM0tB,GAEF,YAAmB/wB,EAAsBqD,EAAmBC,GAAzC,KAAAtD,OAAsB,KAAAqD,IAAmB,KAAAC,IAGrD,SAASmsB,GACZ,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GAC9B,OAAOD,EAAIoC,KAAKurB,IAAI1tB,GAGjB,WACH,MAAO,GAAGjE,KAAKW,aAAaX,KAAKgE,KAAKhE,KAAKiE,KAInD,MAAM2tB,GAEF,YAAmBjxB,EAAsBqD,GAAtB,KAAArD,OAAsB,KAAAqD,IAGlC,SAASosB,GAEZ,OADUA,EAAMvX,SAAS7Y,KAAKgE,GAI3B,WACH,MAAO,GAAGhE,KAAKW,aAAaX,KAAKgE,KAIzC,MAAM6tB,GACF,YAAoBlxB,EAAsBmxB,GAAtB,KAAAnxB,OAAsB,KAAAmxB,OAInC,SAAS1B,GACZ,OAAOpwB,KAAK8xB,KAAK1B,EAAM2B,OAIpB,WACH,OAAU/xB,KAAKW,KAAR,cAIR,MAAM,GAKT,YAAYoxB,GAHJ,KAAAC,UAAwB,GACxB,KAAAC,WAA6C,GAGjDjyB,KAAK+xB,MAAQA,EAGV,WAAWG,EAAiBvxB,GAC/B,MAAMwxB,EAAQD,EAAQ1d,MAAM,KAC5B,GAAI2d,EAAM7mB,OAAS,EAEf,YADAuF,QAAQC,IAAI,oCAAoCohB,GAGpD,IAAIE,OAA6BjtB,EACjC,OAAOgtB,EAAM,IACT,IAAK,KACDC,EAAO,IAAIlC,GAAsBvvB,EAAMwxB,EAAM,GAAIA,EAAM,GAAIA,EAAM,IACjE,MACJ,IAAK,KACDC,EAAO,IAAI/B,GAAmB1vB,EAAMwxB,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAC9D,MACJ,IAAK,KACDC,EAAO,IAAI9B,GAAiB3vB,EAAMwxB,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAC5D,MACJ,IAAK,KACDC,EAAO,IAAI7B,GAAc5vB,EAAMwxB,EAAM,GAAIA,EAAM,GAAIA,EAAM,IACzD,MACJ,IAAK,MACDC,EAAO,IAAI5B,GAAgB7vB,EAAMwxB,EAAM,IACvC,MACJ,IAAK,MACDC,EAAO,IAAI1B,GAAc/vB,EAAMwxB,EAAM,GAAIA,EAAM,IAC/C,MACJ,IAAK,OACDC,EAAO,IAAIxB,GAAoBjwB,EAAMwxB,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAC/D,MACJ,IAAK,MACDC,EAAO,IAAItB,GAAcnwB,EAAMwxB,EAAM,GAAIA,EAAM,IAC/C,MACJ,IAAK,MACDC,EAAO,IAAInB,GAAetwB,EAAMwxB,EAAM,GAAIA,EAAM,IAChD,MACJ,IAAK,MACDC,EAAO,IAAIlB,GAAevwB,EAAMwxB,EAAM,GAAIA,EAAM,IAChD,MACJ,IAAK,MACDC,EAAO,IAAIjB,GAAcxwB,EAAMwxB,EAAM,GAAIA,EAAM,GAAIA,EAAM,IACzD,MACJ,IAAK,MACDC,EAAO,IAAIf,GAAW1wB,EAAMwxB,EAAM,GAAIA,EAAM,GAAIA,EAAM,IACtD,MACJ,IAAK,OACDC,EAAO,IAAId,GAAkB3wB,EAAMwxB,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAC7D,MACJ,IAAK,MACDC,EAAO,IAAIZ,GAAY7wB,EAAMwxB,EAAM,GAAIA,EAAM,IAC7C,MACJ,IAAK,OACDC,EAAO,IAAIX,GAAkB9wB,EAAMwxB,EAAM,IACzC,MACJ,IAAK,MACDC,EAAO,IAAIV,GAAe/wB,EAAMwxB,EAAM,GAAIA,EAAM,IAChD,MACJ,IAAK,MACDC,EAAO,IAAIR,GAAoBjxB,EAAMwxB,EAAM,IAC3C,MACJ,QACIthB,QAAQC,IAAI,wCAAwCqhB,EAAM,SAGrDhtB,IAATitB,GACApyB,KAAKgyB,UAAUznB,KAAK6nB,GAIrB,SAASC,GACZ,IAAIvjB,EAOJ,OAJIA,EAFa,UAAUwjB,KAAKD,KAA2C,IAA7BA,EAAU7iB,QAAQ,MAEtDM,WAAWuiB,GAEXryB,KAAKuyB,kBAAkBF,GAE1BvjB,EAGJ,cAAcujB,GACjB,MAAMvjB,EAAM9O,KAAK6Y,SAASwZ,GAE1B,OADczC,GAAM4C,aAAa1jB,GAI9B,WACH9O,KAAKgyB,UAAU3nB,QAAQ6nB,IACnBlyB,KAAKyyB,kBAAkBP,KAIxB,0BACH,OAAOlyB,KAAKiyB,WAAW5R,IAAIvR,GAAO,GAAGA,EAAInO,QAAQmO,EAAIA,OAAOuO,KAAK,KAG7D,kBAAkB1c,GACtB,IAAImO,EAAM9O,KAAKiyB,WAAWS,KAAMC,GAAYA,EAAQhyB,OAASA,GAC7D,QAAYwE,IAAR2J,EAGA,OAAOnO,GACH,IAAK,IAEDmO,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,IAAME,GAAiBA,EAAMttB,SACjF,MACJ,IAAK,MAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMttB,OAAS,IAC5F,MACJ,IAAK,MAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMttB,OAAS,IAC5F,MACJ,IAAK,MAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMttB,OAAS,IAC5F,MACJ,IAAK,MAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMttB,OAAS,IAC5F,MACJ,IAAK,MAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMttB,OAAS,IAC5F,MACJ,IAAK,MAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMttB,OAAS,IAC5F,MACJ,IAAK,IAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,IAAME,GAAiBA,EAAMvtB,QACjF,MACJ,IAAK,MAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMvtB,MAAQ,IAC3F,MACJ,IAAK,MAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMvtB,MAAQ,IAC3F,MACJ,IAAK,MAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMvtB,MAAQ,IAC3F,MACJ,IAAK,MAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMvtB,MAAQ,IAC3F,MACJ,IAAK,MAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMvtB,MAAQ,IAC3F,MACJ,IAAK,MAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQE,GAAiBA,EAAMvtB,MAAQ,IAC3F,MACJ,IAAK,OAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASE,GAAiBA,EAAMvtB,MAAQ,KAC5F,MACJ,IAAK,MAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQgB,GAAkBjD,GAAMkD,eAAe,IAAKC,eACxG,MACJ,IAAK,MAEDjkB,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQgB,GAAkBjD,GAAMkD,eAAe,EAAE,GAAGC,eACxG,MACJ,IAAK,MAEDjkB,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,MAAQgB,GAAkBjD,GAAMkD,eAAe,EAAE,GAAGC,eACxG,MACJ,IAAK,OAEDjkB,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASgB,GAAkBjD,GAAMkD,eAAe,EAAE,GAAGC,eACzG,MACJ,IAAK,OAEDjkB,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASgB,GAAkBjD,GAAMkD,eAAe,EAAE,GAAGC,eACzG,MACJ,IAAK,OAEDjkB,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASgB,GAAkBjD,GAAMkD,eAAe,EAAE,GAAGC,eACzG,MACJ,IAAK,OAEDjkB,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASgB,GAAkBjD,GAAMkD,eAAe,EAAE,GAAGC,eACzG,MACJ,IAAK,KAEDjkB,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,KAAOE,GAAiBA,EAAMvtB,MAAQ,IAC1F,MACJ,IAAK,KAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,KAAOE,GAAiBA,EAAMttB,OAAS,IAC3F,MACJ,IAAK,IAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,IAAMgB,GAAkB,IAC5E,MACJ,IAAK,IAED/jB,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,IAAME,GAAiBA,EAAMttB,SACjF,MACJ,IAAK,IAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,IAAME,GAAiBA,EAAMvtB,QACjF,MACJ,IAAK,IAEDsK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,IAAMgB,GAAkB,IAC5E,MACJ,IAAK,KAED/jB,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,KAAOE,GAAiB3rB,KAAKC,IAAI0rB,EAAMvtB,MAAOutB,EAAMttB,UACxG,MACJ,IAAK,OAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASE,GAAiB3rB,KAAKC,IAAI0rB,EAAMvtB,MAAOutB,EAAMttB,QAAU,IACpH,MACJ,IAAK,OAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASE,GAAiB3rB,KAAKC,IAAI0rB,EAAMvtB,MAAOutB,EAAMttB,QAAU,IACpH,MACJ,IAAK,OAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASE,GAAiB3rB,KAAKC,IAAI0rB,EAAMvtB,MAAOutB,EAAMttB,QAAU,IACpH,MACJ,IAAK,OAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASE,GAAiB3rB,KAAKC,IAAI0rB,EAAMvtB,MAAOutB,EAAMttB,QAAU,IACpH,MACJ,IAAK,OAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,OAASE,GAAiB3rB,KAAKC,IAAI0rB,EAAMvtB,MAAOutB,EAAMttB,QAAU,IACpH,MACJ,IAAK,QAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,QAAUE,GAAiB3rB,KAAKC,IAAI0rB,EAAMvtB,MAAOutB,EAAMttB,QAAU,KACrH,MACJ,IAAK,QAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,QAAUE,GAAiB3rB,KAAKC,IAAI0rB,EAAMvtB,MAAOutB,EAAMttB,QAAU,KACrH,MACJ,IAAK,KAEDqK,EAAM9O,KAAK4yB,qBAAqB,IAAIf,GAAgB,KAAOE,GAAiB3rB,KAAKI,IAAIurB,EAAMvtB,MAAOutB,EAAMttB,UACxG,MACJ,QACI,MAAMypB,EAAQluB,KAAKgyB,UAAU3R,IAAI6R,GAAWA,EAAQvxB,MAAM0c,KAAK,KAC/DxM,QAAQC,IAAI,2BAA2BnQ,6CAAgDutB,MAInG,YAAgB/oB,IAAR2J,EAAqBA,EAAIA,IAAMkkB,OAAOC,IAG1C,kBAAkBf,GACtBlyB,KAAKiyB,WAAW1nB,KAAKvK,KAAK4yB,qBAAqBV,IAG3C,qBAAqBA,GACzB,MAAO,CAAEvxB,KAAMuxB,EAAQvxB,KAAMmO,IAAMojB,EAAQgB,SAASlzB,QC1jBrD,MAAM,GAKT,YAAYoS,EAAe+gB,EAAiBC,GACxCpzB,KAAKoS,OAASA,EACdpS,KAAKmzB,QAAUA,EACfnzB,KAAKozB,QAAUA,EAGZ,uBAAuBrsB,EAAcssB,EAAcF,EAAiBC,GACvE,MAAME,EAAUD,EAAMrC,YAChBuC,EAAS,GAAQC,aAAaF,EAASH,EAASC,GAChDpvB,EAAI+C,EAAM/C,EAAIuvB,EAASntB,KAAKyqB,IAAIyC,GAChCrvB,EAAI8C,EAAM9C,EAAIsvB,EAASntB,KAAKmrB,IAAI+B,GAChClhB,EAAS,IAAIrO,EAAMC,EAAGC,GAC5B,OAAO,IAAI,GAAQmO,EAAQ+gB,EAASC,GAGjC,aAAaC,GAEhB,MAAMC,EAAUD,EAAMrC,YAChBuC,EAASvzB,KAAKyzB,YAAYJ,GAC1BrvB,EAAIhE,KAAKoS,OAAOpO,EAAIuvB,EAASntB,KAAKyqB,IAAIyC,GACtCrvB,EAAIjE,KAAKoS,OAAOnO,EAAIsvB,EAASntB,KAAKmrB,IAAI+B,GAC5C,OAAO,IAAIvvB,EAAMC,EAAGC,GAGjB,YAAYovB,GACf,MAAMC,EAAUD,EAAMrC,YACtB,OAAO,GAAQwC,aAAaF,EAAStzB,KAAKmzB,QAASnzB,KAAKozB,SAGrD,QACH,OAAO,IAAI,GAAQpzB,KAAKoS,OAAOiR,QAASrjB,KAAKmzB,QAASnzB,KAAKozB,SAGvD,oBAAoBE,EAAiBH,EAAiBC,GAE1D,MAAMvN,EAAIsN,EAAU/sB,KAAKmrB,IAAI+B,GACvBI,EAAIN,EAAUhtB,KAAKyqB,IAAIyC,GAE7B,OADWH,EAAUC,EACThtB,KAAKgrB,KAAMsC,EAAIA,EAAM7N,EAAIA,ICxC7C,MAAe,GAAf,cACc,KAAA8N,QAAiB,IAAI5vB,EAAM,EAAG,GAC9B,KAAA6vB,SAAkB,IAAI7vB,EAAM,EAAG,GAElC,UAAUK,GACbpE,KAAK2zB,QAAUvvB,EAGZ,MAAMyvB,GACT7zB,KAAK4zB,SAAWC,EAOV,aAAa9sB,EAAmBqpB,GACtC,OAAOrpB,EAAM+sB,eAAe1D,GAAO2D,MAAM/zB,KAAK4zB,UAAUI,UAAUh0B,KAAK2zB,UAI/E,MAAM,WAAqB,GAChB,YAAYM,EAAoBC,GACnC,OAAO,IAAInwB,EAAM,EAAG,GAGjB,UAAUkwB,EAAoBC,GACjC,MAAO,KAGJ,QACH,OAAO,IAAI,IAInB,MAAMC,WAAe,GACjB,YAAmBptB,GACfqtB,QADe,KAAArtB,QAIZ,YAAYqpB,EAAmB8D,GAClC,OAAOl0B,KAAKq0B,aAAar0B,KAAK+G,MAAOqpB,GAGlC,UAAUA,EAAmB8D,GAChC,MAAMntB,EAAQ/G,KAAKq0B,aAAar0B,KAAK+G,MAAOqpB,GAC5C,MAAO,MAAMrpB,EAAM/C,KAAK+C,EAAM9C,IAG3B,QACH,OAAO,IAAIkwB,GAAOn0B,KAAK+G,QAI/B,MAAMutB,WAAeH,GACV,YAAY/D,EAAmB8D,GAClC,OAAOl0B,KAAKq0B,aAAar0B,KAAK+G,MAAOqpB,GAGlC,UAAUA,EAAmB8D,GAChC,MAAMntB,EAAQ/G,KAAKq0B,aAAar0B,KAAK+G,MAAOqpB,GAC5C,MAAO,MAAMrpB,EAAM/C,KAAK+C,EAAM9C,IAG3B,QACH,OAAO,IAAIqwB,GAAOt0B,KAAK+G,QAI/B,MAAM,WAAc,GAChB,YAAmBwtB,EAA2BC,EAA2BrB,EAAwBC,GAC7FgB,QADe,KAAAG,aAA2B,KAAAC,aAA2B,KAAArB,UAAwB,KAAAC,UAI1F,YAAYhD,EAAmBlsB,EAAmBuwB,GACrD,MAAMD,EAAax0B,KAAK00B,eAAetE,EAAOpwB,KAAKw0B,YAAY,GAC/D,IAAID,EAAaE,GAAsBz0B,KAAK00B,eAAetE,EAAOpwB,KAAKu0B,YAAY,GACnF,MAAMpB,EAAU/C,EAAMvX,SAAS7Y,KAAKmzB,SAAWnzB,KAAK4zB,SAAS5vB,EACvDovB,EAAUhD,EAAMvX,SAAS7Y,KAAKozB,SAAWpzB,KAAK4zB,SAAS3vB,EAE7D,OADgB,GAAQ0wB,gBAAgBzwB,EAAYswB,EAAYrB,EAASC,GAC1DwB,aAAaJ,EAAWK,IAAIN,IAGxC,UAAUnE,EAAmBlsB,GAChC,IAAIqwB,EAAav0B,KAAK00B,eAAetE,EAAOpwB,KAAKu0B,YAAY,GAC7D,MAAMO,EAAY90B,KAAK+0B,WAAW3E,GAC5B+C,EAAU/C,EAAMvX,SAAS7Y,KAAKmzB,SAAWnzB,KAAK4zB,SAAS5vB,EACvDovB,EAAUhD,EAAMvX,SAAS7Y,KAAKozB,SAAWpzB,KAAK4zB,SAAS3vB,EACvDE,EAAWnE,KAAKg1B,YAAY5E,EAAOlsB,GACzC,GAAIlE,KAAKi1B,cAAc7E,GAAQ,CAC3B,MAAM8E,EAAWl1B,KAAKg1B,YAAY5E,EAAOlsB,EAAY0rB,GAAMkD,eAAe,KAG1E,MAAO,GAFe9yB,KAAKm1B,mBAAmBD,EAAU9uB,KAAK0F,GAAIqnB,EAASC,GAAS,KAC5DpzB,KAAKm1B,mBAAmBhxB,EAAUiC,KAAK0F,GAAIqnB,EAASC,GAAS,KAGpF,OAAOpzB,KAAKm1B,mBAAmBhxB,EAAUowB,EAAWvD,YAAamC,EAASC,EAAS0B,GAIpF,QACH,OAAO,IAAI,GAAM90B,KAAKu0B,WAAYv0B,KAAKw0B,WAAYx0B,KAAKmzB,QAASnzB,KAAKozB,SAGlE,mBAAmBjvB,EAAiBowB,EAAoBpB,EAAiBC,EAAiB0B,GAG9F,MAAO,MAAM3B,KAAWC,OAFNmB,EAAanuB,KAAK0F,GAAM,IAAM,OAClC,EAAc,IAAM,OACwB3H,EAASH,KAAKG,EAASF,IAG7E,eAAemsB,EAAmBgF,EAAkBC,GACxD,MAAMvmB,EAAMshB,EAAMvX,SAASuc,GACrB/B,EAAQzD,GAAM4C,aAAa1jB,GAEjC,OADAukB,EAAMhmB,MAAMgoB,GACLhC,EAGH,WAAWjD,GAEf,OADYA,EAAMvX,SAAS7Y,KAAKu0B,YACnB,EAGT,cAAcnE,GAClB,MAAMthB,EAAMshB,EAAMvX,SAAS7Y,KAAKu0B,YAChC,OAAkD,IAA3C3E,GAAM4C,aAAa1jB,GAAKwmB,gBAIvC,MAAMC,WAAsB,GACxB,YAAmBpxB,EAA6BqxB,EAA6BC,GACzErB,QADe,KAAAjwB,WAA6B,KAAAqxB,WAA6B,KAAAC,WAItE,YAAYrF,EAAmB8D,GAClC,OAAOl0B,KAAKq0B,aAAar0B,KAAKmE,SAAUisB,GAGrC,UAAUA,EAAmB8D,GAChC,MAAM/vB,EAAWnE,KAAKq0B,aAAar0B,KAAKmE,SAAUisB,GAC5CoF,EAAWx1B,KAAKq0B,aAAar0B,KAAKw1B,SAAUpF,GAC5CqF,EAAWz1B,KAAKq0B,aAAar0B,KAAKy1B,SAAUrF,GAClD,MAAO,MAAMoF,EAASxxB,KAAKwxB,EAASvxB,MAAMwxB,EAASzxB,KAAKyxB,EAASxxB,MAAME,EAASH,KAAKG,EAASF,IAG3F,QACH,OAAO,IAAIsxB,GAAcv1B,KAAKmE,SAAUnE,KAAKw1B,SAAUx1B,KAAKy1B,WAIpE,MAAM,WAAqB,GACvB,YAAmBtxB,EAA6BuxB,GAC5CtB,QADe,KAAAjwB,WAA6B,KAAAuxB,UAIzC,YAAYtF,EAAmB8D,GAClC,OAAOl0B,KAAKq0B,aAAar0B,KAAKmE,SAAUisB,GAGrC,UAAUA,EAAmBlsB,GAChC,MAAMC,EAAWnE,KAAKq0B,aAAar0B,KAAKmE,SAAUisB,GAC5CsF,EAAU11B,KAAKq0B,aAAar0B,KAAK01B,QAAStF,GAE1CuF,EAASzxB,EAAW8vB,UAAUjwB,EAAM6xB,WAAWF,EAASxxB,GAAY6vB,MADzD,EAAI,IAEf8B,EAAS1xB,EAAS6vB,UAAUjwB,EAAM6xB,WAAWF,EAASvxB,GAAU4vB,MAFrD,EAAI,IAGrB,MAAO,MAAM4B,EAAO3xB,KAAK2xB,EAAO1xB,MAAM4xB,EAAO7xB,KAAK6xB,EAAO5xB,MAAME,EAASH,KAAKG,EAASF,IAGnF,QACH,OAAO,IAAI,GAAajE,KAAKmE,SAAUnE,KAAK01B,UAI7C,MAAM,GAQT,YAAYtF,EAAmB0F,GAAoB,EAAMC,GAAmB,GAHpE,KAAAC,SAA0B,GAC1B,KAAAC,WAA4B9wB,EAGhCnF,KAAKi0B,OAAS7D,EACdpwB,KAAK81B,SAAWA,EAChB91B,KAAK+1B,QAAUA,EAGZ,UAAU3xB,GACbpE,KAAKg2B,SAAS3rB,QAAQ6rB,IAClBA,EAAQlC,UAAU5vB,KAInB,MAAMyvB,GACT7zB,KAAKg2B,SAAS3rB,QAAQ6rB,IAClBA,EAAQnC,MAAMF,KAIf,OAAO9sB,GACV/G,KAAKg2B,SAASzrB,KAAK,IAAI4pB,GAAOptB,IAG3B,OAAOA,GACV/G,KAAKg2B,SAASzrB,KAAK,IAAI+pB,GAAOvtB,IAG3B,MAAMwtB,EAAoBC,EAAoBrB,EAAiBC,GAClEpzB,KAAKg2B,SAASzrB,KAAK,IAAI,GAAMgqB,EAAYC,EAAYrB,EAASC,IAG3D,aAAajvB,EAAsBuxB,GACtC11B,KAAKg2B,SAASzrB,KAAK,IAAI,GAAapG,EAAUuxB,IAG3C,cAAc3uB,EAAmByuB,EAAsBC,GAC1Dz1B,KAAKg2B,SAASzrB,KAAK,IAAIgrB,GAAcxuB,EAAOyuB,EAAUC,IAGnD,QACHz1B,KAAKg2B,SAASzrB,KAAK,IAAI,IAGpB,YACH,QAAmBpF,IAAfnF,KAAKi2B,MAAqB,CAC1Bj2B,KAAKi2B,MAAQ,GACbj2B,KAAKi0B,OAAOf,WACZ,IAAIiD,EAAsB,IAAIpyB,EAAM,EAAG,GACvC/D,KAAKg2B,SAAS3rB,QAAQ6rB,IAClBl2B,KAAKi2B,OAASC,EAAQE,UAAUp2B,KAAKi0B,OAAQkC,GAC7CA,EAAeD,EAAQlB,YAAYh1B,KAAKi0B,OAAQkC,KAEpDn2B,KAAKi2B,MAAQj2B,KAAKi2B,MAAMI,OAAO,GAEnC,OAAOr2B,KAAKi2B,MAGT,QACH,MAAM5S,EAAQ,IAAI,GAAUrjB,KAAKi0B,QAEjC,OADA5Q,EAAM2S,SAAWh2B,KAAKg2B,SAAS3V,IAAI6V,GAAWA,EAAQ7S,SAC/CA,GC9OR,MAAM,GAST,cARO,KAAA7e,MAAgB,EAChB,KAAAC,OAAiB,EACjB,KAAAsgB,eAAgC5f,EAChC,KAAAukB,eAAgCvkB,EAMnCnF,KAAKowB,MAAQ,IAAI,GAAWpwB,MAC5BA,KAAKs2B,MAAQ,GACbt2B,KAAKs2B,MAAM/rB,KAAK,IAAI,GAAUvK,KAAKowB,QAGhC,UAAUhsB,GACbpE,KAAKs2B,MAAMjsB,QAAQ6rB,IACfA,EAAQlC,UAAU5vB,KAInB,MAAMyvB,GACT7zB,KAAKs2B,MAAMjsB,QAAQ6rB,IACfA,EAAQnC,MAAMF,KAIf,eAAe9sB,GAClB/G,KAAKs2B,MAAMt2B,KAAKs2B,MAAMhrB,OAAS,GAAGirB,OAAOxvB,GAGtC,eAAeA,GAClB/G,KAAKs2B,MAAMt2B,KAAKs2B,MAAMhrB,OAAS,GAAGkrB,OAAOzvB,GAGtC,cAAcwtB,EAAoBC,EAAoBrB,EAAiBC,GAC1EpzB,KAAKs2B,MAAMt2B,KAAKs2B,MAAMhrB,OAAS,GAAGmrB,MAAMlC,EAAYC,EAAYrB,EAASC,GAGtE,qBAAqBjvB,EAAsBuxB,GAC9C11B,KAAKs2B,MAAMt2B,KAAKs2B,MAAMhrB,OAAS,GAAGorB,aAAavyB,EAAUuxB,GAGtD,sBAAsB3uB,EAAmByuB,EAAsBC,GAClEz1B,KAAKs2B,MAAMt2B,KAAKs2B,MAAMhrB,OAAS,GAAGqrB,cAAc5vB,EAAOyuB,EAAUC,GAG9D,kBACHz1B,KAAKs2B,MAAMt2B,KAAKs2B,MAAMhrB,OAAS,GAAGsrB,QAG/B,QAAQd,EAAmBC,GAC9B/1B,KAAKs2B,MAAM/rB,KAAK,IAAI,GAAUvK,KAAKowB,MAAO0F,EAAUC,IAGjD,cAAcrtB,GACjB,MAAMmuB,EAAWnuB,EAAOlE,MAAQxE,KAAKwE,MAC/BsyB,EAAWpuB,EAAOjE,OAASzE,KAAKyE,OACtCzE,KAAK+zB,MAAM,IAAIhwB,EAAM8yB,EAAUC,IAC/B92B,KAAKg0B,UAAUtrB,EAAOquB,SAGnB,QACH,MAAM1T,EAAQ,IAAI,GAOlB,OANAA,EAAM7e,MAAQxE,KAAKwE,MACnB6e,EAAM5e,OAASzE,KAAKyE,OACpB4e,EAAM+M,MAAQpwB,KAAKowB,MACnB/M,EAAMqG,UAAY1pB,KAAK0pB,UACvBrG,EAAM0B,UAAY/kB,KAAK+kB,UACvB1B,EAAMiT,MAAQt2B,KAAKs2B,MAAMjW,IAAKyE,GAASA,EAAKzB,SACrCA,GCzER,MAAM,GAIT,YAAYrf,EAAWC,GACnBjE,KAAKgE,EAAIA,EACThE,KAAKiE,EAAIA,EAGN,iBAAiB8C,GACpB,OAAO,IAAI,GAAWA,EAAM/C,EAAEoQ,WAAYrN,EAAM9C,EAAEmQ,YAG/C,eAAegc,GAClB,MAAMpsB,EAAIosB,EAAMvX,SAAS7Y,KAAKgE,GACxBC,EAAImsB,EAAMvX,SAAS7Y,KAAKiE,GAC9B,OAAO,IAAIF,EAAMC,EAAGC,ICFrB,MAAM,GAGT,YAAYiiB,GACRlmB,KAAKomB,SAAWF,EAGb,iBAAiB0D,GACpB,MAAMmE,EAAcnE,EAAMlhB,OAC1B,QAAoBvD,IAAhB4oB,EAA2B,CAC3B/tB,KAAKg3B,wBAAwBpN,EAAM5d,MAAO+hB,GAC1C,MAAMhC,EAAa/rB,KAAKg3B,wBAAwBpN,EAAMoC,SAAShgB,MAAO4d,EAAMoC,SAAStjB,QAUrF,YATqBvD,IAAjBykB,EAAMyE,QACNruB,KAAKi3B,cAAcrN,EAAMyE,aAEOlpB,IAAhCykB,EAAMoC,SAASwD,cACfxvB,KAAKk3B,YAAYtN,EAAMoC,SAASwD,mBAEHrqB,IAA7BykB,EAAMoC,SAASnC,WACf7pB,KAAKk3B,YAAYtN,EAAMoC,SAASnC,WAE7BD,EAAMiD,WACT,KAAKvpB,EAAUwpB,IACX9sB,KAAKm3B,gBAAgBvN,EAAME,MAAmBiC,GAC9C,MACJ,KAAKzoB,EAAUorB,KACX1uB,KAAKo3B,iBAAiBxN,EAAME,MAAoBiC,GAChD,MACJ,KAAKzoB,EAAUkrB,KACXxuB,KAAKq3B,iBAAiBzN,EAAME,MAAoBiC,GAChD,MACJ,KAAKzoB,EAAUurB,IACX7uB,KAAKs3B,gBAAgB1N,EAAME,MAAmBiC,KAMtD,wBAAwB/f,EAAmBtD,GAC/C,IAAI3C,EAAU,EACd,MAAM/B,EAAI0E,EAAOhE,KACXT,EAAIyE,EAAO/D,IACXkE,EAAOH,EAAO9D,MACd2yB,EAAO7uB,EAAO7D,OACd6kB,EAAY1d,EAAM0d,UACxB,QAAkBvkB,IAAdukB,EAAyB,CACzB,MAAM/E,EAAY3Y,EAAM2d,cACxB3pB,KAAKomB,SAASa,UAAUjjB,EAAGC,EAAG4E,EAAM5E,EAAGylB,EAAW/E,EAAW3hB,EAASkkB,OACtElnB,KAAKomB,SAASa,UAAUpe,EAAM5E,EAAG4E,EAAM0uB,EAAM7N,EAAW/E,EAAW3hB,EAASkkB,OAC5ElnB,KAAKomB,SAASa,UAAUjjB,EAAGuzB,EAAM1uB,EAAM0uB,EAAM7N,EAAW/E,EAAW3hB,EAASkkB,OAC5ElnB,KAAKomB,SAASa,UAAUjjB,EAAGC,EAAGD,EAAGuzB,EAAM7N,EAAW/E,EAAW3hB,EAASkkB,OACtEnhB,EAAU4e,EAEd,MAAMqC,EAAUhb,EAAM+Y,UACtB,QAAgB5f,IAAZ6hB,EAAuB,CACvB,MAAMwQ,EAAOvzB,EAAKyE,EAAOjE,OAAS,EAClCzE,KAAKomB,SAASa,UAAUjjB,EAAGwzB,EAAM3uB,EAAM2uB,EAAMxQ,EAASte,EAAOjE,OAAQzB,EAASkkB,OAElF,OAAOxe,EAAO+e,gBAAgB1hB,GAG1B,cAAcsoB,GAClBruB,KAAKg3B,wBAAwB3I,EAAOriB,MAAOqiB,EAAO3lB,QAClD,MAAMulB,EAASI,EAAOoJ,YAChBC,EAAarJ,EAAOqJ,WAC1BrJ,EAAO3M,WAAWrX,QAAQ,CAACsX,EAAM3W,KAC7B,MAAM2sB,EAAUhW,EAAK3d,EAAI0zB,EAAarJ,EAAOuJ,cACvCC,EAAUlW,EAAK1d,EAAI,EACzBjE,KAAKomB,SAASa,UAAU0Q,EAASE,EAASF,EAAUD,EAAYG,EAAS5J,EAAOjjB,GAAQ0sB,EAAY10B,EAASkkB,OAC7GlnB,KAAKomB,SAASgD,UAAUzH,EAAK3d,EAAG2d,EAAK1d,EAAG0d,EAAKnd,MAAOmd,EAAK5B,UAAW4B,EAAK5V,KAAM4V,EAAK3H,MAAO2H,EAAKxP,cAAgBwP,EAAKrV,WAAYqV,EAAKpV,UAAU,GAAO,KAIvJ,YAAYkjB,GAMhB,QAL6BtqB,IAAzBsqB,EAAK9E,iBACL8E,EAAK9E,gBAAgBtgB,QAAQsX,IACzB3hB,KAAKomB,SAASgD,UAAUzH,EAAK3d,EAAG2d,EAAK1d,EAAG0d,EAAKnd,MAAOmd,EAAK5B,UAAW4B,EAAK5V,KAAM4V,EAAK3H,MAAO2H,EAAKxP,cAAgBwP,EAAKrV,WAAYqV,EAAKpV,UAAU,GAAO,UAGlIpH,IAAzBsqB,EAAK7E,sBAA0DzlB,IAAzBsqB,EAAKzjB,MAAM0d,UAAyB,CAC1E,MAAMA,EAAY+F,EAAKzjB,MAAM0d,UACvB/E,EAAY8K,EAAKzjB,MAAM2d,cAC7B8F,EAAK7E,gBAAgBvgB,QAAQsX,IACzB3hB,KAAKomB,SAASa,UAAUtF,EAAK4C,GAAI5C,EAAK6C,GAAI7C,EAAK8C,GAAI9C,EAAK+C,GAAIgF,EAAW/E,EAAW3hB,EAASkkB,UAK/F,iBAAiBqH,EAAsB7lB,GAC3C,MAAMovB,EAASvJ,EAAUwJ,YACnBC,EAAatvB,EAAOlE,MAAQszB,EAAOG,UACnCC,EAAQxvB,EAAO1E,EACfm0B,EAAOzvB,EAAOzE,EACdm0B,EAAUD,EAAOzvB,EAAOjE,OACxB4zB,EAAQ9J,EAAUrE,gBAExB,IAAI,IAAIoO,EAAcR,EAAOG,UAAY,EAAGK,GAAe,EAAGA,IAAe,CACzE,MAAMvG,EAAQ,IAAI,GAClBA,EAAMwG,eAAe,GAAWC,UAAU9vB,EAAO+vB,aACjD,MAAMzsB,EAAQuiB,EAAUxE,OAAOuO,GAAatsB,MAC5C,IAAI,IAAI0sB,EAAW,EAAGA,EAAWZ,EAAOa,eACZxzB,IAApB6G,EAAM+Y,WAA+C,WAApB/Y,EAAM+Y,WADE2T,IAAY,CAIzD,MACM10B,EAAIk0B,EAAQQ,EAAWV,EACvB/zB,EAAIm0B,GAAWA,EAAUD,GAFnBn4B,KAAK44B,gBAAgBrK,EAAU1V,SAAS6f,EAAUJ,GAAcD,GAG5EtG,EAAM8G,eAAe,IAAI,GAAW70B,EAAEoQ,WAAYnQ,EAAEmQ,aAExD2d,EAAM8G,eAAe,GAAWL,UAAU9vB,EAAOowB,cACjD/G,EAAM8G,eAAe,GAAWL,UAAU9vB,EAAO+vB,aACjD,MAAM3T,EAAOiN,EAAMuE,MAAM,GAAGF,YAC5Bp2B,KAAKomB,SAAS2S,aAAajU,EAAM9Y,EAAM+Y,UAAW/Y,EAAM0d,UAAW1d,EAAM2d,cAAe3mB,EAASkkB,QAIjG,iBAAiBuH,EAAsB/lB,GAC3C,MAAMovB,EAASrJ,EAAUsJ,YACnBC,EAAatvB,EAAOlE,MAAQszB,EAAOG,UACnCC,EAAQxvB,EAAO1E,EACfm0B,EAAOzvB,EAAOzE,EACdm0B,EAAUD,EAAOzvB,EAAOjE,OACxB4zB,EAAQ5J,EAAUvE,gBACxB,IAAI,IAAIoO,EAAc,EAAGA,EAAcR,EAAOG,UAAWK,IAAe,CACpE,IAAIU,EAAch5B,KAAK44B,gBAAgBnK,EAAU5V,SAAS,EAAGyf,GAAcD,GAC3E,IAAI,IAAIK,EAAW,EAAGA,EAAWZ,EAAOa,QAASD,IAAY,CACzD,MAAM1sB,EAAQyiB,EAAUwK,eAAeX,EAAaI,GAC9C5pB,EAAM9O,KAAK44B,gBAAgBnK,EAAU5V,SAAS6f,EAAUJ,GAAcD,GACtE9T,EAAK2T,GAASQ,EAAW,GAAKV,EAC9BxT,EAAK4T,GAAWA,EAAUD,GAAQa,EAClCvU,EAAKyT,EAAQQ,EAAWV,EACxBtT,EAAK0T,GAAWA,EAAUD,GAAQrpB,EACxC9O,KAAKomB,SAASa,UAAU1C,EAAIC,EAAIC,EAAIC,EAAI1Y,EAAM0d,WAAa,SAAU1d,EAAM2d,cAAe3mB,EAASkkB,OACnG8R,EAAclqB,IAKlB,gBAAgB6f,EAAoBjmB,GACxC,MAAMovB,EAASnJ,EAASoJ,YAClBmB,EAAgBxwB,EAAOlE,QAAUszB,EAAOa,QAAU,IAAMb,EAAOG,UAAY,IAC3ED,EAAatvB,EAAOlE,OAASszB,EAAOG,UAAY,GAChDC,EAAQxvB,EAAO1E,EAAIk1B,EACnBf,EAAOzvB,EAAOzE,EACdm0B,EAAUD,EAAOzvB,EAAOjE,OACxB4zB,EAAQ1J,EAASzE,gBACvB,IAAI,IAAIoO,EAAc,EAAGA,EAAcR,EAAOG,UAAWK,IACrD,IAAI,IAAII,EAAW,EAAGA,EAAWZ,EAAOa,QAASD,IAAY,CACzD,MAAM1e,EAAQ2U,EAASsK,eAAeX,EAAaI,GAAU3T,WAAa,SAEpE/gB,EAAIk0B,EAAQQ,EAAWV,EAAaM,EAAcY,EAClDj1B,EAAIm0B,GAAWA,EAAUD,GAFnBn4B,KAAK44B,gBAAgBjK,EAAS9V,SAAS6f,EAAUJ,GAAcD,GAG3Er4B,KAAKomB,SAASa,UAAUjjB,EAAGo0B,EAASp0B,EAAGC,EAAG+V,EAAOkf,EAAel2B,EAASkkB,QAK7E,gBAAgB0H,EAAoBlmB,GACxC,MAAMovB,EAASlJ,EAASmJ,YAClBoB,EAAS,IAAIp1B,EAAM2E,EAAO1E,EAAI0E,EAAOlE,MAAQ,EAAGkE,EAAOzE,EAAIyE,EAAOjE,OAAS,GAE3E4zB,EAAQ,CAAEhyB,IAAK,EAAGG,IAAKooB,EAASwK,YADlB,IAEd7F,EAAS7qB,EAAOjE,OAAS,EACzB40B,EAAS,IAAI,GAAQF,EAAQ5F,EAAQA,GAE3C,IAAI+F,EAAgB1J,GAAM4C,aAAa5D,EAAS4F,YAAY+E,SAAS3J,GAAMkD,eAAe,MAC1F,IAAI,IAAI4F,EAAW,EAAGA,EAAWZ,EAAOa,QAASD,IAAY,CACzD,MAAM1e,EAAQ4U,EAASqK,eAPP,EAOmCP,GAAU3T,WAAa,SACpEjW,EAAM8gB,GAAMkD,eAAe9yB,KAAK44B,gBAAgBhK,EAAS/V,SAAS6f,EARxD,GAQgFL,IAC1FvT,EAAO,IAAI,GACjBA,EAAKyT,eAAe,GAAWC,UAAUW,IACzCrU,EAAK+T,eAAe,GAAWL,UAAUa,EAAOzE,aAAa0E,KAC7DxU,EAAK0U,cAAe1qB,EAAIikB,aAAc3e,WAAaklB,EAAcvG,aAAc3e,WAAYmf,EAAOnf,WAAYmf,EAAOnf,YACrH0Q,EAAK+T,eAAe,GAAWL,UAAUW,IACzCn5B,KAAKomB,SAAS2S,aAAajU,EAAKwR,MAAM,GAAGF,YAAapc,OAAO7U,OAAWA,EAAWnC,EAASkkB,OAC5FoS,EAAgBA,EAAczE,IAAI/lB,IAIlC,gBAAgBA,EAAiBupB,GACrC,OAAQvpB,EAAI2qB,QAAWpB,EAAMhyB,MAAQgyB,EAAM7xB,IAAM6xB,EAAMhyB,MCjMxD,MAAM,GAIT,YAAY6f,GACRlmB,KAAKomB,SAAWF,EAChBlmB,KAAK05B,eAAiB,IAAI,GAAc15B,KAAKomB,UAG1C,cAAcuT,GACjB,MAAMC,EAAUD,EAAQC,QACxB,QAAgBz0B,IAAZy0B,QAA4Cz0B,IAAnBy0B,EAAQlxB,OAAsB,CACvD,MAAMmxB,EAAYD,EAAQlxB,OAC1B1I,KAAKomB,SAAS0T,aAAaD,EAAU71B,EAAG61B,EAAU51B,EAAG41B,EAAUr1B,MAAOq1B,EAAUp1B,OAAQm1B,GAE5F,MAAM9P,EAAQ6P,EAAQ7P,WACR3kB,IAAV2kB,GACAA,EAAMiF,eAAe3J,KAAK,KACtBplB,KAAK05B,eAAeK,iBAAiBjQ,KAG7C,MAAMiI,EAAQ4H,EAAQ5H,WACR5sB,IAAV4sB,GACAA,EAAMuE,MAAMjsB,QAAQya,IAChB,MAAMQ,EAAIR,EAAKsR,YACTrR,EAAaD,EAAa,SAAIiN,EAAMhN,eAAY5f,EAChDukB,EAAa5E,EAAY,QAAIiN,EAAMrI,eAAYvkB,EACrDnF,KAAKomB,SAAS2S,aAAazT,EAAGP,EAAW2E,EAAW,EAAG1mB,EAASkkB,W9BvBhF,SAAY3jB,GACR,mBACA,uBACA,yBACA,qBACA,mCALJ,CAAYA,MAAQ,KAQb,MAAM,GAST,YAAYmF,EAAqBsxB,GAC7Bh6B,KAAK0I,OAASA,EACd1I,KAAKg6B,SAAWA,EAGb,eACH,OAAOh6B,KAAK0I,OAAOd,MAGhB,YACH,OAAO5H,KAAK0I,OAAOb,MAGhB,cAAcM,GACjB,MAAMO,EAAS1I,KAAK0I,OAAOuxB,OAAO9xB,GAC5BQ,EAAa3I,KAAK0I,OAAOT,SAAW5F,EAAgB63B,cACrC/0B,IAAjBnF,KAAK45B,UACL55B,KAAK45B,QAAQlxB,OAASA,EACtB1I,KAAK45B,QAAQ5W,cAAc7a,SAEZhD,IAAfnF,KAAK8pB,QACL9pB,KAAK8pB,MAAMphB,OAASA,EACpB1I,KAAK8pB,MAAM9G,cAAc7a,SAEVhD,IAAfnF,KAAK+xB,OACL/xB,KAAK+xB,MAAM/O,cAActa,GAE7B1I,KAAKqhB,SAAW,EAChBrhB,KAAKm6B,aAAahyB,EAAMO,EAAQC,GAG5B,aAAaR,EAAmBO,EAAaC,GACjD,MAAM0b,EAAM3b,EAAO2a,QACfrjB,KAAKg6B,WAAaz2B,EAAS62B,eAC3B/V,EAAI7f,MAAQ2D,EAAK+X,YAErB/X,EAAKqC,YAAY6Z,EAAK1b,I+BzDvB,MAAM0xB,GAGT,YAAYnU,GACRlmB,KAAKomB,SAAWF,EAGb,cAAcvI,GACJA,EAAI2c,SAASC,QACrBlwB,QAAQmwB,IACTA,EAAIC,OAAOz6B,KAAKomB,aCTrB,MAAMsU,GAMT,YAAYJ,GAFJ,KAAAK,WAA0Bx1B,EAG9BnF,KAAKs6B,SAAWA,EAGb,eAIH,YAHmBn1B,IAAfnF,KAAK26B,QACL36B,KAAK26B,MAAQ36B,KAAKs6B,SAASC,QAAQK,WAEhC56B,KAAK26B,MAAOn2B,MAGhB,YAIH,YAHmBW,IAAfnF,KAAK26B,QACL36B,KAAK26B,MAAQ36B,KAAKs6B,SAASC,QAAQK,WAEhC56B,KAAK26B,MAAOl2B,OAGhB,cAAc0D,GACjB,MAAMuY,EAAU1gB,KAAKwgB,cAAgBrY,EAAK8B,OAC1CjK,KAAKqhB,SAAWrhB,KAAKs6B,SAASC,QAAQvX,cAAc7a,EAAMuY,ICtB3D,MAAM,GAKT,YAAYwF,GACRlmB,KAAK66B,cAAgB,IAAI,EAAa3U,GACtClmB,KAAK86B,iBAAmB,IAAI,GAAgB5U,GAC5ClmB,KAAK+6B,cAAgB,IAAIV,GAAanU,GAGnC,gBAAgBY,GACnB,IAAItG,EAAmC,OACdrb,IAArB2hB,EAAI5E,eACNliB,KAAK66B,cAAcG,cAAclU,EAAI5E,cACrC1B,EAAesG,EAAI5E,aAAab,UAElCyF,EAAI7E,KAAK5X,QAASsT,IACdA,EAAI6C,aAAeA,EACf7C,aAAe,EACf3d,KAAK66B,cAAcG,cAAcrd,GAC1BA,aAAe,GACtB3d,KAAK86B,iBAAiBG,cAActd,GAC7BA,aAAe+c,GACtB16B,KAAK+6B,cAAcG,cAAcvd,GAEjC9M,QAAQC,IAAI,8DAEhB0P,EAAe7C,EAAI0D,YC9BxB,MAAM,GAKT,YAAYmC,GACRxjB,KAAKomB,SAAW,IAAI,EAAW5C,GAC/BxjB,KAAKm7B,mBAAqB,IAAI,GAAkBn7B,KAAKomB,UACrDpmB,KAAKo7B,eAAiB,IAAI,EAAcp7B,KAAKomB,SAAUpmB,KAAKm7B,oBAGzD,eAAeE,GAClB,MAAMlzB,EAAO,EAAYmzB,YAAYD,EAAK9xB,SAc1C,YAbqBpE,IAAjBk2B,EAAK9xB,cAAoDpE,IAA3Bk2B,EAAK9xB,QAAQC,WAC3CxJ,KAAKomB,SAASmV,SAASF,EAAK9xB,QAASC,WAEzC6xB,EAAKG,WAAWnxB,QAAQoxB,IACpBA,EAAWzY,cAAc7a,KAE7BkzB,EAAKG,WAAWnxB,QAAQoxB,IAChBA,aAAsB,EACtBz7B,KAAKm7B,mBAAmBpU,gBAAgB0U,GAExCz7B,KAAKo7B,eAAeM,YAAYD,KAGjCtzB,EAAKwzB,SAAQ,GAGjB,QACH37B,KAAKomB,SAASwV,QAGX,aAAan1B,GAChBzG,KAAKomB,SAASyV,aAAap1B,ICzC5B,MAAMq1B,GAGT,YAAYttB,GACRxO,KAAKwO,IAAMA,EAGf,eACI,OAAOxO,KAAKwO,KCHb,MAAM,GAIT,YAAYutB,GAFJ,KAAAvY,QAAsC,GAG1CxjB,KAAKg8B,QAAUD,EAeZ,mBAAmBnuB,GACtB,OAAO,IAAIC,QAAiB,CAACC,EAASC,KAClC,IAAIC,EAAO,IAAIC,eACfD,EAAKE,KAAK,MAAON,GAAK,GACtBI,EAAKG,aAAe,cAEpBH,EAAKI,OAAUC,IACX,GAAoB,MAAhBL,EAAKM,OAAgB,CACrB,IAAI2tB,EAAcjuB,EAAKO,SACvB,GAAQ2tB,qBAAqBD,GACxB7W,KAAM+W,GAASruB,EAAQquB,IACvB3W,MAAO4W,GAAQruB,EAAOquB,SAE3BruB,EAAO,mBAAmBH,IAGlCI,EAAKW,QAAWC,IACZb,EAAOa,IAEXZ,EAAKa,KAAK,QAIX,oBAAoBwtB,GACvB,OAAO,IAAIxuB,QAAiB,CAACC,EAASC,KAClC,IAAK,IAASuuB,EAALl8B,EAAE,EAASk8B,EAAKD,EAAMj8B,GAAIA,IAC/B,GAAIk8B,EAAK37B,KAAK47B,SAAS,SAAU,CAC7B,IAAIC,EAAS,IAAIC,WAEjBD,EAAOpuB,OAAUsuB,IAEb,GAAQR,qBAAsBQ,EAAGC,OAAeC,QAAQxX,KAAK+W,GAAQruB,EAAQquB,IAAO3W,MAAM4W,GAAOruB,EAAOquB,KAG5GI,EAAOK,kBAAkBP,GACzB,SAMR,4BAA4BL,GAChC,OAAO,IAAIpuB,QAAiB,CAACC,EAASC,KAC9BkuB,GAAeA,EAAYa,WAAa,GACxC,IAAIC,OAAQC,UAAUf,GAAa7W,KAAM6X,IACrC,MAAMd,EAAO,IAAI,GAAQc,GACzBd,EAAKe,oBAAoB9X,KAAK,KAC1BtX,EAAQquB,KACT3W,MAAOC,IACN1X,EAAO0X,OAEZD,MAAOC,IACN1X,EAAO0X,KAGX1X,EAAO,uBAKZ,QAAQpN,GACX,OAAmC,OAA5BX,KAAKg8B,QAAQM,KAAK37B,GAGtB,cAAcA,GACjB,OAAO,IAAIkN,QAAiB,CAACC,EAASC,KAClC/N,KAAKg8B,QAAQM,KAAK37B,GAAMsuB,MAAM,QAAQ7J,KAAM+X,IACxC,MAAMC,GAAU,IAAI3uB,WAAYC,gBAAgByuB,EAAa,mBAC7DrvB,EAAQ,IAAIguB,GAAQsB,MACrB5X,MAAOC,IACN1X,EAAO0X,OAKZ,iBAAiB9kB,GACpB,OAAO,IAAIkN,QAAgB,CAACC,EAASC,KACjC/N,KAAKg8B,QAAQM,KAAK37B,GAAMsuB,MAAM,UAAU7J,KAAM5B,IAC1C1V,EAAQ0V,KACPgC,MAAOC,IACN1X,EAAO0X,OAKd,iBAAiB9kB,GACpB,OAAO,IAAIkN,QAAqB,CAACC,EAASC,KACtC/N,KAAKg8B,QAAQM,KAAK37B,GAAMsuB,MAAM,eAAe7J,KAAM5B,IAC/C1V,EAAQ0V,KACPgC,MAAOC,IACN1X,EAAO0X,OAKd,sBAAsB9jB,GACzB,OAAO3B,KAAKwjB,QAAQ7hB,GAGhB,oBACJ,OAAO,IAAIkM,QAAc,CAACC,EAASC,KAC/B/N,KAAKq9B,cAAc,uBAAuBjY,KAAKkY,IAC3CA,EAAgBnxB,SAASoxB,cAAchuB,WAAWlF,QAAQmZ,IACtD,GAAyB,aAArBA,EAAQ/T,SAAyB,CACjC,MAAM+tB,EAAW7vB,EAAIqB,aAAawU,EAAS,YACrCia,EAAc9vB,EAAIqB,aAAawU,EAAS,eAC9C,QAAiBre,IAAbq4B,QAA0Cr4B,IAAhBs4B,EAA2B,CACrD,IAAI97B,EAAM87B,EAAYC,QAAQ,kCAAmC,IACjE/7B,EAAMA,EAAI+7B,QAAQ,OAAQ,SACAv4B,IAAtBnF,KAAKwjB,QAAQ7hB,KACb3B,KAAKwjB,QAAQ7hB,GAAO,IAExB3B,KAAKwjB,QAAQ7hB,GAAK4I,KAAKizB,OAInC1vB,MACD0X,MAAMC,IACL1X,EAAO0X,QAlIL,GAAAkY,iBAAmB,kCACnB,GAAAC,wBAA0B,8CAC1B,GAAAC,yBAA2B,0CAC3B,GAAAC,yBAA2B,0CAC3B,GAAAC,wBAA0B,yCAC1B,GAAAC,sBAAwB,uCACxB,GAAAC,8BAAgC,qCAChC,GAAAC,0BAA4B,0BAC5B,GAAAC,yBAA2B,wBAC3B,GAAAC,gBAAkB,aAClB,GAAAC,eAAiB,YCnB5B,MAAM,GAKT,YAAYC,GAHJ,KAAAC,MAAkC,GAItCv+B,KAAKwO,IAAM8vB,EAAKnyB,SAChBnM,KAAKw+B,iBAAmB,IAAI,EAGzB,eACH,QAA6Br5B,IAAzBnF,KAAKu+B,MAAc,OAAiB,CACpC,MAAM7+B,EAAOiO,EAAIyB,oBAAoBpP,KAAKwO,IAAK,iBAClCrJ,IAATzF,GACAA,EAAK6P,WAAWlF,QAAQgF,IACpB,OAAOA,EAAMI,UACT,IAAK,UACD,MAAMgvB,EAAY9wB,EAAIqB,aAAaK,EAAO,UAC1C,QAAkBlK,IAAds5B,GAAyC,cAAdA,EAA2B,CACtD,MAAMzyB,EAAQ,EAAM0yB,cAAcrvB,GAC5BsvB,EAAUhxB,EAAIqB,aAAaK,EAAO,kBACxBlK,IAAZw5B,IACA3+B,KAAKu+B,MAAMI,GAAW3yB,GAG9B,MACJ,IAAK,gBACDhM,KAAKw+B,iBAAmB,EAAMI,oBAAoBvvB,GAClD,MACJ,IAAK,iBAED,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,0CAK7D,IAAK,MAAM9O,KAAQX,KAAKu+B,MACpB,GAAIv+B,KAAKu+B,MAAMt8B,eAAetB,GAAO,CACnBX,KAAKu+B,MAAM59B,GACnBiY,iBAAiB5Y,QAMvC,kBACI,OAAOA,KAAKw+B,iBAGT,cAAc79B,GACjB,OAAOX,KAAKu+B,MAAM59B,GAGf,iBACH,IAAK,MAAMA,KAAQX,KAAKu+B,MACpB,GAAIv+B,KAAKu+B,MAAMt8B,eAAetB,GAAO,CACjC,MAAMqL,EAAQhM,KAAKu+B,MAAM59B,GACzBkQ,QAAQC,IAAI,GAAGnQ,MAASqL,EAAMoI,cAC1BpI,EAAM+J,UACNlF,QAAQC,IAAI9E,EAAM+J,SAAS3B,YAE3BpI,EAAM2K,UACN9F,QAAQC,IAAI9E,EAAM2K,SAASvC,cChExC,MAAM,GAUT,YAAYyqB,EAAiBC,GACzB9+B,KAAK8+B,YAAcA,EAGvB,iBAEI,OADA9+B,KAAK++B,eACE/+B,KAAKg/B,YAGhB,gBAEI,OADAh/B,KAAK++B,eACE/+B,KAAKi/B,WAGhB,gBAEI,OADAj/B,KAAK++B,eACE/+B,KAAKk/B,WAGhB,iBAEI,OADAl/B,KAAK++B,eACE/+B,KAAKm/B,YAGhB,mBAEI,OADAn/B,KAAK++B,eACE/+B,KAAKo/B,cAGhB,kBAEI,OADAp/B,KAAK++B,eACE/+B,KAAKq/B,aAGR,oBACoBl6B,IAApBnF,KAAKi/B,YACLj/B,KAAK8+B,YAAYvvB,WAAWlF,QAAQgF,IAChC,OAAOA,EAAMI,UACT,IAAK,SACD,MAAMjL,EAAQmJ,EAAIqB,aAAaK,EAAO,YACxBlK,IAAVX,IACAxE,KAAKi/B,WAAa1zB,EAAQG,qBAAqB4E,SAAS9L,EAAO,MAEnE,MAAMC,EAASkJ,EAAIqB,aAAaK,EAAO,YACxBlK,IAAXV,IACAzE,KAAKg/B,YAAczzB,EAAQG,qBAAqB4E,SAAS7L,EAAQ,MAErE,MACJ,IAAK,UACD,MAAME,EAAMgJ,EAAIqB,aAAaK,EAAO,cACxBlK,IAARR,IACA3E,KAAKk/B,WAAa3zB,EAAQG,qBAAqB4E,SAAS3L,KAE5D,MAAMD,EAAOiJ,EAAIqB,aAAaK,EAAO,eACxBlK,IAATT,IACA1E,KAAKm/B,YAAc5zB,EAAQG,qBAAqB4E,SAAS5L,KAE7D,MAAMG,EAAS8I,EAAIqB,aAAaK,EAAO,iBACxBlK,IAAXN,IACA7E,KAAKo/B,cAAgB7zB,EAAQG,qBAAqB4E,SAASzL,KAE/D,MAAMD,EAAQ+I,EAAIqB,aAAaK,EAAO,gBACxBlK,IAAVP,IACA5E,KAAKq/B,aAAe9zB,EAAQG,qBAAqB4E,SAAS1L,KAE9D,MACJ,IAAK,kBACL,IAAK,YACL,IAAK,cACL,IAAK,aACL,IAAK,SACL,IAAK,oBACL,IAAK,oBACL,IAAK,YACL,IAAK,SAED,MACJ,QACIiM,QAAQC,IAAI,2BAA2BzB,EAAMI,wCC1F9D,MAAM,GAQT,cACIzP,KAAK0F,UAAY,IAAIugB,EACrBjmB,KAAK4F,aAAe,IAAIqgB,EACxBjmB,KAAKoF,YAAc,IAAI6gB,EACvBjmB,KAAKwF,UAAY,IAAIygB,GCZtB,MAAM,GAMT,cACI,MAAMqZ,EAAoB/zB,EAAQG,qBAAqB,KACvD1L,KAAK6F,iBAAmB,EACxB7F,KAAK2F,cAAgB,EACrB3F,KAAKsF,gBAAkBg6B,EACvBt/B,KAAKyF,cAAgB65B,GCRtB,MAAM,GAYT,oBACI,OAAOt/B,KAAKu/B,UAAU58B,EAAc+B,KAAOsH,GAAUA,EAAMwzB,gBAG/D,kBAAyBrtB,GACrBnS,KAAKw/B,eAAiBrtB,EAG1B,iBACI,OAAOnS,KAAKu/B,UAAU,EAAIvzB,GAAUA,EAAMyzB,aAG9C,eAAsBtpB,GAClBnW,KAAKy/B,YAActpB,EAGvB,cACI,OAAOnW,KAAKu/B,UAAU,IAAI,GAAmBvzB,GAAUA,EAAM0zB,UAGjE,YAAmBtY,GACfpnB,KAAK0/B,SAAWtY,EAGpB,wBACI,YAAyBjiB,IAAlBnF,KAAK0/B,SAGhB,cACI,OAAO1/B,KAAKu/B,UAAU,IAAI,GAAmBvzB,GAAUA,EAAM2zB,UAGjE,YAAmB56B,GACf/E,KAAK2/B,SAAW56B,EAGpB,kBACI,OAAO/E,KAAKu/B,UAAU,EAAIvzB,GAAUA,EAAM4zB,cAG9C,gBAAuBtY,GACnBtnB,KAAK4/B,aAAetY,EAGxB,iBACI,OAAOtnB,KAAKu/B,UAAU,EAAIvzB,GAAUA,EAAM6zB,aAG9C,eAAsBC,GAClB9/B,KAAK6/B,YAAcC,EAGvB,mBACI,OAAO9/B,KAAKu/B,UAAUn9B,EAAWgX,KAAOpN,GAAUA,EAAM+zB,UAG5D,iBAAwBC,GACpBhgC,KAAK+/B,SAAWC,EAGpB,cACI,OAAOhgC,KAAKu/B,UAAU,GAAKvzB,GAAUA,EAAMi0B,UAG/C,YAAmBjZ,GACfhnB,KAAKigC,SAAWjZ,EAGZ,UAAakZ,EAAiBC,GAClC,IAAIrxB,EAAqBqxB,EAAGngC,MAO5B,YANYmF,IAAR2J,QAA0C3J,IAArBnF,KAAKogC,cAC1BtxB,EAAMqxB,EAAGngC,KAAKogC,mBAENj7B,IAAR2J,IACAA,EAAMoxB,GAEHpxB,GCpFR,MAAM,GAMT,YAAYusB,GACRr7B,KAAKq7B,KAAOA,EACZr7B,KAAKqgC,QAAU,GACfrgC,KAAKsmB,KAAO,GACZtmB,KAAKgM,MAAQ,IAAI,GAGd,UACH,MAAM6a,EAAoB,GAI1B,OAHA7mB,KAAKsmB,KAAKjc,QAAQkc,IACdM,EAAKtc,QAAQgc,EAAI+Z,aAEdzZ,EAGJ,YACH,IAAIpiB,EAAS,EAIb,OAHAzE,KAAKsmB,KAAKjc,QAAQkc,IACd9hB,GAAU8hB,EAAIga,WAAa,IAExB97B,EAGJ,cAAc0D,GAEjBnI,KAAKsmB,KAAKjc,QAAQ,CAACkc,EAAKia,KACpBja,EAAIC,MAAMnc,QAAQ,CAACoc,EAAMga,KACjBha,EAAKza,MAAM00B,eAAiBt+B,EAAW+W,OACvCnZ,KAAK2gC,eAAeF,EAAaD,OAI7CxgC,KAAKsmB,KAAKjc,QAAQkc,IACdA,EAAIvD,cAAc7a,KAGtBnI,KAAKsmB,KAAKjc,QAAQ,CAACkc,EAAKia,KACpBja,EAAIC,MAAMnc,QAAQ,CAACoc,EAAMma,KAChBna,EAAKC,cAAgB,QAAsBvhB,IAAhBshB,EAAK/d,SACjC+d,EAAK/d,OAAOjE,OAASzE,KAAK6gC,oBAAoBD,EAAWJ,QAOjE,eAAeI,EAAmBE,GACtC,IAAIC,EAAU,EACd,IAAK,IAAI3gC,EAAI0gC,EAAe1gC,EAAIJ,KAAKsmB,KAAKhb,OAAQlL,IAAK,CACnD,MAAM4gC,EAAahhC,KAAKsmB,KAAKlmB,EAAI,GACjC,QAAmB+E,IAAf67B,GAA4BA,EAAWxa,MAAMoa,GAAW50B,MAAM00B,eAAiBt+B,EAAWwE,OAAQ,CAElG5G,KAAKsmB,KAAKlmB,GAAGomB,MAAMoa,GAAW50B,MAAM00B,aAAet+B,EAAWyE,KAC9D,MAEJm6B,EAAWxa,MAAMoa,GAAWla,cAAgB,EAC5Cqa,IAEJ/gC,KAAKsmB,KAAKwa,GAAeta,MAAMoa,GAAWla,cAAgBqa,EAGtD,oBAAoBH,EAAmBE,GAC3C,IAAIr8B,EAAS,EACb,MAAMs8B,EAAU/gC,KAAKsmB,KAAKwa,GAAeta,MAAMoa,GAAWla,cAC1D,IAAK,IAAItmB,EAAI,EAAGA,EAAI2gC,EAAS3gC,IACzBqE,GAAUzE,KAAKsmB,KAAKwa,EAAgB1gC,GAAGmgC,WAAa,EAExD,OAAO97B,GCjFR,MAAMw8B,GAIT,YAAY/7B,EAAeV,GACvBxE,KAAKkF,MAAQA,EACblF,KAAKwE,MAAQA,GCDd,MAAM,GAKT,YAAYqW,GAHL,KAAA2L,MAAqB,GAIxBxmB,KAAK6a,MAAQA,EAGV,SAASqmB,GACZlhC,KAAKwmB,MAAMnc,QAAQoc,GAAQA,EAAK0a,SAAWD,GAGxC,UACH,MAAMra,EAAoB,GAI1B,OAHA7mB,KAAKwmB,MAAMnc,QAAQoc,IACfI,EAAKtc,QAAQkc,EAAKI,QAEfA,EAGJ,cAAc1e,GACjB,IAAIo4B,EAAY,EAChBvgC,KAAKwmB,MAAMnc,QAAQoc,IAEf,GADAA,EAAKzD,cAAc7a,GACfse,EAAKza,MAAM00B,eAAiBt+B,EAAWgX,KAAM,CAC7C,MAAMgoB,EAAa3a,EAAK/d,OAAQjE,OAChC87B,EAAYn6B,KAAKI,IAAI46B,EAAYb,MAIzCvgC,KAAKwmB,MAAMnc,QAAQoc,IACXA,EAAKza,MAAM00B,eAAiBt+B,EAAWgX,OACvCqN,EAAK/d,OAAQjE,OAAS87B,KAG9BvgC,KAAKugC,UAAYA,EACjBp4B,EAAK4B,gBAAgBw2B,ICpCtB,MAAM,GAYT,YAAYF,EAAwBr0B,EAAmBq1B,GAXhD,KAAAv2B,QAAyB3F,EACzB,KAAA0hB,KAAoB,GAGpB,KAAAH,cAAwB,EAIvB,KAAA4a,cAAsCn8B,EAI1CnF,KAAKgM,MAAQA,EACbhM,KAAKuhC,YAAclB,EACnBrgC,KAAKwhC,kBAAoBH,EAGtB,cAAcl5B,GACjB,MAAMnE,EAAImE,EAAK8B,OAASjK,KAAKyhC,cAAc,GAAGv8B,MACxCjB,EAAIkE,EAAK8X,OACTlb,EAAU/E,KAAKgM,MAAMjH,QACrBqiB,EAAUpnB,KAAKgM,MAAMob,QAC3BpnB,KAAK0I,OAAS,IAAI,EAAI1E,EAAGC,EAAGjE,KAAK0hC,YAAa,GAC9C,MAAMP,OAA8Bh8B,IAAlBnF,KAAKmhC,SAA0B/+B,EAAWgX,KAAOpZ,KAAKmhC,SAClEQ,EAAc3hC,KAAK4hC,kBACzB5hC,KAAK6hC,eAAiB7hC,KAAK0I,OAAO2a,QAAQye,0BAA0B1a,EAASriB,EAASo8B,EAAUQ,GAChG,MAAMI,EAAgB/hC,KAAKgiC,oBAAoB75B,EAAMnI,KAAK6hC,gBAC1D7hC,KAAK6hC,eAAep9B,OAASs9B,EAC7B/hC,KAAK0I,OAAS1I,KAAK6hC,eAAeI,qBAAqB7a,EAASriB,EAASo8B,EAAUQ,GAGvF,iBACI,OAAO3hC,KAAKyhC,cAAcn2B,OAGtB,cACJ,QAAsBnG,IAAlBnF,KAAKshC,SAAwB,CAC7B,MAAMxB,EAAa9/B,KAAKgM,MAAM8zB,WAC9B9/B,KAAKshC,SAAWthC,KAAKuhC,YAAYW,MAAMliC,KAAKwhC,kBAAmBxhC,KAAKwhC,kBAAoB1B,GAE5F,OAAO9/B,KAAKshC,SAGR,YACJ,IAAI98B,EAAQ,EAIZ,OAHAxE,KAAKyhC,cAAcp3B,QAAQ83B,IACvB39B,GAAS29B,EAAI39B,QAEVA,EAGH,oBAAoB2D,EAAmBO,GAC3C,MAAM05B,EAAW,IAAI,EAAY15B,EAAOhE,KAAMgE,EAAO9D,MAAO8D,EAAO/D,KAKnE,OAJA3E,KAAK6mB,KAAKxc,QAAQyc,IACdA,EAAI9D,cAAcof,KAEtBj6B,EAAKk6B,kBAAkBD,GAChBA,EAASzG,SAAQ,GAASjzB,EAAO/D,IAGpC,kBACJ,IAAIu8B,EAAQ9+B,EAAWwE,OACvB,MAAM07B,EAAgBtiC,KAAKuhC,YAAYj2B,OAQvC,OAPsB,IAAlBg3B,EACApB,EAAQ9+B,EAAWgX,KACe,IAA3BpZ,KAAKwhC,kBACZN,EAAQ9+B,EAAW+W,MACZnZ,KAAKwhC,kBAAoBxhC,KAAKuiC,aAAeD,IACpDpB,EAAQ9+B,EAAWyE,MAEhBq6B,GCvER,MAAM,GACF,mBAAmBsB,EAAoBzsB,EAAgC/B,GAC1E,MAAM2J,EAAM,IAAI,EAAQ,GAAI,IAAI,GAC1B8kB,EAAmB90B,EAAIyB,oBAAoBozB,EAAS,SAS1D,YARyBr9B,IAArBs9B,GAAkCA,EAAiBC,kBACnD/kB,EAAI3R,MAAM2K,SAAW,EAASC,qBAAqB6rB,SAEtCt9B,IAAb4Q,IACA4H,EAAI3R,MAAM+J,SAAWA,GAEzB4H,EAAIf,MAAQ,GAAW8O,UAAU8W,GACjC7kB,EAAI3R,MAAM4M,iBAAiB5E,GACpB2J,EAGH,iBAAiB6kB,GACrB,MAAM5lB,EAAkB,GAuBxB,OAtBI4lB,EAAQE,iBACRF,EAAQjzB,WAAWlF,QAASqC,IACxB,OAAOA,EAAK+C,UACR,IAAK,MACD,MAAM+T,EAAU9W,EAAKi2B,YACL,OAAZnf,GACA5G,EAAMrS,KAAKiZ,GAEf,MACJ,IAAK,OACL,IAAK,OACD5G,EAAMrS,KAAK,MACX,MACJ,IAAK,QACDqS,EAAMrS,KAAK,SAQpBqS,GCnCR,MAAM,GAuBT,YAAYuf,EAAex7B,GACvBX,KAAK4iC,MAAQzG,EACbn8B,KAAK6iC,MAAQliC,EAnBV,mBAAmBmiC,EAAoBzH,GAC1C,IAAI1d,OAA2BxY,EAC/B,MAAM49B,EAAWp1B,EAAIyB,oBAAoB0zB,EAAS,gBAClD,QAAiB39B,IAAb49B,EAAwB,CACxB,MAAMC,EAAOr1B,EAAIyB,oBAAoB2zB,EAAU,UAC/C,QAAa59B,IAAT69B,EAAoB,CACpB,MAAMC,EAAQt1B,EAAIqB,aAAag0B,EAAM,WACrC,IAAIrG,OAA6Bx3B,OACNA,IAAvBk2B,EAAK6H,oBAAyC/9B,IAAV89B,IACpCtG,EAAStB,EAAK6H,cAAcC,UAAUF,GACtCtlB,EAAM,IAAI,GAAQ0d,EAAKc,KAAM,QAAQQ,KAIjD,OAAOhf,EAQJ,cACH,OAAO,IAAI9P,QAA6B,CAACC,EAASC,KAC9C,QAAuB5I,IAAnBnF,KAAKojC,UACLt1B,EAAQ9N,KAAKojC,eACV,CACH,MAAMC,EAAYrjC,KAAK6iC,MAAMruB,MAAM,KAC7B8uB,EAAgBD,EAAUA,EAAU/3B,OAAS,GACnD,IAAIi4B,OAA+Fp+B,EAC/Fq+B,OAA+Br+B,EACnC,OAAOm+B,GACH,IAAK,MACL,IAAK,OACDE,EAAW,aACX,MACJ,IAAK,MACDA,EAAW,YACX,MACJ,IAAK,MACDA,EAAW,YACX,MACJ,IAAK,MACDA,EAAW,YACX,MACJ,IAAK,OACDA,EAAW,aACX,MACJ,IAAK,MACL,IAAK,OACGxjC,KAAKyjC,kBACLF,EAAavjC,KAAK0jC,qBAEtB,MACJ,IAAK,MACG1jC,KAAK2jC,iBACLJ,EAAavjC,KAAK4jC,oBAEtB,MACJ,IAAK,MAED,MACJ,IAAK,MACG5jC,KAAK6jC,iBACLN,EAAavjC,KAAK8jC,oBAO9B,QAAiB3+B,IAAbq+B,EACAxjC,KAAK4iC,MAAMmB,iBAAiB/jC,KAAK6iC,OAAOzd,KAAK5B,IACzCxjB,KAAKojC,UAAY,QAAQI,YAAmBhgB,IAC5C1V,EAAQ9N,KAAKojC,aACd5d,MAAMC,IACL1X,EAAO0X,UAER,QAAmBtgB,IAAfo+B,QAA4Cp+B,IAAhBnF,KAAK0I,OAAsB,CAC9D,MAAMA,EAAS1I,KAAK0I,OACpB1I,KAAK4iC,MAAMoB,iBAAiBhkC,KAAK6iC,OAAOzd,KAAK6e,IACzCV,EAAYU,EAAQv7B,GAAQ0c,KAAMxX,IAC9B5N,KAAKojC,UAAYx1B,EACjBE,EAAQ9N,KAAKojC,aACd5d,MAAO4W,IACNruB,EAAOquB,WASxB,cAAcpN,IAGrB,sBACI,YAAgB7pB,IAAT++B,KAGH,oBAAoBD,EAAqBE,GAC7C,OAAO,IAAIt2B,QAAgB,CAACC,EAASC,KACjC,MAAMq2B,EAAOF,KAAKG,OAAOJ,GACzB,IAAIK,EAAOF,EACPG,EAAK,EACLC,EAAOF,EAAK,GACZF,EAAK,GAAGK,SACRH,EAAOA,EAAKI,OAAON,EAAK,GAAGK,SAE/B,IAAK,IAAIrkC,EAAI,EAAGA,EAAIkkC,EAAKh5B,OAAQlL,IAAK,CAClC,MAAMukC,EAAML,EAAKlkC,GACjB,GAAoB,OAAhBukC,EAAU,MAAcA,EAAU,KAAEr5B,OAAS,EAC7C,SAEJ,MAAMs5B,EAAKD,EAAU,KAAIA,EAAU,KAC/BC,EAAKL,IACLA,EAAKK,EACLJ,EAAOG,GAGfT,KAAKW,YAAYZ,EAAQO,EAAMJ,GAC/B,MAAMU,EAAOZ,KAAKa,QAAQP,GACpBhgC,EAAQggC,EAAKhgC,MACbC,EAAS+/B,EAAK//B,OAEpBy/B,KAAKc,MAAMC,OADC,EACW,GACvB,IAAI13B,EAASpB,SAASqB,cAAc,UACpCD,EAAO/I,MAAQA,EACf+I,EAAO9I,OAASA,EAChB,MAAM0I,EAAUI,EAAOE,WAAW,MAClC,GAAgB,OAAZN,EAAkB,CAClB,MAAM+3B,EAAO/3B,EAAQg4B,gBAAgB3gC,EAAOC,GAC5C,IAAK,IAAIrE,EAAI,EAAGA,EAAI0kC,EAAKx5B,OAAQlL,IAC7B8kC,EAAKE,KAAKhlC,GAAK0kC,EAAK1kC,GAExB+M,EAAQk4B,aAAaH,EAAM,EAAG,GAC9Bp3B,EAAQP,EAAO+3B,kBAEfv3B,EAAO,+CAKnB,qBACI,YAAiB5I,IAAVogC,MAGH,mBAAmBtB,EAAqBv7B,GAC5C,OAAO,IAAImF,QAAgB,CAACC,EAASC,KACjCw3B,MAAMC,gBAAe,GACrB,MAAMC,EAAW,IAAIF,MAAMG,SAASzB,GAC9Bz/B,EAAQkE,EAAOlE,MACfC,EAASiE,EAAOjE,OAChBkhC,EAAW,CACbnhC,MAAOA,EAAQ,KACfC,OAAQA,EAAS,KACjBmhC,KAAMphC,EACNqhC,KAAMphC,EACNqhC,QAAS,GAEPlJ,EAAS6I,EAAShL,OAAOkL,QAChBxgC,IAAXy3B,EACA9uB,EAAQ8uB,GAER7uB,EAAO,+BAKnB,qBACI,YAAiB5I,IAAV4gC,MAGH,mBAAmB9B,EAAqBv7B,GAC5C,OAAO,IAAImF,QAAgB,CAACC,EAASC,KACjCg4B,MAAMP,gBAAe,GACrB,MAAMC,EAAW,IAAIM,MAAML,SAASzB,GAC9Bz/B,EAAQkE,EAAOlE,MACfC,EAASiE,EAAOjE,OAChBkhC,EAAW,CACbnhC,MAAOA,EAAQ,KACfC,OAAQA,EAAS,KACjBmhC,KAAMphC,EACNqhC,KAAMphC,EACNqhC,QAAS,GAEPlJ,EAAS6I,EAAShL,OAAOkL,QAChBxgC,IAAXy3B,EACA9uB,EAAQ8uB,GAER7uB,EAAO,gCC1MhB,MAAe,GAMlB,YAAY6b,GALL,KAAAG,OAAwB,GAM3B/pB,KAAK4pB,MAAQA,EAGV,YACH,MAAO,CACH+O,QAAS34B,KAAK+pB,OAAO,GAAGuD,WAAWhiB,OACnC06B,UAAWhmC,KAAK+pB,OAAO,GAAGkc,OAAO36B,OACjC2sB,UAAWj4B,KAAK+pB,OAAOze,QAIxB,SAASotB,EAAkBJ,GAC9B,OAAOt4B,KAAK+pB,OAAOuO,GAAa2N,OAAOvN,GAGpC,gBACH,QAAuBvzB,IAAnBnF,KAAKkmC,gBAA8C/gC,IAAnBnF,KAAKmmC,UACrC,MAAO,CAAE9/B,IAAKrG,KAAKmmC,UAAW3/B,IAAKxG,KAAKkmC,WAE5C,IAAI1/B,EAAMwsB,OAAOoT,UACb//B,EAAM2sB,OAAOqT,UACjBrmC,KAAK+pB,OAAO1f,QAAQ0f,IAChBA,EAAOkc,OAAO57B,QAAQyE,IAClB,MAAMw3B,EAAMx3B,EAAI2qB,aACJt0B,IAARmhC,IACA9/B,EAAMJ,KAAKI,IAAIA,EAAK8/B,GACpBjgC,EAAMD,KAAKC,IAAIA,EAAKigC,QAIhC,MAAMzc,EAAY7pB,KAAK4pB,MAAMoC,SAASnC,UAMtC,YALkB1kB,IAAd0kB,GAA2BA,EAAUY,YAAcpnB,EAAmBqnB,WACtErkB,EAAM,GAEVrG,KAAKmmC,UAAY9/B,EACjBrG,KAAKkmC,UAAY1/B,EACV,CAAEA,IAAKA,EAAKH,IAAKA,GAGrB,cAAcA,EAAaG,GAC9BxG,KAAKmmC,UAAY9/B,EACjBrG,KAAKkmC,UAAY1/B,EAGd,eAAe8xB,EAAqBiO,GACvC,IAAIv6B,EACJ,MAAMuhB,EAAMvtB,KAAK+pB,OAAOuO,GAAahL,WAAWiZ,GAMhD,OAJIv6B,OADc7G,IAAdooB,EAAIvhB,MACIuhB,EAAIvhB,MAEJhM,KAAK+pB,OAAOuO,GAAatsB,MAE9BA,I/C9Df,SAAYxI,GACR,+BACA,2BAFJ,CAAYA,MAAgB,KAKrB,MAAM,WAAiB,GAE1B,YAAYomB,GACRwK,MAAMxK,GAFH,KAAA4c,YAAchjC,EAAiBijC,YgDNnC,MAAM,GAAb,cACW,KAAAnZ,WAA2B,GAC3B,KAAA2Y,OAAuB,GACvB,KAAAj6B,MAAoB,IAAIyd,EACxB,KAAA9oB,KAAe,GAEtB,uBACI,OAAOX,KAAKimC,OAAO36B,OAAS,QAAgCnG,IAA3BnF,KAAKimC,OAAO,GAAGxM,QAGpD,2BACI,OAAOz5B,KAAKstB,WAAWhiB,OAAS,QAAoCnG,IAA/BnF,KAAKstB,WAAW,GAAGmM,SCZzD,MAAMiN,GAAb,cACW,KAAAjN,aAA8Bt0B,EAC9B,KAAA4G,UAA2B5G,EAC3B,KAAA6G,WAAgC7G,EAEhC,WACH,IAAIwhC,EAAM,GAMV,YALqBxhC,IAAjBnF,KAAKy5B,QACLkN,EAAM3mC,KAAKy5B,QAAQrlB,gBACEjP,IAAdnF,KAAK+L,OACZ46B,EAAM3mC,KAAK+L,MAER46B,GCXR,MAAM,WAAkB,GAC3B,YAAY/c,GACRwK,MAAMxK,ICFP,MAAM,WAAkB,GAC3B,YAAYA,GACRwK,MAAMxK,ICFP,MAAM,WAAiB,GAG1B,YAAYA,GACRwK,MAAMxK,GACN5pB,KAAKw0B,WAAa,EAGf,YAAY8D,GACf,MAAM2N,EAASjmC,KAAK+pB,OAAOuO,GAAa2N,OACxC,IAAIW,EAAQ,EACZ,IAAK,IAAIxmC,EAAI,EAAGA,EAAI6lC,EAAO36B,OAAQlL,IAAK,CACpC,MAAMq5B,EAAUwM,EAAO7lC,GAAGq5B,aACVt0B,IAAZs0B,IACAmN,GAASnN,GAGjB,OAAOmN,GClBR,MAAMC,GAGF,mBAAmBlmC,EAAcoxB,GACpC/xB,KAAK8mC,SAASnmC,GAAQ,IAAMoxB,EAAM1O,QAG/B,YAAY1iB,GACf,IAAIoxB,OAA2B5sB,EAC/B,MAAM4hC,EAAuBF,GAAmBC,SAASnmC,GAMzD,YALgBwE,IAAZ4hC,EACAhV,EAAQgV,IAERl2B,QAAQC,IAAI,0BAA0BnQ,MAEnCoxB,GAdI,GAAA+U,SAAgB,GCE5B,MAAM,GAGF,UAAUE,GACb,IAAIjV,EAA2B,IAAI,GAC/BhN,OAAgC5f,EAChCukB,OAAgCvkB,EACpC,MAAMs9B,EAAmB90B,EAAIyB,oBAAoB43B,EAAW,YAmC5D,YAlCyB7hC,IAArBs9B,GACAA,EAAiBlzB,WAAWlF,QAAQgF,IAChC,OAAOA,EAAMI,UACT,IAAK,aACDsiB,EAAQ/xB,KAAKinC,iBAAiB53B,GAC9B,MACJ,IAAK,aACD0iB,EAAQ/xB,KAAKknC,iBAAiB73B,GAC9B,MACJ,IAAK,cACD0V,EAAY/kB,KAAKmnC,eAAe93B,GAChC,MACJ,IAAK,OAEkB,OADAA,EAAM+3B,aAErB1d,EAAY1pB,KAAKmnC,eAAe93B,EAAM+3B,aAE1C,MACJ,IAAK,WACDriB,OAAY5f,EACZ,MACJ,IAAK,SAED,MACJ,QACI0L,QAAQC,IAAI,2BAA2BzB,EAAMI,0CAK/CtK,IAAV4sB,IACAA,EAAMrI,UAAYA,EAClBqI,EAAMhN,UAAYA,GAEfgN,EAGJ,SAASsV,EAAgBtV,GAC5B,IAAI+D,GAAW,EACXC,GAAU,EACd,MAAMuR,EAAO35B,EAAIqB,aAAaq4B,EAAU,aAC3BliC,IAATmiC,IACAxR,EAAoB,SAATwR,GAEf,MAAMC,EAAS55B,EAAIqB,aAAaq4B,EAAU,eAC3BliC,IAAXoiC,IACAxR,EAAUpoB,EAAIiC,mBAAmB23B,IAErCxV,EAAMyV,QAAQ1R,EAAUC,GACxBsR,EAAS93B,WAAWlF,QAAQo9B,IACxB,GAAIA,EAAYC,WAAaC,KAAKC,aAC9B,OAAOH,EAAYh4B,UACf,IAAK,UACL,IAAK,QACDzP,KAAK6nC,UAAUJ,EAAa1V,GAC5B,MACJ,IAAK,WACL,IAAK,SACD,MAAM+V,EAAgBn6B,EAAIyB,oBAAoBq4B,EAAa,CAAC,KAAM,cAC5CtiC,IAAlB2iC,EACA/V,EAAMwG,eAAev4B,KAAK+nC,WAAWD,IAErCj3B,QAAQC,IAAI,6CAEhB,MACJ,IAAK,SACL,IAAK,OACD,MAAMk3B,EAAgBr6B,EAAIyB,oBAAoBq4B,EAAa,CAAC,KAAM,cAC5CtiC,IAAlB6iC,EACAjW,EAAM8G,eAAe74B,KAAK+nC,WAAWC,IAErCn3B,QAAQC,IAAI,6CAEhB,MACJ,IAAK,eACL,IAAK,aACD9Q,KAAKioC,gBAAgBR,EAAa1V,GAClC,MACJ,IAAK,cACL,IAAK,YACD/xB,KAAKkoC,eAAeT,EAAa1V,GACjC,MACJ,IAAK,UACL,IAAK,QACDA,EAAMoW,kBACN,MACJ,QACIt3B,QAAQC,IAAI,wBAAwB22B,EAAYh4B,mDAO5D,iBAAiB24B,GACrB,IAAIrW,OAA2B5sB,EAC/B,MAAMxE,EAAOgN,EAAIqB,aAAao5B,EAAY,QAI1C,YAHajjC,IAATxE,IACAoxB,EAAQ,GAAYsW,eAAeC,YAAY3nC,IAE5CoxB,EAGH,iBAAiBwW,GACrB,IAAIxW,OAA2B5sB,EAC/B,MAAMqjC,EAAe76B,EAAIyB,oBAAoBm5B,EAAY,aACzD,QAAqBpjC,IAAjBqjC,EAA4B,CAC5B,MAAMnB,EAAW15B,EAAIyB,oBAAoBo5B,EAAc,UACvD,QAAiBrjC,IAAbkiC,EAAwB,CACxBtV,EAAQ,IAAI,GACZ/xB,KAAKyoC,SAASpB,EAAUtV,GACxB,MAAM2W,EAAY/6B,EAAIqB,aAAaq4B,EAAU,UAC3BliC,IAAdujC,IACA3W,EAAMvtB,MAAQ8L,SAASo4B,IAE3B,MAAMC,EAAah7B,EAAIqB,aAAaq4B,EAAU,UAC3BliC,IAAfwjC,IACA5W,EAAMttB,OAAS6L,SAASq4B,KAIpC,OAAO5W,EAGH,eAAe6W,GACnB,IAAI5uB,OAA4B7U,EAChC,MAAM0jC,EAAYD,EAASxB,WAI3B,OAHkB,OAAdyB,IACA7uB,EAAQrM,EAAIgC,eAAek5B,IAExB7uB,EAGH,UAAUytB,EAAmB1V,GACjC,MAAMwC,EAAa5mB,EAAIqB,aAAay4B,EAAa,SAC3CjT,EAAa7mB,EAAIqB,aAAay4B,EAAa,SAC3CtU,EAAUxlB,EAAIqB,aAAay4B,EAAa,MACxCrU,EAAUzlB,EAAIqB,aAAay4B,EAAa,WAC3BtiC,IAAfovB,QAA2CpvB,IAAfqvB,QAAwCrvB,IAAZguB,QAAqChuB,IAAZiuB,GACjFrB,EAAMyH,cAAcjF,EAAYC,EAAYrB,EAASC,GAIrD,eAAeqU,EAAmB1V,GACtC,MAAMxiB,EAAak4B,EAAYl4B,WAC/B,GAA0B,IAAtBA,EAAWjE,OAAc,CACzB,MAAMnH,EAAWnE,KAAK+nC,WAAWx4B,EAAW,IACtCmmB,EAAU11B,KAAK+nC,WAAWx4B,EAAW,IAC3CwiB,EAAM+W,qBAAqB3kC,EAAUuxB,IAIrC,gBAAgB+R,EAAmB1V,GACvC,MAAMxiB,EAAak4B,EAAYl4B,WAC/B,GAA0B,IAAtBA,EAAWjE,OAAc,CACzB,MAAMnH,EAAWnE,KAAK+nC,WAAWx4B,EAAW,IACtCimB,EAAWx1B,KAAK+nC,WAAWx4B,EAAW,IACtCkmB,EAAWz1B,KAAK+nC,WAAWx4B,EAAW,IAC5CwiB,EAAMgX,sBAAsB5kC,EAAUqxB,EAAUC,IAIhD,WAAWuT,GACf,IAAIhlC,EAAI,IACJC,EAAI,IACR,MAAMglC,EAAQt7B,EAAIqB,aAAag6B,EAAW,KACpCE,EAAQv7B,EAAIqB,aAAag6B,EAAW,KAO1C,YANc7jC,IAAV8jC,IACAjlC,EAAIilC,QAEM9jC,IAAV+jC,IACAjlC,EAAIilC,GAED,IAAI,GAAWllC,EAAGC,IApLd,GAAAokC,eAAiB,IAAIxB,GCFjC,MAAM,GAEF,+BAA+BsC,GAClC,MAAMzgC,EAAS,IAAI,EACnBA,EAAOT,OAAS5F,EAAgB63B,SAChC,MAAMkP,EAAQz7B,EAAIyB,oBAAoB+5B,EAAe,UACrD,QAAchkC,IAAVikC,EAAqB,MAEPjkC,IADAwI,EAAIqB,aAAao6B,EAAO,WAElC1gC,EAAOZ,gBAAiB,QAGd3C,IADAwI,EAAIqB,aAAao6B,EAAO,WAElC1gC,EAAOX,cAAe,GAE1B,MAAM8D,EAAM8B,EAAIqB,aAAao6B,EAAO,YACxBjkC,IAAR0G,IACAnD,EAAOV,SAAWuD,EAAQ89B,yBAAyB/4B,SAASzE,KAEhE,MAAMzH,EAASuJ,EAAIyB,oBAAoBg6B,EAAO,SAC9C,QAAejkC,IAAXf,EAAsB,CACtB,MAAM8C,EAAUyG,EAAIqB,aAAa5K,EAAQ,UACzBe,IAAZ+B,IACAwB,EAAOxB,QAAUqE,EAAQ+9B,mBAAmBh5B,SAASpJ,KAEzD,MAAMC,EAAUwG,EAAIqB,aAAa5K,EAAQ,UACzBe,IAAZgC,IACAuB,EAAOvB,QAAUoE,EAAQ+9B,mBAAmBh5B,SAASnJ,KAG7D,GAAkBoiC,YAAYH,EAAO,QAAS1gC,GAElD,OAAOA,EAGJ,sBAAsB8gC,GACzB,MAAM9gC,EAAS,IAAI,EAKnB,OAJAA,EAAOT,OAAS5F,EAAgB6F,OAChC,GAAkBqhC,YAAYC,EAAY,YAAa9gC,GACvD,GAAkB+gC,wBAAwBD,EAAY9gC,GACtD,GAAkBghC,sBAAsBF,EAAY9gC,GAC7CA,EAGJ,sBAAsBihC,GACzB,MAAMjhC,EAAS,IAAI,EAKnB,OAJAA,EAAOT,OAAS5F,EAAgB63B,SAChC,GAAkBqP,YAAYI,EAAY,YAAajhC,GACvD,GAAkB+gC,wBAAwBE,EAAYjhC,GACtD,GAAkBghC,sBAAsBC,EAAYjhC,GAC7CA,EAGH,+BAA+BuG,EAAcvG,GACjD,MAAMkhC,EAASj8B,EAAIyB,oBAAoBH,EAAQ,gBAC/C,QAAe9J,IAAXykC,EAAsB,CACtB,MAAM5/B,EAAY,GAAkB6/B,uBAAuBD,QACzCzkC,IAAd6E,IACAtB,EAAOtB,WAAa4C,GAExB,MAAM8/B,EAAkB,GAAkBC,6BAA6BH,GACvElhC,EAAOnB,iBAAmBuiC,EAC1B,MAAM/4B,EAAQ,GAAkBi5B,uBAAuBJ,QACzCzkC,IAAV4L,IACArI,EAAOjB,OAASsJ,IAKpB,6BAA6B9B,EAAcvG,GAC/C,MAAMuhC,EAAUt8B,EAAIyB,oBAAoBH,EAAQ,gBAChD,QAAgB9J,IAAZ8kC,EAAuB,CACvB,MAAMjgC,EAAY,GAAkB6/B,uBAAuBI,QACzC9kC,IAAd6E,IACAtB,EAAOpB,WAAa0C,GAExB,MAAM8/B,EAAkB,GAAkBC,6BAA6BE,GACvEvhC,EAAOlB,iBAAmBsiC,EAC1B,MAAM/4B,EAAQ,GAAkBi5B,uBAAuBC,QACzC9kC,IAAV4L,IACArI,EAAOf,OAASoJ,IAKpB,8BAA8BrE,GAClC,IAAI1C,OAAgD7E,EACpD,MAAM+kC,EAAev8B,EAAIqB,aAAatC,EAAM,gBAC5C,QAAqBvH,IAAjB+kC,EACA,OAAOA,EAAar4B,eAChB,IAAK,YACL,IAAK,OACD7H,EAAY1H,EAAuB4H,UACnC,MACJ,IAAK,SACDF,EAAY1H,EAAuBiG,OACnC,MACJ,IAAK,aACL,IAAK,YACDyB,EAAY1H,EAAuB6nC,YACnC,MACJ,IAAK,cACL,IAAK,eACDngC,EAAY1H,EAAuB8nC,UACnC,MACJ,IAAK,eACDpgC,EAAY1H,EAAuB+nC,aACnC,MACJ,IAAK,gBACDrgC,EAAY1H,EAAuBgoC,cACnC,MACJ,IAAK,SACDtgC,EAAY1H,EAAuBioC,OACnC,MACJ,IAAK,OACDvgC,EAAY1H,EAAuBkoC,KACnC,MACJ,IAAK,YACDxgC,EAAY1H,EAAuBkG,UAI/C,OAAOwB,EAGH,8BAA8B0C,GAClC,IAAIqE,OAA4C5L,EAChD,MAAMslC,EAAY98B,EAAIyB,oBAAoB1C,EAAM,YAChD,QAAkBvH,IAAdslC,GAAqD,OAA1BA,EAAU9H,YACrC,OAAO8H,EAAU9H,YAAY9wB,eACzB,IAAK,OACL,IAAK,MACDd,EAAQxO,EAAuBmF,MAC/B,MACJ,IAAK,QACL,IAAK,SACDqJ,EAAQxO,EAAuBmoC,IAC/B,MACJ,IAAK,SACD35B,EAAQxO,EAAuBooC,OAC/B,MACJ,IAAK,UACD55B,EAAQxO,EAAuBqoC,QAC/B,MACJ,IAAK,SACD75B,EAAQxO,EAAuBwP,OAI3C,OAAOhB,EAGH,oCAAoCrE,GACxC,IAAItI,EAAiB,EACrB,MAAMymC,EAAal9B,EAAIyB,oBAAoB1C,EAAM,gBAIjD,YAHmBvH,IAAf0lC,GAAuD,OAA3BA,EAAWlI,cACvCv+B,EAASmH,EAAQ+9B,mBAAmBh5B,SAASu6B,EAAWlI,eAErDv+B,EAGH,mBAAmB6K,EAAmBQ,EAAkB/G,GAC5D,MAAMoiC,EAASn9B,EAAIyB,oBAAoBH,EAAQQ,GAC/C,QAAetK,IAAX2lC,EAAsB,CACtB,MAAMC,EAAUp9B,EAAIqB,aAAa87B,EAAQ,WACzB3lC,IAAZ4lC,IACAriC,EAAOd,MAAQ2D,EAAQ+9B,mBAAmBh5B,SAASy6B,KAEvD,MAAMC,EAAUr9B,EAAIqB,aAAa87B,EAAQ,WACzB3lC,IAAZ6lC,IACAtiC,EAAOb,MAAQ0D,EAAQ+9B,mBAAmBh5B,SAAS06B,OCnK5D,MAAM,GAGF,sBAAsBC,EAAwB5P,GACjD,IAAI3yB,EAAS,IAAI,EACbwiC,EAAW3nC,EAAS8D,KACxB,MAAMgI,EAAQ47B,EAAY17B,WAAW,GACd,cAAnBF,EAAMI,UACN/G,EAAS,GAAkByiC,eAAe97B,GAC1C67B,EAAW3nC,EAAS62B,cACM,cAAnB/qB,EAAMI,WACb/G,EAAS,GAAkB0iC,eAAe/7B,IAE9C,MAAMsqB,EAAU,IAAI,GAAWjxB,EAAQwiC,GACjCG,EAAU19B,EAAIyB,oBAAoBC,EAAO,aAC/C,QAAgBlK,IAAZkmC,EAAuB,CACvB,MAAMC,EAAc39B,EAAIyB,oBAAoBi8B,EAAS,sBACjClmC,IAAhBmmC,GACAtrC,KAAKurC,iBAAiB5R,EAAS2R,EAAajQ,GAGpD,OAAO1B,EAGH,wBAAwBA,EAAqB2R,EAAmBjQ,GACpEiQ,EAAY/7B,WAAWlF,QAAQmhC,IAC3B,OAAQA,EAAU/7B,UACd,IAAK,UACDkqB,EAAQC,QAAU,GAAQ6R,YAAYD,EAAWnQ,GACjD,MACJ,IAAK,UACD,MAAMqQ,EAAe/9B,EAAIqB,aAAaw8B,EAAW,QACjD,QAAqBrmC,IAAjBumC,QAAqDvmC,IAAvBk2B,EAAK6H,cAA6B,CAChE,MAAMyI,EAActQ,EAAK6H,cAAcC,UAAUuI,GACjD/R,EAAQ7P,MAAQ9pB,KAAK4rC,kBAAkBvQ,EAAKc,KAAKkB,cAAc,QAAQsO,IAE3E,MACJ,IAAK,UACDhS,EAAQ5H,MAAQ/xB,KAAK6rC,YAAYC,UAAUN,GAC3C,MACJ,IAAK,UACDxrC,KAAKurC,iBAAiB5R,EAAS6R,EAAWnQ,GAC1C,MACJ,IAAK,cACL,IAAK,iBAED,MACJ,QACIxqB,QAAQC,IAAI,2BAA2B06B,EAAU/7B,uCAMzD,yBAAyBqf,GAC7B,MAAMlF,EAAQ,IAAI,GACZmiB,EACF,IAAIl+B,QAAc,CAACC,EAASC,KACxB+gB,EAAQ1J,KAAKkZ,IACTt+B,KAAKgsC,sBAAsB1N,EAAKnyB,SAAUyd,GAC1C9b,MACD0X,MAAM4W,IACLruB,EAAOquB,OAInB,OADAxS,EAAMwF,WAAW2c,GACVniB,EAGH,6BAA6Bpb,EAAkBob,GACnD,MAAMqiB,EAAiBz9B,EAAI+uB,cAAc6J,WACzC,OAAuB,OAAnB6E,ECrEL,MACI,yBAAyBA,EAAsBriB,GAClD,MAAMsiB,EAAYv+B,EAAIyB,oBAAoB68B,EAAgB,WAgB1D,YAfkB9mC,IAAd+mC,GACAA,EAAU38B,WAAWlF,QAAQgF,IACzB,OAAQA,EAAMI,UACV,IAAK,SACDma,EAAM5d,MAAQhM,KAAKmsC,WAAW98B,GAC9B,MACJ,IAAK,aACDrP,KAAKosC,cAAc/8B,EAAOua,GAC1B,MACJ,IAAK,WACD5pB,KAAKqsC,YAAYh9B,EAAOua,MAKjCA,EAGH,qBAAqB0iB,EAAoB1iB,GAC7C0iB,EAAa/8B,WAAWlF,QAAQgF,IAC5B,OAAOA,EAAMI,UACT,IAAK,cACDma,EAAM2iB,aAAavsC,KAAKwsC,eAAen9B,EAAOua,IAC9C,MACJ,IAAK,cACDA,EAAM6iB,aAAazsC,KAAK0sC,eAAer9B,EAAOua,IAC9C,MACJ,IAAK,aACDA,EAAM+iB,YAAY3sC,KAAK4sC,cAAcv9B,EAAOua,IAC5C,MACJ,IAAK,aACDA,EAAMijB,YAAY7sC,KAAK8sC,cAAcz9B,EAAOua,IAC5C,MACJ,IAAK,UACDA,EAAMoC,SAASwD,aAAexvB,KAAK+sC,eAAe19B,EAAOua,GAAO,GAChE,MACJ,IAAK,UACDA,EAAMoC,SAASnC,UAAY7pB,KAAK+sC,eAAe19B,EAAOua,GAAO,GAC7D,MACJ,IAAK,SACDA,EAAMoC,SAAShgB,MAAQhM,KAAKmsC,WAAW98B,MAM/C,mBAAmB29B,EAAkBpjB,GACzC,MAAMyE,EAAS,IAAI,GAAYzE,GAC/BojB,EAAWz9B,WAAWlF,QAASgF,IAC3B,OAAQA,EAAMI,UACV,IAAK,SACD4e,EAAOriB,MAAQhM,KAAKmsC,WAAW98B,GAC/B,MACJ,IAAK,cACD,MAAMkC,EAAU5D,EAAIqB,aAAaK,EAAO,YACxBlK,IAAZoM,IACA8c,EAAOvlB,SAAW9I,KAAKitC,eAAe17B,IAE1C,MACJ,IAAK,YACD,MAAM27B,EAAUv/B,EAAIw/B,wBAAwB99B,EAAO,YACnClK,IAAZ+nC,IACA7e,EAAOZ,cAAgByf,MAMnCtjB,EAAMiD,YAAcvpB,EAAUurB,MAC9BR,EAAOX,WAAa,GAExB9D,EAAMyE,OAASA,EAGX,sBAAsB+e,EAAqBxjB,GAC/C,MAAME,EAAQ,IAAI,GAAUF,GAO5B,OANAwjB,EAAc79B,WAAWlF,QAAQgF,IAC7B,GAAuB,UAAnBA,EAAMI,SAAsB,CAC5B,MAAMsa,EAAS/pB,KAAKqtC,iBAAiBh+B,GACrCya,EAAMC,OAAOxf,KAAKwf,MAGnBD,EAGH,sBAAsBsjB,EAAqBxjB,GAC/C,MAAME,EAAQ,IAAI,GAAUF,GAO5B,OANAwjB,EAAc79B,WAAWlF,QAAQgF,IAC7B,GAAuB,UAAnBA,EAAMI,SAAsB,CAC5B,MAAMsa,EAAS/pB,KAAKqtC,iBAAiBh+B,GACrCya,EAAMC,OAAOxf,KAAKwf,MAGnBD,EAGH,qBAAqBwjB,EAAoB1jB,GAC7C,MAAME,EAAQ,IAAI,GAASF,GAO3B,OANA0jB,EAAa/9B,WAAWlF,QAAQgF,IAC5B,GAAuB,UAAnBA,EAAMI,SAAsB,CAC5B,MAAMsa,EAAS/pB,KAAKqtC,iBAAiBh+B,GACrCya,EAAMC,OAAOxf,KAAKwf,MAGnBD,EAGH,qBAAqByjB,EAAoB3jB,GAC7C,MAAME,EAAQ,IAAI,GAASF,GAa3B,OAZA2jB,EAAah+B,WAAWlF,QAAQgF,IAC5B,GAAuB,UAAnBA,EAAMI,SAAsB,CAC5B,MAAMsa,EAAS/pB,KAAKqtC,iBAAiBh+B,GACrCya,EAAMC,OAAOxf,KAAKwf,GAEtB,GAAuB,sBAAnB1a,EAAMI,SAAkC,CACxC,MAAM+9B,EAAY7/B,EAAIqB,aAAaK,EAAO,YACxBlK,IAAdqoC,IACA1jB,EAAM0K,WAAalkB,SAASk9B,OAIjC1jB,EAGH,kBAAkBtR,GACtB,MAAMxM,EAAQ,IAAIyd,EAiBlB,OAhBAjR,EAAUjJ,WAAWlF,QAAQgF,IACzB,OAAQA,EAAMI,UACV,IAAK,WACDzD,EAAM+Y,eAAY5f,EAClB,MACJ,IAAK,cACD6G,EAAM+Y,UAAY/kB,KAAKmnC,eAAe93B,GACtC,MACJ,IAAK,OACD,MAAM+3B,EAAa/3B,EAAM+3B,WACN,OAAfA,IACAp7B,EAAM0d,UAAY1pB,KAAKmnC,eAAeC,OAK/Cp7B,EAGH,sBAAsByhC,EAAgB7jB,EAAmBW,GAC7D,IAAIjgB,EAAyBpH,EAAkBmoB,OAC3Crf,EAAQ,IAAIyd,EACZqB,EAAmC3nB,EAAkBkE,KACrD0jB,EAAmC5nB,EAAkBkE,KACrD4jB,EAAiB,IAAIxB,EACrByB,EAAiB,IAAIzB,EACrBe,EAA0CpnB,EAAwB2O,OAClE0Y,EAAgCpnB,EAAmBqnB,SACnDM,EAAc,EAClByiB,EAASl+B,WAAWlF,QAAQgF,IACxB,IAAIq+B,OAA8BvoC,EAClC,OAAQkK,EAAMI,UACV,IAAK,SACDzD,EAAQhM,KAAKmsC,WAAW98B,GACxB,MACJ,IAAK,kBACDq+B,EAAU//B,EAAIqB,aAAaK,EAAO,YAClBlK,IAAZuoC,IACA5iB,EAAgB9qB,KAAK2tC,eAAeD,IAExC,MACJ,IAAK,kBACDA,EAAU//B,EAAIqB,aAAaK,EAAO,YAClBlK,IAAZuoC,IACA3iB,EAAgB/qB,KAAK2tC,eAAeD,IAExC,MACJ,IAAK,mBACwB,OAArBr+B,EAAM+3B,aACNnc,EAAiBjrB,KAAKmsC,WAAW98B,EAAM+3B,aAE3C,MACJ,IAAK,mBACwB,OAArB/3B,EAAM+3B,aACNlc,EAAiBlrB,KAAKmsC,WAAW98B,EAAM+3B,aAE3C,MACJ,IAAK,UACDsG,EAAU//B,EAAIqB,aAAaK,EAAO,YAClBlK,IAAZuoC,IACApjC,EAAMtK,KAAKitC,eAAeS,IAE9B,MACJ,IAAK,YACDA,EAAU//B,EAAIqB,aAAaK,EAAO,YAClBlK,IAAZuoC,IACAljB,EAAiBxqB,KAAK4tC,qBAAqBF,IAE/C,MACJ,IAAK,cACDA,EAAU//B,EAAIqB,aAAaK,EAAO,YAClBlK,IAAZuoC,IACA1iB,EAAczf,EAAQG,qBAAqB4E,SAASo9B,EAAS,MAEjE,MACJ,IAAK,YACDA,EAAU//B,EAAIqB,aAAaK,EAAO,YAClBlK,IAAZuoC,IACAjjB,EAAYzqB,KAAK6tC,gBAAgBH,OAKjD,MAAMje,EAAO,IAAI,GAAU7F,EAAO5d,EAAO1B,EAAKwgB,EAAeC,EAAeC,EAAaT,GAKzF,OAJAkF,EAAKjF,eAAiBA,EACtBiF,EAAKhF,UAAYA,EACjBgF,EAAKxE,eAAiBA,EACtBwE,EAAKvE,eAAiBA,EACfuE,EAGH,wBAAwBqe,GAC5B,MAAM/jB,EAAS,IAAI,GACbgkB,EAA0B,GAiFhC,OAhFAD,EAAWv+B,WAAWlF,QAASgF,IAC3B,MAAM+3B,EAAa/3B,EAAM+3B,WACzB,OAAO/3B,EAAMI,UACT,IAAK,OACD,GAAmB,OAAf23B,EAAqB,CACrB,MAAMlZ,EAAQluB,KAAKguC,qBAAqB5G,GACxCrd,EAAOppB,KAAOutB,EAAM,GAExB,MACJ,IAAK,QACD,GAAmB,OAAfkZ,EAAqB,CACrB,MAAM6G,EAAU7G,EAAW33B,SAC3B,GAAgB,aAAZw+B,EAAwB,CACLjuC,KAAKguC,qBAAqB5G,GAClC/8B,QAAQ6jC,IACf,MAAM3gB,EAAM,IAAImZ,GAChBnZ,EAAIxhB,KAAOmiC,EACXnkB,EAAOuD,WAAW/iB,KAAKgjB,UAExB,GAAgB,aAAZ0gB,EAAwB,CACbjuC,KAAKmuC,sBAAsB/G,GACnC/8B,QAAQ+jC,IACd,MAAM7gB,EAAM,IAAImZ,GAChBnZ,EAAIkM,QAAU2U,EACdrkB,EAAOuD,WAAW/iB,KAAKgjB,UAG3B1c,QAAQC,IAAI,qDAAqDm9B,GAGzE,MACJ,IAAK,QACD,GAAmB,OAAf7G,EAAqB,CACrB,MAAM6G,EAAU7G,EAAW33B,SAC3B,GAAgB,aAAZw+B,EAAwB,CACHjuC,KAAKguC,qBAAqB5G,GAClC/8B,QAAQgkC,IACjB,MAAMv/B,EAAM,IAAI43B,GAChB53B,EAAI/C,KAAOsiC,EACXtkB,EAAOkc,OAAO17B,KAAKuE,UAEpB,GAAgB,aAAZm/B,EAAwB,CACbjuC,KAAKmuC,sBAAsB/G,GACnC/8B,QAAQ+jC,IACd,MAAMt/B,EAAM,IAAI43B,GAChB53B,EAAI2qB,QAAU2U,EACdrkB,EAAOkc,OAAO17B,KAAKuE,UAGvB+B,QAAQC,IAAI,kDAAkDm9B,GAGtE,MACJ,IAAK,SACDlkB,EAAO/d,MAAQhM,KAAKmsC,WAAW98B,GAC/B,MACJ,IAAK,QACD,MAAMrE,EAAQ2C,EAAI2gC,uBAAuBj/B,EAAO,SAC1CmJ,EAAY7K,EAAIyB,oBAAoBC,EAAO,eACnClK,IAAV6F,QAAqC7F,IAAdqT,IACvBu1B,EAAU/iC,GAAShL,KAAKmsC,WAAW3zB,IAEvC,MACJ,IAAK,QACL,IAAK,UACL,IAAK,qBACL,IAAK,UACL,IAAK,WACL,IAAK,WACL,IAAK,cAED,MACJ,QACI3H,QAAQC,IAAI,2BAA2BzB,EAAMI,4CAIzDs+B,EAAU1jC,QAAQ,CAAC2B,EAAmB5L,KAClC2pB,EAAOuD,WAAWltB,GAAG4L,MAAQA,IAE1B+d,EAGH,4BAA4BwkB,GAChC,MAAMC,EAAgB,GAChBC,EAAe9gC,EAAIyB,oBAAoBm/B,EAAY,cAYzD,YAXqBppC,IAAjBspC,GACAA,EAAal/B,WAAWlF,QAAQqC,IAC5B,GAAsB,SAAlBA,EAAK+C,SAAqB,CAC1B,MAAMzE,EAAQ2C,EAAIqB,aAAatC,EAAM,OAC/BgiC,EAAY/gC,EAAIyB,oBAAoB1C,EAAM,YAClCvH,IAAV6F,QAAqC7F,IAAdupC,GAAqD,OAA1BA,EAAU/L,cAC5D6L,EAAIl+B,SAAStF,EAAO,KAAO0jC,EAAU/L,gBAK9C6L,EAIH,6BAA6BG,GACjC,MAAMH,EAAgB,GAChBI,EAAejhC,EAAIyB,oBAAoBu/B,EAAY,cAYzD,YAXqBxpC,IAAjBypC,GACAA,EAAar/B,WAAWlF,QAAQqC,IAC5B,GAAsB,SAAlBA,EAAK+C,SAAqB,CAC1B,MAAMzE,EAAQ2C,EAAIqB,aAAatC,EAAM,OAC/BgiC,EAAY/gC,EAAIyB,oBAAoB1C,EAAM,YAClCvH,IAAV6F,QAAqC7F,IAAdupC,GAAqD,OAA1BA,EAAU/L,cAC5D6L,EAAIl+B,SAAStF,EAAO,KAAO8E,WAAW4+B,EAAU/L,iBAKzD6L,EAGH,sBAAsB5F,GAC1B,IAAI5uB,OAA4B7U,EAChC,MAAM0jC,EAAYD,EAASxB,WAC3B,GAAkB,OAAdyB,GAA6C,cAAvBA,EAAUp5B,SAA0B,CAC1D,MAAMi+B,EAAU//B,EAAIqB,aAAa65B,EAAW,YAC5B1jC,IAAZuoC,IACA1zB,EAAQ0zB,GAGhB,OAAO1zB,EAGH,sBAAsB60B,GAC1B,IAAIC,EAAW3rC,EAAkBkE,KAIjC,MAHiB,QAAbwnC,IACAC,EAAW3rC,EAAkBwoB,UAE1BmjB,EAGH,sBAAsBv9B,GAC1B,IAAIw9B,EAAU7rC,EAAkBmoB,OAChC,OAAO9Z,GACH,IAAK,IACDw9B,EAAU7rC,EAAkBooB,IAC5B,MACJ,IAAK,IACDyjB,EAAU7rC,EAAkBmoB,OAC5B,MACJ,IAAK,IACD0jB,EAAU7rC,EAAkB0O,KAC5B,MACJ,IAAK,IACDm9B,EAAU7rC,EAAkB+O,MAGpC,OAAO88B,EAGH,4BAA4BC,GAChC,OAAO5rC,EAAwB2O,OAG3B,uBAAuBk9B,GAC3B,OAAO5rC,EAAmBqnB,WD3THwkB,kBAAkBjD,EAAgBriB,IAErD/Y,QAAQC,IAAI,wBACL,IAAI,KA1EJ,GAAA+6B,YAAc,IAAI,GEP9B,MAAM,WAAqB,EAG9B,YAAY7/B,GACRooB,MAAM,CAAC,IAAKpoB,EAAMA,OAAS,IAAI,GAC/BhM,KAAKmvC,OAASnjC,EAGX,cAAc7D,GACjB,MAAMoI,EAAUvQ,KAAKovC,YAAYjnC,GACjCisB,MAAMxX,MAAQ,CAAC5c,KAAKmvC,OAAOE,cAAc9+B,IACzCvQ,KAAKsvC,cAAcnnC,GACnBisB,MAAMpR,cAAc7a,GAGhB,YAAYA,GAChB,MAAMoI,EAAoB,GACpB3F,EAAQ5K,KAAKmvC,OAAOvkC,MACpBC,EAAQ7K,KAAKmvC,OAAOtkC,MAC1B,QAAc1F,IAAV0F,EAAqB,CACrB,MAAM0kC,EAAW1kC,EAAMG,MACvB,IAAI,IAAI5K,EAAI,EAAGA,GAAKmvC,EAAUnvC,IAC1BmQ,EAAQhG,KAAKpC,EAAKqnC,aAAa5kC,EAAOxK,SAG1CmQ,EAAQhG,KAAK,GAEjB,OAAOgG,EAGH,cAAcpI,GAClB,MAAMyC,EAAQ5K,KAAKmvC,OAAOvkC,MACpBC,EAAQ7K,KAAKmvC,OAAOtkC,MAC1B,IAAImF,EAAa,OACH7K,IAAV0F,IACAmF,EAAanF,EAAMG,OAEvB7C,EAAKsnC,iBAAiB7kC,EAAOoF,ICxC9B,MAAM0/B,GAGT,YAAYnV,GACRv6B,KAAKu6B,QAAUA,GCLhB,MAAMoV,GAAb,cACW,KAAAC,KAAe,GACf,KAAAC,SAAmB,EACnB,KAAAC,WAAqB,GCAzB,MAAeC,IASf,MAAM,WAAuBA,GAApC,c,oBACY,KAAAC,MAAsB,GAEvB,IAAIxV,GACPx6B,KAAKgwC,MAAMzlC,KAAKiwB,GAGb,QAAQA,GACXx6B,KAAKgwC,MAAMC,QAAQzV,GAGhB,IAAIxvB,GACP,OAAOhL,KAAKgwC,MAAMhlC,GAGtB,aACI,OAAOhL,KAAKgwC,MAAM1kC,OAGf,QAAQwmB,GACX,OAAO9xB,KAAKgwC,MAAM3lC,QAAQynB,GAGvB,UACH,IAAIzsB,EAAO,IAAI6b,EAAK,EAAG,GAIvB,OAHAlhB,KAAKgwC,MAAM3lC,QAAQmwB,IACfn1B,EAAOA,EAAK6qC,cAAc1V,EAAII,aAE3Bv1B,EAGJ,cAAc8C,EAAmB0X,GACpC,IAAIa,EAAUb,EAEd,OADA7f,KAAKgwC,MAAM3lC,QAAQmwB,GAAO9Z,EAAU8Z,EAAIxX,cAAc7a,EAAMuY,IACrDA,EAGJ,OAAOwF,GACVlmB,KAAKgwC,MAAM3lC,QAAQmwB,GAAOA,EAAIC,OAAOvU,KC1CtC,MAAM,WAAwB6pB,GAKjC,YAAYH,EAAc5jC,GACtBooB,QACAp0B,KAAKmwC,MAAQP,EACb5vC,KAAKmvC,OAASnjC,EAGX,UACH,MAAMvH,EAASzE,KAAKmvC,OAAOp1B,YAC3B,OAAO,IAAImH,EAAKlhB,KAAK0hC,YAAaj9B,GAG/B,cAAc0D,EAAmB0X,GAEpC,OADA7f,KAAKsJ,KAAO,IAAIvF,EAAMoE,EAAK8B,OAAS4V,EAAU1X,EAAK8X,QAC5CJ,EAAW7f,KAAK0hC,YAGpB,OAAOxb,QACQ/gB,IAAdnF,KAAKsJ,MACL4c,EAAQkD,UAAUppB,KAAKsJ,KAAKtF,EAAGhE,KAAKsJ,KAAKrF,EAAG,KAAK,EAAOjE,KAAKmwC,MAAOnwC,KAAKmvC,OAAOn1B,MAAOrX,EAAc+B,KAAM1E,KAAKmvC,OAAO7iC,WAAYtM,KAAKmvC,OAAO5iC,SAAUvM,KAAKmvC,OAAO3iC,KAAMxM,KAAKmvC,OAAO1iC,QAIvL,YACJ,OAAO,EAAYqP,iBAAiB9b,KAAKmvC,QAAUnvC,KAAKmwC,MAAM7kC,QC7B/D,MAAM,WAAmBykC,GAO5B,YAAYnnB,EAA6BwnB,EAA6BC,EAA8BrkC,GAChGooB,QACAp0B,KAAKswC,KAAO1nB,EACZ5oB,KAAKuwC,OAASH,EACdpwC,KAAKwwC,MAAQH,EACbrwC,KAAKmwC,MAAQ,IAAI,GAAgBnkC,EAAM4jC,KAAM,IAAI,GACjD5vC,KAAKmvC,OAASnjC,EAGX,UACH,IAAIykC,OAA2BtrC,IAAfnF,KAAKwwC,MAAwBxwC,KAAKwwC,MAAM5V,UAAY,IAAI1Z,EAAK,EAAG,GAC5EwvB,OAA6BvrC,IAAhBnF,KAAKuwC,OAAyBvwC,KAAKuwC,OAAO3V,UAAY,IAAI1Z,EAAK,EAAG,GAC/EyvB,OAAyBxrC,IAAdnF,KAAKswC,KAAuBtwC,KAAKswC,KAAK1V,UAAY,IAAI1Z,EAAK,EAAG,GAE7E,OADawvB,EAAUE,YAAYH,GAAUG,YAAYD,GAItD,cAAcxoC,EAAmB0X,G,WAClB1a,IAAdnF,KAAKswC,MAAuBtwC,KAAKmvC,OAAOU,SACxC7vC,KAAKswC,KAAKttB,cAAc7a,EAAM0X,QAEd1a,IAAhBnF,KAAKuwC,QAAyBvwC,KAAKmvC,OAAOW,WAC1C9vC,KAAKuwC,OAAOvtB,cAAc7a,EAAM0X,GAEpC,IAAIa,EAAUb,EAGd,OAFAa,EAAU1gB,KAAKmwC,MAAMntB,cAAc7a,EAAMuY,IAAYA,EACrDA,GAAoB,QAAV,EAAA1gB,KAAKwwC,aAAK,eAAExtB,cAAc7a,EAAMuY,KAAYA,EAC/CA,EAGJ,OAAOwF,G,WACQ/gB,IAAdnF,KAAKswC,MAAuBtwC,KAAKmvC,OAAOU,SACxC7vC,KAAKswC,KAAK7V,OAAOvU,QAED/gB,IAAhBnF,KAAKuwC,QAAyBvwC,KAAKmvC,OAAOW,WAC1C9vC,KAAKuwC,OAAO9V,OAAOvU,GAEvBlmB,KAAKmwC,MAAM1V,OAAOvU,GACR,QAAV,EAAAlmB,KAAKwwC,aAAK,SAAE/V,OAAOvU,IC7CpB,MAAM,WAAwB6pB,GAKjC,YAAYM,EAA8BQ,EAAgC7kC,GACtEooB,QACAp0B,KAAKwwC,MAAQH,EACbrwC,KAAK8wC,OAAS,IAAI,GAAgBD,EAAeE,UAAW/kC,GAC5DhM,KAAKgxC,KAAO,IAAI,GAAgBH,EAAeI,QAASjlC,GAGrD,U,UACH,IAAI3G,GAAiB,QAAV,EAAArF,KAAKwwC,aAAK,eAAE5V,YAAa,IAAI1Z,EAAK,EAAG,GAGhD,OAFA7b,EAAK6qC,eAAyB,QAAX,EAAAlwC,KAAK8wC,cAAM,eAAElW,YAAa,IAAI1Z,EAAK,EAAG,IACzD7b,EAAK6qC,eAAuB,QAAT,EAAAlwC,KAAKgxC,YAAI,eAAEpW,YAAa,IAAI1Z,EAAK,EAAG,IAChD7b,EAGJ,cAAc8C,EAAmB0X,G,UACpC,IAAIa,EAAUb,EAId,OAHAa,GAAqB,QAAX,EAAA1gB,KAAK8wC,cAAM,eAAE9tB,cAAc7a,EAAMuY,KAAYA,EACvDA,GAAoB,QAAV,EAAA1gB,KAAKwwC,aAAK,eAAExtB,cAAc7a,EAAMuY,KAAYA,EACtDA,GAAmB,QAAT,EAAA1gB,KAAKgxC,YAAI,eAAEhuB,cAAc7a,EAAMuY,KAAYA,EAC9CA,EAGJ,OAAOwF,G,UACC,QAAX,EAAAlmB,KAAK8wC,cAAM,SAAErW,OAAOvU,GACV,QAAV,EAAAlmB,KAAKwwC,aAAK,SAAE/V,OAAOvU,GACV,QAAT,EAAAlmB,KAAKgxC,YAAI,SAAEvW,OAAOvU,IC5BnB,MAAM,WAAkB6pB,GAG3B,YAAYhkC,EAAcC,GACtBooB,QACAp0B,KAAK6d,KAAO,IAAI,EAAQ,CAAC9R,GAAO,IAAI,OAAM5G,EAAW6G,IACrDhM,KAAK6d,KAAK+B,YAAcxd,EAAWwE,OAGhC,UACH,OAAO5G,KAAK6d,KAAK+c,UAGd,cAAczyB,EAAmB0X,GAGpC,OAFA7f,KAAK6d,KAAK2C,aAA6B,IAAbX,EAAkBA,OAAW1a,EACvDnF,KAAK6d,KAAKmF,cAAc7a,GACjBnI,KAAK6d,KAAKwD,SAGd,OAAO6E,GACO,IAAI,EAAaA,GACzB8U,cAAch7B,KAAK6d,OC9B7B,MAAMqzB,GAAb,cACW,KAAAH,UAAoB,GACpB,KAAAE,QAAkB,ICGtB,MAAM,WAAuBlB,GAKhC,YAAYoB,EAAmCC,EAAqCplC,GAChFooB,QACAp0B,KAAKqxC,WAAaF,EAClBnxC,KAAKsxC,aAAeF,EACpBpxC,KAAKgM,MAAQA,EAGV,UACH,IAAIulC,EAMAC,EAMJ,OAVID,OADsBpsC,IAAtBnF,KAAKsxC,aACatxC,KAAKsxC,aAAa1W,UAElB,IAAI1Z,EAAK,EAAG,GAI9BswB,OADoBrsC,IAApBnF,KAAKqxC,WACWrxC,KAAKqxC,WAAWzW,UAEhB,IAAI1Z,EAAK,EAAG,GAEzBqwB,EAAgBX,YAAYY,EAAe,IAG/C,cAAcrpC,EAAmB0X,G,QACpC,MAAM4xB,GAA4B,QAAf,EAAAzxC,KAAKqxC,kBAAU,eAAEruB,cAAc7a,EAAM0X,KAAaA,EAC/D6xB,GAA8B,QAAjB,EAAA1xC,KAAKsxC,oBAAY,eAAEtuB,cAAc7a,EAAM0X,KAAaA,EACvE,OAAOzZ,KAAKI,IAAIirC,EAAYC,GAGzB,OAAOxrB,G,QACK,QAAf,EAAAlmB,KAAKqxC,kBAAU,SAAE5W,OAAOvU,GACP,QAAjB,EAAAlmB,KAAKsxC,oBAAY,SAAE7W,OAAOvU,KlExClC,SAAYziB,GACR,qBACA,iBACA,uBACA,uBAJJ,CAAYA,MAAY,KAOjB,MAAMkuC,GAAb,cACW,KAAAnvB,KAAqB/e,EAAamuC,MAElC,QAAQC,GACX,OAAQA,GACJ,IAAK,MACD7xC,KAAKwiB,KAAO/e,EAAaqpB,IACzB,MACJ,IAAK,MACD9sB,KAAKwiB,KAAO/e,EAAaquC,OACzB,MACJ,IAAK,MACD9xC,KAAKwiB,KAAO/e,EAAasuC,OACzB,MACJ,IAAK,QACL,QACI/xC,KAAKwiB,KAAO/e,EAAamuC,SCvBzC,SAAYluC,GACR,uBACA,iBACA,uBACA,uBACA,uBACA,yBANJ,CAAYA,MAAY,KASxB,SAAYC,GACR,mBACA,uBACA,qBACA,uBACA,yBALJ,CAAYA,MAAkB,KAQ9B,SAAYC,GACR,uBACA,iCACA,iBACA,yBACA,2BALJ,CAAYA,MAAiB,KAQtB,MAAMouC,GAAb,cACW,KAAAC,kBAAkCvuC,EAAawE,OAC/C,KAAAgqC,iBAA2B,EAC3B,KAAAC,eAAoCvuC,EAAkB4R,OACtD,KAAA48B,WAAqB,EACrB,KAAAC,cAAmCzuC,EAAkB4R,OACrD,KAAA88B,UAAoB,EACpB,KAAAC,mBAA6B,EAC7B,KAAAC,kBAAgDrtC,EAEhD,iBAAiBstC,GACZA,GkEhCT,MAAM,WAAqB1C,GAI9B,YAAYzpB,EAAsBta,GAC9BooB,QACAp0B,KAAKsmB,KAAOA,EACZtmB,KAAKgM,MAAQA,EAGV,UACH,MAAM0mC,EAAU1yC,KAAKsmB,KAAKrlB,IAAI,GAAG25B,UAAUvX,QAE3C,OADAqvB,EAAQjuC,QAAUiuC,EAAQjuC,OAAS,IAAMzE,KAAKsmB,KAAKhb,OAAS,GACrDonC,EAGJ,cAAc1jB,EAAoB2jB,GACrC,MAAM,IAAI/wB,MAAM,2BAGb,OAAOwE,GACV,MAAM,IAAIxE,MAAM,4BC1BjB,MAAMgxB,ICKN,MAAM,WAAuB7C,GAKhC,YAAY8C,EAAsCxC,EAA8BrkC,GAC5EooB,QACAp0B,KAAK8yC,cAAgBD,EACrB7yC,KAAKwwC,MAAQH,EACbrwC,KAAKgM,MAAQA,EAGV,UACH,IAAIykC,EAMAsC,EAOJ,OAXItC,OADetrC,IAAfnF,KAAKwwC,MACMxwC,KAAKwwC,MAAM5V,UAEX,IAAI1Z,EAAK,EAAG,GAIvB6xB,OADuB5tC,IAAvBnF,KAAK8yC,cACM9yC,KAAK8yC,cAAclY,UAEnB,IAAI1Z,EAAK,EAAG,GAEd6xB,EAASnC,YAAYH,GAI/B,cAActoC,EAAmB0X,G,QACpC,IAAIa,GAA4B,QAAlB,EAAA1gB,KAAK8yC,qBAAa,eAAE9vB,cAAc7a,EAAM0X,KAAaA,EACnE,OAAiB,QAAV,EAAA7f,KAAKwwC,aAAK,eAAExtB,cAAc7a,EAAMuY,KAAYA,EAGhD,OAAOwF,G,QACQ,QAAlB,EAAAlmB,KAAK8yC,qBAAa,SAAErY,OAAOvU,GACjB,QAAV,EAAAlmB,KAAKwwC,aAAK,SAAE/V,OAAOvU,ICzCpB,MAAM8sB,GAAb,cACW,KAAAC,YAAsB,GCM1B,MAAM,WAAsBlD,GAM/B,YAAYmD,EAAgC7C,EAA8BrkC,GACtEooB,QACAp0B,KAAKmzC,QAAUD,EACflzC,KAAKwwC,MAAQH,EACbrwC,KAAKozC,SAAW,IAAI,GAAgB,UAAW,IAAI,GACnDpzC,KAAKgM,MAAQA,EAGV,UACH,IAAIykC,EAQJ,OANIA,OADetrC,IAAfnF,KAAKwwC,MACMxwC,KAAKwwC,MAAM5V,UAEX,IAAI1Z,EAAK,EAAG,GAE3BuvB,EAASjsC,OAAS,GAClBisC,EAAShsC,QAAU,GACZgsC,EAGJ,cAActoC,EAAmB0X,G,UACpC,IAAIa,EAAUb,EAId,OAHAa,GAAsB,QAAZ,EAAA1gB,KAAKmzC,eAAO,eAAEnwB,cAAc7a,EAAMuY,KAAYA,EACxDA,GAAuB,QAAb,EAAA1gB,KAAKozC,gBAAQ,eAAEpwB,cAAc7a,EAAMuY,KAAYA,EACzDA,GAAoB,QAAV,EAAA1gB,KAAKwwC,aAAK,eAAExtB,cAAc7a,EAAMuY,KAAYA,EAC/CA,EAGJ,OAAOwF,G,UACE,QAAZ,EAAAlmB,KAAKmzC,eAAO,SAAE1Y,OAAOvU,GACR,QAAb,EAAAlmB,KAAKozC,gBAAQ,SAAE3Y,OAAOvU,GACZ,QAAV,EAAAlmB,KAAKwwC,aAAK,SAAE/V,OAAOvU,IC3CpB,MAAM,GAAb,cACW,KAAA0gB,MAAgB,EAChB,KAAAz0B,cAAoCxO,EAAmBoO,OAEvD,iBAAiB0gC,GACpB,OAAQA,GACJ,IAAK,OACDzyC,KAAKmS,cAAgBxO,EAAmBiO,KACxC,MACJ,IAAK,QACD5R,KAAKmS,cAAgBxO,EAAmBsO,MACxC,MACJ,IAAK,SACDjS,KAAKmS,cAAgBxO,EAAmBgnC,OACxC,MACJ,IAAK,UACD3qC,KAAKmS,cAAgBxO,EAAmBinC,QACxC,MACJ,IAAK,SACL,QACI5qC,KAAKmS,cAAgBxO,EAAmBoO,SCXjD,MAAM,GACF,iCAAiCspB,EAAiBgY,GACrD,MAAMxsB,EAAoB,GACpBysB,EAAc3lC,EAAIyB,oBAAoBikC,EAAS,gBAarD,YAZoBluC,IAAhBmuC,GACAA,EAAY/jC,WAAWlF,QAAQgF,IAC3B,OAAQA,EAAMI,UACV,IAAK,MACDoX,EAAKtc,KAAK,GAAgBgpC,cAAclY,EAAMhsB,OAQvDwX,EAGJ,qBAAqBwU,EAAiBmY,GACzC,IAAItxB,EACAd,OAAiCjc,EACrC,MAAM8c,EAAe,GACflM,EAAW/V,KAAKyzC,UAAUpY,EAAMmY,QACrBruC,IAAb4Q,QAAgD5Q,IAAtB4Q,EAASK,WACnC8L,EAAe,IAAI,GAAanM,EAASK,WAE7C,MAAMoV,EAAYzV,EAASsN,QAC3BmI,EAAUpV,cAAWjR,EACrBquC,EAAMjkC,WAAWlF,QAAQqC,IAErB,GADA0U,OAAajc,EACS,gBAAlBuH,EAAK+C,SAA4B,CACjC,MAAMikC,EAAS/lC,EAAIqB,aAAatC,EAAM,aACvBvH,IAAXuuC,IACAtyB,EAAaia,EAAK6H,cAAeC,UAAUuQ,IAE/C,MAAMtM,EAAa16B,EAAK06B,WACL,OAAfA,IACA16B,EAAO06B,GAGf,GAAsB,QAAlB16B,EAAK+C,SAAoB,CACzB/C,EAAK6C,WAAWlF,QAAQgF,IACpB,GAAuB,cAAnBA,EAAMI,SAA0B,CAChC,MAAMkqB,EAAU,GAAcga,eAAetkC,EAAOgsB,GACpDpZ,EAAK1X,KAAKovB,GAEd,GAAuB,wBAAnBtqB,EAAMI,SAAoC,CAC1C,MAAMmkC,EAAajmC,EAAIyB,oBAAoBC,EAAO,aAClD,QAAmBlK,IAAfyuC,EAA0B,CAC1B,MAAMC,EAAalmC,EAAIyB,oBAAoBwkC,EAAY,kBACpCzuC,IAAf0uC,GACA5xB,EAAK1X,KAAK,GAAcopC,eAAeE,EAAYxY,QAMnE,MAAM1d,EAAM,GAAWm2B,YAAYpnC,EAAM8e,EAAW6P,EAAK0Y,QACzDp2B,EAAIiC,YAAcxd,EAAWwE,OAC7B+W,EAAIyD,WAAaA,EACjBa,EAAK1X,KAAKoT,GAEd,GAAsB,YAAlBjR,EAAK+C,SAAwB,CAC7B,MAAMukC,ECtDf,MAEI,oBAAoBC,GACvB,MAAM3Z,EAAW,IAAIoV,GAAS1vC,KAAKk0C,iBAAiBD,IACpD,OAAO,IAAIvZ,GAAQJ,GAGf,uBAAuB6Z,GAC3B,IAAInoC,EAAmB,IAAI2jC,GACvB/mB,OAA8BzjB,EAC9BirC,OAA8BjrC,EAC9BkrC,OAA+BlrC,EAC/BivC,EAA0B,KA0B9B,OAzBAD,EAAS5kC,WAAWlF,QAAQgF,IACxB,OAAQA,EAAMI,UACV,IAAK,WACDzD,EAAQhM,KAAKq0C,eAAehlC,GAC5B,MACJ,IAAK,QACD+kC,EAAa/kC,EAAM+3B,WACA,OAAfgN,IACAxrB,EAAM5oB,KAAKk0C,iBAAiBE,IAEhC,MACJ,IAAK,QACDA,EAAa/kC,EAAM+3B,WACA,OAAfgN,IACAhE,EAAMpwC,KAAKk0C,iBAAiBE,IAEhC,MACJ,IAAK,MACD/D,EAAOrwC,KAAKk0C,iBAAiB7kC,GAC7B,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,4CAIlD,IAAI,GAAWmZ,EAAKwnB,EAAKC,EAAMrkC,GAGlC,sBAAsBy2B,GAC1B,MAAMz2B,EAAQ,IAAI2jC,GAiBlB,OAhBAlN,EAAiBlzB,WAAWlF,QAAQgF,IAChC,OAAQA,EAAMI,UACV,IAAK,QACDzD,EAAM4jC,KAAOjiC,EAAIgC,eAAeN,IAAU,GAC1C,MACJ,IAAK,YACDrD,EAAM6jC,QAAUliC,EAAIkC,gBAAgBR,KAAU,EAC9C,MACJ,IAAK,YACDrD,EAAM8jC,UAAYniC,EAAIkC,gBAAgBR,KAAU,EAChD,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,2CAIlDzD,EAGH,4BAA4BsoC,GAChC,IAAItoC,EAAwB,IAAIklC,GAC5Bb,OAA+BlrC,EAcnC,OAbAmvC,EAAQ/kC,WAAWlF,QAAQgF,IACvB,OAAQA,EAAMI,UACV,IAAK,QACDzD,EAAQhM,KAAKu0C,oBAAoBllC,GACjC,MACJ,IAAK,MACDghC,EAAOrwC,KAAKk0C,iBAAiB7kC,GAC7B,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,yCAIlD,IAAI,GAAgB4gC,EAAMrkC,EAAO,IAAI,GAGxC,2BAA2By2B,GAC/B,MAAMz2B,EAAQ,IAAIklC,GAclB,OAbAzO,EAAiBlzB,WAAWlF,QAAQgF,IAChC,OAAQA,EAAMI,UACV,IAAK,WACDzD,EAAM+kC,UAAYpjC,EAAIgC,eAAeN,IAAU,GAC/C,MACJ,IAAK,WACDrD,EAAMilC,QAAUtjC,EAAIgC,eAAeN,IAAU,GAC7C,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,+CAIlDzD,EAGH,2BAA2BwoC,GAC/B,IAAIxoC,EAAuB,IAAI2lC,GAC3BR,OAAoChsC,EACpCisC,OAAsCjsC,EAiB1C,OAhBAqvC,EAASjlC,WAAWlF,QAAQgF,IACxB,OAAQA,EAAMI,UACV,IAAK,QACDzD,EAAQhM,KAAKy0C,mBAAmBplC,GAChC,MACJ,IAAK,QACD8hC,EAAYnxC,KAAKk0C,iBAAiB7kC,GAClC,MACJ,IAAK,QACD+hC,EAAcpxC,KAAKk0C,iBAAiB7kC,GACpC,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,wCAIlD,IAAI,GAAe0hC,EAAWC,EAAaplC,GAG9C,0BAA0By2B,GAC9B,MAAMz2B,EAAQ,IAAI2lC,GAWlB,OAVAlP,EAAiBlzB,WAAWlF,QAAQgF,IAChC,OAAQA,EAAMI,UACV,IAAK,SACDzD,EAAM0oC,QAAQ/mC,EAAIgC,eAAeN,IACjC,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,+CAIlDzD,EAGH,2BAA2BwoC,GAC/B,IAAIxoC,EAAQ,IAAI4mC,GACZC,OAAuC1tC,EACvCkrC,OAA+BlrC,EAiBnC,OAhBAqvC,EAASjlC,WAAWlF,QAAQgF,IACxB,OAAQA,EAAMI,UACV,IAAK,WACDzD,EAAQhM,KAAK20C,mBAAmBtlC,GAChC,MACJ,IAAK,UACDwjC,EAAe7yC,KAAKk0C,iBAAiB7kC,GACrC,MACJ,IAAK,MACDghC,EAAOrwC,KAAKk0C,iBAAiB7kC,GAC7B,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,wCAIlD,IAAI,GAAeojC,EAAcxC,EAAMrkC,GAG1C,0BAA0By2B,GAC9B,MAAMz2B,EAAQ,IAAI4mC,GAWlB,OAVAnQ,EAAiBlzB,WAAWlF,QAAQgF,IAChC,OAAQA,EAAMI,UACV,IAAK,WAED,MACJ,QACIoB,QAAQC,IAAI,2BAA2BzB,EAAMI,+CAIlDzD,EAGH,yBAAyB4oC,GAC7B,IAAI5oC,EAAQ,IAAIgmC,GACZ1rB,EAAO,IAAI,GAkBf,OAjBAsuB,EAAWrlC,WAAWlF,QAAQgF,IAC1B,OAAQA,EAAMI,UACV,IAAK,QACDzD,EAAQhM,KAAK60C,iBAAiBxlC,GAC9B,MACJ,IAAK,OACD,MAAMkX,EAAM,IAAI,GAChBlX,EAAME,WAAWlF,QAAQ+pC,GACrB7tB,EAAIsO,IAAI70B,KAAKk0C,iBAAiBE,KAElC9tB,EAAKuO,IAAItO,GACT,MACJ,QACI1V,QAAQC,IAAI,2BAA2BzB,EAAMI,wCAIlD,IAAI,GAAa6W,EAAMta,GAG1B,wBAAwBy2B,GAC5B,MAAMz2B,EAAQ,IAAIgmC,GAmClB,OAlCAvP,EAAiBlzB,WAAWlF,QAAQgF,IAChC,OAAQA,EAAMI,UACV,IAAK,WACDzD,EAAM8oC,iBAAiBnnC,EAAIgC,eAAeN,IAC1C,MACJ,IAAK,YACDrD,EAAMkmC,gBAAkBvkC,EAAIkC,gBAAgBR,KAAU,EACtD,MACJ,IAAK,QACDrD,EAAMomC,WAAazkC,EAAIoC,eAAeV,IAAU,EAChD,MACJ,IAAK,YACDrD,EAAMmmC,eAAiBnyC,KAAK+0C,uBAAuB1lC,GACnD,MACJ,IAAK,QACDrD,EAAMumC,mBAAqB5kC,EAAIoC,eAAeV,IAAU,EACxD,MACJ,IAAK,QACDrD,EAAMsmC,UAAY3kC,EAAIoC,eAAeV,IAAU,EAC/C,MACJ,IAAK,YACDrD,EAAMqmC,cAAgBryC,KAAK+0C,uBAAuB1lC,GAClD,MACJ,IAAK,QACDrD,EAAMwmC,aAAexyC,KAAKg1C,2BAA2B3lC,GACrD,MACJ,IAAK,WAED,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,+CAIlDzD,EAGH,8BAA8BipC,GAClC,OAAOrxC,EAAkB4R,OAGrB,kCAAkC0/B,GACtC,MAAM7U,EAA+B,GAMrC,OALA6U,EAAY3lC,WAAWlF,QAAQgF,IACJ,SAAnBA,EAAMI,UACN4wB,EAAQ91B,KAAKvK,KAAKm1C,uBAAuB9lC,MAG1CgxB,EAGH,8BAA8B+U,GAClC,MAAMppC,EAAQ,IAAI,GAclB,OAbAopC,EAAW7lC,WAAWlF,QAAQgF,IAC1B,OAAQA,EAAMI,UACV,IAAK,UACDzD,EAAM46B,MAAQj5B,EAAIoC,eAAeV,IAAU,EAC3C,MACJ,IAAK,SACDrD,EAAM8oC,iBAAiBnnC,EAAIgC,eAAeN,IAC1C,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,mDAIlDzD,EAGH,0BAA0BsoC,GAC9B,IAAItoC,EAAQ,IAAIgnC,GACZE,OAAiC/tC,EACjCkrC,OAA+BlrC,EAiBnC,OAhBAmvC,EAAQ/kC,WAAWlF,QAAQgF,IACvB,OAAQA,EAAMI,UACV,IAAK,UACDzD,EAAQhM,KAAKq1C,kBAAkBhmC,GAC/B,MACJ,IAAK,QACD6jC,EAASlzC,KAAKk0C,iBAAiB7kC,GAC/B,MACJ,IAAK,MACDghC,EAAOrwC,KAAKk0C,iBAAiB7kC,GAC7B,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,uCAIlD,IAAI,GAAcyjC,EAAQ7C,EAAMrkC,GAGnC,yBAAyBy2B,GAC7B,MAAMz2B,EAAQ,IAAIgnC,GAclB,OAbAvQ,EAAiBlzB,WAAWlF,QAAQgF,IAChC,OAAQA,EAAMI,UACV,IAAK,YACDzD,EAAMinC,WAAatlC,EAAIkC,gBAAgBR,KAAU,EACjD,MACJ,IAAK,WAED,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,+CAIlDzD,EAGH,sBAAsBw2B,GAC1B,IAAIx2B,OAA8B7G,EAC9B4G,EAAe,GAcnB,OAbAy2B,EAAQjzB,WAAWlF,QAAQgF,IACvB,OAAQA,EAAMI,UACV,IAAK,MACD1D,EAAOsD,EAAMszB,aAAe,GAC5B,MACJ,IAAK,QACD32B,EAAQ,EAAS4K,qBAAqBvH,GACtC,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,wCAIlD,IAAI,GAAU1D,EAAMC,GAAS,IAAI,GAGpC,wBAAwBU,GAC5B,MAAM6tB,EAAU,IAAI,GA+CpB,OA9CA7tB,EAAK6C,WAAWlF,QAAQgF,IACpB,OAAQA,EAAMI,UACV,IAAK,MACD8qB,EAAQ1F,IAAI70B,KAAKk0C,iBAAiB7kC,IAClC,MACJ,IAAK,SACDkrB,EAAQ1F,IAAI70B,KAAKs1C,gBAAgBjmC,IACjC,MACJ,IAAK,MACDkrB,EAAQ1F,IAAI70B,KAAKu1C,qBAAqBlmC,IACtC,MACJ,IAAK,MACDkrB,EAAQ1F,IAAI70B,KAAKw1C,eAAenmC,IAChC,MACJ,IAAK,MACDkrB,EAAQ1F,IAAI70B,KAAKy1C,oBAAoBpmC,IACrC,MACJ,IAAK,MACDkrB,EAAQ1F,IAAI70B,KAAK01C,kBAAkBrmC,IACnC,MACJ,IAAK,SACDkrB,EAAQ1F,IAAI70B,KAAK21C,oBAAoBtmC,IACrC,MACJ,IAAK,QACDkrB,EAAQ1F,IAAI70B,KAAK41C,mBAAmBvmC,IACpC,MACJ,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,cACL,IAAK,UACL,IAAK,aACL,IAAK,WACL,IAAK,WACL,IAAK,UACL,IAAK,SACL,IAAK,SACL,IAAK,YACL,IAAK,SACDwB,QAAQC,IAAI,eAAezB,EAAMI,gCACjC,MACJ,QACIoB,QAAQC,IAAI,gBAAgBzB,EAAMI,0DAIvC8qB,IDnU4Bsb,aAAanpC,GACxCuV,EAAK1X,KAAKypC,MAGlB,MAAM8B,EAAW5zB,GAAgBD,EAAK,GACtC,GAAmB,GAAfA,EAAK3W,QAAewqC,aAAoB,EACxCA,EAASl2B,YAAcxd,EAAWgX,UAC/B,GAAI6I,EAAK3W,OAAS,EAAG,CACpBwqC,aAAoB,IACpBA,EAASl2B,YAAcxd,EAAW+W,OAEtC,MAAM48B,EAAU9zB,EAAKA,EAAK3W,OAAS,GAC/ByqC,aAAmB,IACnBA,EAAQn2B,YAAcxd,EAAWyE,MAGzC,OAAO,IAAI,EAAUob,EAAMC,GAGvB,iBAAiBmZ,EAAiBmY,GACtC,MAAMwC,EAAYroC,EAAIyB,oBAAoBokC,EAAO,SACjD,QAAkBruC,IAAd6wC,EAAyB,CACzB,MAAMjgC,EAAW,EAASwC,wBAAwBy9B,GAGlD,OAFAjgC,EAAS6C,iBAAiByiB,EAAK0Y,QAC/Bh+B,EAASwB,gBAAgB8jB,EAAK5qB,YACvBsF,EAEX,OAAO,IAAI,GEvFZ,MAAM,GAWT,YAAYomB,EAAemC,GATnB,KAAAzX,KAA8B,GAUlC7mB,KAAKm8B,KAAOA,EACZn8B,KAAKs+B,KAAOA,EAGT,eACH,GAAyB,IAArBt+B,KAAK6mB,KAAKvb,OAAc,CACxB,MAAMkD,EAAMb,EAAIyB,oBAAoBpP,KAAKs+B,KAAKnyB,SAAU,cACxD,QAAYhH,IAARqJ,EAAmB,CACnB,MAAMd,EAAOC,EAAIyB,oBAAoBZ,EAAK,eAC7BrJ,IAATuI,GACAA,EAAK6B,WAAWlF,QAAQqC,IACpB,OAAOA,EAAK+C,UACR,IAAK,MACDzP,KAAK6mB,KAAKtc,KAAK,GAAgBgpC,cAAcvzC,KAAM0M,IACnD,MACJ,IAAK,QACD1M,KAAK6mB,KAAKtc,KC3BnC,MACI,iBAAiB8wB,EAAiB4a,GACrC,MAAMp7B,EAAQ,IAAI,GAAMwgB,GACxB,IAAI8F,EAAW/+B,EAAW+W,MAmC1B,OAlCA88B,EAAU1mC,WAAWlF,QAAQgF,IACzB,OAAOA,EAAMI,UACT,IAAK,OACD,MAAM8W,EAAMvmB,KAAKk2C,aAAa7mC,EAAOwL,GACrC0L,EAAI4vB,SAAShV,GACbtmB,EAAMyL,KAAK/b,KAAKgc,GAChB4a,EAAW/+B,EAAWwE,OACtB,MACJ,IAAK,UACDiU,EAAM7O,MAAQhM,KAAKo2C,eAAe/mC,GAClC,MACJ,IAAK,YACD,IAAInK,EAAQ,EACZmK,EAAME,WAAWlF,QAAQ83B,IACrB,GAAqB,cAAjBA,EAAI1yB,SAA0B,CAC9B,MAAM4mC,EAAI1oC,EAAIqB,aAAamzB,EAAK,OAChC,QAAUh9B,IAANkxC,EAAiB,CACjB,MAAM7xC,EAAQ+G,EAAQG,qBAAqB4E,SAAS+lC,IACpDx7B,EAAMwlB,QAAQ91B,KAAK,IAAI02B,GAAY/7B,EAAOV,IAC1CU,GAASV,MAIrB,MACJ,QACIqM,QAAQC,IAAI,2BAA2BzB,EAAMI,qCAI/B,IAAtBoL,EAAMyL,KAAKhb,OACXuP,EAAMyL,KAAK,GAAG6vB,SAAS/zC,EAAWgX,MAElCyB,EAAMyL,KAAKzL,EAAMyL,KAAKhb,OAAS,GAAG6qC,SAAS/zC,EAAWyE,MAEnDgU,EAGH,oBAAoBy7B,EAAoBz7B,GAC5C,MAAM0L,EAAM,IAAI,GAAS1L,GACnB07B,EAAW,IAAI,GACrBA,EAASnW,YAAcvlB,EAAM7O,MAC7B,IAAIwqC,EAAW,EAQf,OAPAF,EAAQ/mC,WAAWlF,QAAQosC,IACvB,GAA0B,SAAtBA,EAAShnC,SAAqB,CAC9B,MAAMgX,EAAOzmB,KAAK02C,cAAcD,EAAU57B,EAAO07B,EAAUC,GAC3DA,GAAY/vB,EAAK8b,WACjBhc,EAAIC,MAAMjc,KAAKkc,MAGhBF,EAGH,qBAAqBkwB,EAAqB57B,EAAc07B,EAAsBC,GAClF,MAAMxqC,EAAQ,IAAI,GACZya,EAAO,IAAI,GAAU5L,EAAMwlB,QAASr0B,EAAOwqC,GACjDC,EAASlnC,WAAWlF,QAAQgF,IACxB,OAAOA,EAAMI,UACT,IAAK,MACD,MAAMqX,EAAM,GAAgBysB,cAAc14B,EAAMwgB,KAAMhsB,GACtDyX,EAAItE,KAAOzf,EAAc2b,UACzB+H,EAAKI,KAAKtc,KAAKuc,GACf,MACJ,IAAK,SACD9mB,KAAK22C,0BAA0BtnC,EAAOknC,EAAUvqC,GAChD,MACJ,QACI6E,QAAQC,IAAI,2BAA2BzB,EAAMI,yCAIzD,MAAM3E,EAAK6C,EAAIqB,aAAaynC,EAAU,QAItC,YAHWtxC,IAAP2F,IACA2b,EAAK3b,GAAKA,GAEP2b,EAGH,iCAAiCmwB,EAAuBL,EAAsBM,GAClFA,EAAUzW,YAAcmW,EACxBK,EAAWrnC,WAAWlF,QAAQgF,IAC1B,OAAQA,EAAMI,UACV,IAAK,QACD,MAAM4mC,EAAI1oC,EAAIqB,aAAaK,EAAO,YACxBlK,IAANkxC,IACAQ,EAAUryC,MAAQ+G,EAAQG,qBAAqB4E,SAAS+lC,KAE5D,MACJ,IAAK,aACD,MAAMvW,EAAanyB,EAAIgC,eAAeN,QACnBlK,IAAf26B,IACA+W,EAAU/W,WAAaxvB,SAASwvB,IAEpC,MACJ,IAAK,cACD+W,EAAUzvB,QAAUpnB,KAAK82C,YAAYznC,GACrC,MACJ,IAAK,UACDwnC,EAAU9xC,QAAU/E,KAAK+2C,gBAAgB1nC,GACzC,MACJ,IAAK,QACD,MAAM2X,EAAUrZ,EAAIqB,aAAaK,EAAO,eACxBlK,IAAZ6hB,IACA6vB,EAAU7vB,QAAUA,GAExB,MACJ,IAAK,WACD,IAAIgZ,EAAU59B,EAAWwE,OACzB,MAAMowC,EAASrpC,EAAIgC,eAAeN,QACnBlK,IAAX6xC,GAAmC,YAAXA,IACxBhX,EAAU59B,EAAW+W,OAEzB09B,EAAUnW,aAAeV,EACzB,MACJ,IAAK,WAED,MACJ,QACInvB,QAAQC,IAAI,2BAA2BzB,EAAMI,gDAMrD,mBAAmBwnC,GACvB,MAAM7vB,EAAU,IAAI,GA6BpB,OA5BA6vB,EAAY1nC,WAAWlF,QAAQqC,IAE3B,OADaA,EAAK+C,UAEd,IAAK,SACL,IAAK,UACD2X,EAAQhiB,YAAcpF,KAAKk3C,gBAAgBxqC,GAC3C,MACJ,IAAK,UACL,IAAK,QACD0a,EAAQ5hB,UAAYxF,KAAKk3C,gBAAgBxqC,GACzC,MACJ,IAAK,QACD0a,EAAQ1hB,UAAY1F,KAAKk3C,gBAAgBxqC,GACzC,MACJ,IAAK,WACD0a,EAAQxhB,aAAe5F,KAAKk3C,gBAAgBxqC,GAC5C,MACJ,IAAK,YACD0a,EAAQ+vB,iBAAmBn3C,KAAKk3C,gBAAgBxqC,GAChD,MACJ,IAAK,YACD0a,EAAQgwB,eAAiBp3C,KAAKk3C,gBAAgBxqC,GAC9C,MACJ,QACImE,QAAQC,IAAI,2BAA2BpE,EAAK+C,6CAIjD2X,EAGH,uBAAuBiwB,GAC3B,MAAMtyC,EAAU,IAAI,GA6CpB,OA5CAsyC,EAAe9nC,WAAWlF,QAAQqC,IAE9B,OADaA,EAAK+C,UAEd,IAAK,SACD,MAAM/K,EAAOiJ,EAAIqB,aAAatC,EAAM,YACvBvH,IAATT,IACAK,EAAQO,gBAAkBiG,EAAQG,qBAAqB4E,SAAS5L,KAEpE,MACJ,IAAK,UACD,MAAMQ,EAAQyI,EAAIqB,aAAatC,EAAM,YACvBvH,IAAVD,IACAH,EAAQO,gBAAkBiG,EAAQG,qBAAqB4E,SAASpL,KAEpE,MACJ,IAAK,UACD,MAAMN,EAAQ+I,EAAIqB,aAAatC,EAAM,YACvBvH,IAAVP,IACAG,EAAQU,cAAgB8F,EAAQG,qBAAqB4E,SAAS1L,KAElE,MACJ,IAAK,QACD,MAAMW,EAAMoI,EAAIqB,aAAatC,EAAM,YACvBvH,IAARI,IACAR,EAAQU,cAAgB8F,EAAQG,qBAAqB4E,SAAS/K,KAElE,MACJ,IAAK,QACD,MAAMZ,EAAMgJ,EAAIqB,aAAatC,EAAM,YACvBvH,IAARR,IACAI,EAAQY,cAAgB4F,EAAQG,qBAAqB4E,SAAS3L,KAElE,MACJ,IAAK,WACD,MAAME,EAAS8I,EAAIqB,aAAatC,EAAM,YACvBvH,IAAXN,IACAE,EAAQc,iBAAmB0F,EAAQG,qBAAqB4E,SAASzL,KAErE,MACJ,QACIgM,QAAQC,IAAI,2BAA2BpE,EAAK+C,kDAIjD1K,EAGH,uBAAuBuyC,GAE3B,MAAM5vB,EAAS,IAAIzB,EACbnX,EAAMnB,EAAIqB,aAAasoC,EAAY,cAC7BnyC,IAAR2J,IACA4Y,EAAOlF,KAAOxiB,KAAKu3C,qBAAqBzoC,IAE5C,MAAM0oC,EAAK7pC,EAAIqB,aAAasoC,EAAY,aAC7BnyC,IAAPqyC,IAEA9vB,EAAOriB,KAAOkG,EAAQK,qBAAqB0E,SAASknC,EAAI,IAAM,IAElE,MAAM5tB,EAAQjc,EAAIqB,aAAasoC,EAAY,gBAC7BnyC,IAAVykB,IACAlC,EAAO3hB,QAAUwF,EAAQG,qBAAqB4E,SAASsZ,EAAO,MAElE,MAAM5P,EAAQrM,EAAIqB,aAAasoC,EAAY,WAI3C,YAHcnyC,IAAV6U,IACA0N,EAAO1N,MAAQA,GAEZ0N,EAGH,4BAA4B+vB,GAChC,IAAIC,EAAaz0C,EAAgBoE,KACjC,OAAOowC,GACH,IAAK,SACDC,EAAaz0C,EAAgBuS,OAC7B,MACJ,IAAK,iBACDkiC,EAAaz0C,EAAgBslB,eAC7B,MACJ,IAAK,SACDmvB,EAAaz0C,EAAgB6iB,OAC7B,MACJ,IAAK,eACD4xB,EAAaz0C,EAAgBulB,aAC7B,MACJ,IAAK,UACDkvB,EAAaz0C,EAAgBkS,QAC7B,MACJ,IAAK,aACDuiC,EAAaz0C,EAAgBmS,WAC7B,MACJ,IAAK,SACDsiC,EAAaz0C,EAAgBoS,OAC7B,MACJ,IAAK,SACDqiC,EAAaz0C,EAAgBsS,OAC7B,MACJ,IAAK,aACDmiC,EAAaz0C,EAAgB00C,WAC7B,MACJ,IAAK,QACDD,EAAaz0C,EAAgB20C,MAC7B,MACJ,IAAK,SACDF,EAAaz0C,EAAgB40C,OAC7B,MACJ,IAAK,QACDH,EAAaz0C,EAAgBwS,MAC7B,MACJ,IAAK,oBACDiiC,EAAaz0C,EAAgB6kB,kBAC7B,MACJ,IAAK,qBACD4vB,EAAaz0C,EAAgB8kB,mBAC7B,MACJ,IAAK,oBACD2vB,EAAaz0C,EAAgB+kB,kBAC7B,MACJ,IAAK,oBACD0vB,EAAaz0C,EAAgBglB,kBAC7B,MACJ,IAAK,qBACDyvB,EAAaz0C,EAAgBilB,mBAC7B,MACJ,IAAK,oBACDwvB,EAAaz0C,EAAgBklB,kBAC7B,MACJ,IAAK,wBACDuvB,EAAaz0C,EAAgBmlB,sBAC7B,MACJ,IAAK,yBACDsvB,EAAaz0C,EAAgBolB,uBAC7B,MACJ,IAAK,wBACDqvB,EAAaz0C,EAAgBqlB,sBAC7B,MACJ,IAAK,eACDovB,EAAaz0C,EAAgB60C,SAC7B,MACJ,IAAK,gBACDJ,EAAaz0C,EAAgB80C,UAC7B,MACJ,IAAK,SACDL,EAAaz0C,EAAgB4kB,OAC7B,MACJ,IAAK,OACD6vB,EAAaz0C,EAAgByS,KAC7B,MACJ,IAAK,OACL,IAAK,MACL,QACIgiC,EAAaz0C,EAAgBoE,KAGrC,OAAOqwC,EAGH,sBAAsBM,GAC1B,MAAMhsC,EAAQ,IAAI,GAqClB,OApCAgsC,EAAUzoC,WAAWlF,QAAQgF,IACzB,OAAQA,EAAMI,UACV,IAAK,eACDzD,EAAMob,QAAUpnB,KAAK82C,YAAYznC,GACjC,MACJ,IAAK,eACDrD,EAAMjH,QAAU/E,KAAK+2C,gBAAgB1nC,GACrC,MACJ,IAAK,OACD,MAAM8C,EAAgBxE,EAAIgC,eAAeN,QACnBlK,IAAlBgN,IACAnG,EAAMmG,cAAgBxP,EAAcwP,IAExC,MACJ,IAAK,WACD,MAAMkkC,EAAI1oC,EAAIqB,aAAaK,EAAO,YACxBlK,IAANkxC,IACArqC,EAAMkN,WAAa3N,EAAQG,qBAAqB4E,SAAS+lC,EAAG,MAEhE,MACJ,IAAK,gBACD,MAAMtwC,EAAU4H,EAAIqB,aAAaK,EAAO,YACxBlK,IAAZY,IACAiG,EAAMsb,YAAc/b,EAAQG,qBAAqB4E,SAASvK,EAAS,MAEvE,MACJ,IAAK,SACL,IAAK,aACL,IAAK,YAED,MACJ,QACI8K,QAAQC,IAAI,2BAA2BzB,EAAMI,2CAIlDzD,ID1U4CisC,UAAUj4C,KAAM0M,IAC3C,MACJ,IAAK,WACD1M,KAAKk4C,SAAW,IAAI,GAAQl4C,KAAM0M,GAClC,MACJ,IAAK,QACD,MAAMyrC,EAAU,GAAgBC,0BAA0Bp4C,KAAM0M,GAChE1M,KAAK6mB,KAAKtc,QAAQ4tC,GAClB,MACJ,QACItnC,QAAQC,IAAI,2BAA2BpE,EAAK+C,0CASjE,cAActH,GACjBnI,KAAK++B,eACL/+B,KAAK6mB,KAAKxc,QAAQyc,IACdA,EAAI9D,cAAc7a,KAI1B,oBACI,OAAOnI,KAAKq4C,MAGhB,aACI,OAAOr4C,KAAKs4C,QAGhB,iBACI,OAAOt4C,KAAKu4C,YAGhB,qBACI,OAAOv4C,KAAKw4C,gBAGT,iBAAiBtV,GACpBljC,KAAKq4C,MAAQnV,EAGV,eAAe6Q,GAClB/zC,KAAKs4C,QAAUvE,EAGZ,cAActjC,GACjBzQ,KAAKu4C,YAAc9nC,EAGhB,kBAAkBgoC,GACrBz4C,KAAKw4C,gBAAkBC,EAG3B,iBACI,OAAOz4C,KAAK6mB,KAGhB,cACI,OAAO7mB,KAAKk4C,WzEtGpB,SAAYr0C,GACR,cACA,kBACA,8BACA,oBACA,oBACA,gDACA,oDACA,oDACA,4BACA,4BACA,0BACA,4BACA,4BACA,0BAdJ,CAAYA,MAAe,KAiB3B,SAAYC,GACR,oBACA,gBACA,YAHJ,CAAYA,MAAe,KAMpB,MAAM,GAmDT,YAAYkH,GAjDL,KAAAgB,MAAe,IAAI,EACnB,KAAA0sC,OAA0B70C,EAAgB80C,KAC1C,KAAAzzC,WAA4BC,EAC5B,KAAAyzC,OAA0B90C,EAAgB6c,IAC1C,KAAA5U,UAA2B5G,EAmG1B,KAAA0zC,YAAc,CAClB,CAAC,GAAG,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,MAAM,OAAO,MAC9C,CAAC,GAAG,IAAI,KAAK,MAAO,KAAM,IAAK,KAAM,MAAO,OAAQ,MACpD,CAAC,GAAG,IAAI,KAAK,MAAM,KAAK,IAAI,KAAK,MAAM,OAAO,OAxD9C74C,KAAKgL,MAAQA,EA5CV,qBAAqBgJ,EAAsC8kC,GAC9D,MAAM3oC,EAAYxC,EAAIqB,aAAa8pC,EAAW,UAC9C,QAAkB3zC,IAAdgL,EACA,OAEJ,MAAMnF,EAAQsF,SAASH,EAAW,IAC5BtF,EAAQ,IAAI,GAAeG,GAkCjC,OAjCAH,EAAMmB,MAAQ,EAAM0yB,cAAcoa,GAClCjuC,EAAMmB,MAAM4M,iBAAiB5E,GAC7B8kC,EAAUvpC,WAAWlF,QAAQgF,IACzB,OAAQA,EAAMI,UACV,IAAK,UACD5E,EAAM3F,MAAQyI,EAAIoC,eAAeV,GACjC,MACJ,IAAK,SACD,MAAMupC,EAASjrC,EAAIgC,eAAeN,QACnBlK,IAAXyzC,IACA/tC,EAAM+tC,OAAS90C,EAAgB80C,IAEnC,MACJ,IAAK,WACD,MAAMF,EAAS/qC,EAAIgC,eAAeN,QACnBlK,IAAXuzC,IACA7tC,EAAM6tC,OAAS70C,EAAgB60C,IAEnC,MACJ,IAAK,YACD7tC,EAAMkB,KAAO4B,EAAIgC,eAAeN,GAChC,MACJ,IAAK,UACL,IAAK,QACL,IAAK,QACL,IAAK,WAED,MACJ,QACIwB,QAAQC,IAAI,2BAA2BzB,EAAMI,+CAIlD5E,EAOJ,QAAQ0F,GAKX,OAAOvQ,KAAK+4C,aAAaxoC,GAGrB,aAAaA,GACjB,IAAIxE,EACJ,OAAQ/L,KAAK04C,QACT,KAAK70C,EAAgBm1C,OACjBjtC,EAAO,WAEPA,EAAO,IACP,MACJ,KAAKlI,EAAgB80C,KACjB5sC,EAAO,GACP,MACJ,KAAKlI,EAAgBo1C,QACjBltC,EAAOwE,EAAQ8P,IAAIiC,GAAOA,EAAIlO,YAAYiJ,KAAK,KAC/C,MACJ,KAAKxZ,EAAgBq1C,YACjBntC,EAAOwE,EAAQ8P,IAAIrgB,KAAKm5C,YAAY97B,KAAK,KACzC,MACJ,KAAKxZ,EAAgBu1C,YACjBrtC,EAAOwE,EAAQ8P,IAAIrgB,KAAKm5C,YAAY97B,KAAK,KAAKiD,oBAC9C,MACJ,KAAKzc,EAAgBw1C,WACjBttC,EAAOwE,EAAQ8P,IAAIrgB,KAAKs5C,UAAUj8B,KAAK,KACvC,MACJ,KAAKxZ,EAAgB01C,WACjBxtC,EAAOwE,EAAQ8P,IAAIrgB,KAAKs5C,UAAUj8B,KAAK,KAAKiD,oBAC5C,MACJ,QACIzP,QAAQC,IAAI,6CAA6C9Q,KAAK04C,QAC9D3sC,EAAO,IAGf,OAAOA,EAGH,WAAWu6B,GACf,OAAIA,EAAM,GACCtmC,KAAKm5C,WAAW7S,EAAM,IAAMtmC,KAAKm5C,WAAW7S,EAAM,IAGtDkT,OAAOC,aAAa,GAAKrzC,KAAK2V,MAAMuqB,IAQvC,SAASA,GACb,IAAIoT,EAAU,GACVC,EAASrT,EAAIlyB,WAAWI,MAAM,IAAI2X,UACtC,IAAK,IAAI/rB,EAAI,EAAGA,EAAIu5C,EAAOruC,OAAQlL,IAC/Bs5C,EAAU15C,KAAK64C,YAAYz4C,GAAGkQ,SAASqpC,EAAOv5C,KAAOs5C,EAEzD,OAAOA,G2E5IR,MAAM,GAAb,cACY,KAAAE,QAA4B,GAK7B,2BAA2B7F,EAAiCrnC,GAC/D,MAAMgE,EAAY,IAAI,GAStB,OARAhE,EAAK6C,WAAWlF,QAAQyuC,IACpB,GAA2B,UAAvBA,EAAUrpC,SAAsB,CAChC,MAAM5E,EAAQ,GAAegvC,cAAc9F,EAAQ+E,QACrC3zC,IAAV0F,IACA6F,EAAUkpC,QAAQ/uC,EAAMG,OAASH,MAItC6F,EAGJ,SAAS1F,GACZ,OAAOhL,KAAK45C,QAAQ5uC,IClBrB,MAAM,GAKT,YAAYszB,GAFJ,KAAAia,YAA2B,GAG/Bv4C,KAAKwO,IAAM8vB,EAAKnyB,SAGb,aAAa4nC,GAChB,GAAgC,IAA5B/zC,KAAKu4C,YAAYjtC,OAAc,CAC/B,MAAM5L,EAAOiO,EAAIyB,oBAAoBpP,KAAKwO,IAAK,eAC/C,QAAarJ,IAATzF,EAAoB,CACpB,MAAMo6C,EAAkC,GACxCp6C,EAAK6P,WAAWlF,QAAQqC,IACpB,GAAsB,kBAAlBA,EAAK+C,SAA8B,CACnC,MAAMsqC,EAAgBpsC,EAAIqB,aAAatC,EAAM,mBAC7C,QAAsBvH,IAAlB40C,EAA6B,CAC7B,MAAMrpC,EAAY,GAAUspC,oBAAoBjG,EAAQrnC,GACxDotC,EAAmBxpC,SAASypC,IAAkBrpC,MAI1DhR,EAAK6P,WAAWlF,QAAQ4vC,IACpB,GAAyB,UAArBA,EAAQxqC,SAAsB,CAC9B,MAAM7E,EAAQ+C,EAAIqB,aAAairC,EAAS,WAClCF,EAAgBpsC,EAAI2gC,uBAAuB2L,EAAS,wBAC5C90C,IAAVyF,QAAyCzF,IAAlB40C,IACvB/5C,KAAKu4C,YAAYjoC,SAAS1F,IAAUkvC,EAAmBC,SAQxE,iBAAiBnvC,GACpB,OAAO5K,KAAKu4C,YAAY3tC,ICxCzB,MAAM,GAAb,cACY,KAAAsvC,UAA6D,GAE9D,oBAAoB1rC,GACvB,MAAM00B,EAAgB,IAAI,GAa1B,OAZA10B,EAAI+uB,cAAchuB,WAAWlF,QAAQ8vC,IACjCA,EAAS5qC,WAAWlF,QAAQ+vC,IACxB,GAAyB,iBAArBA,EAAQ3qC,SAA6B,CACrC,MAAM3E,EAAK6C,EAAIqB,aAAaorC,EAAS,MAC/Bzd,EAAShvB,EAAIqB,aAAaorC,EAAS,UACnC53B,EAAO7U,EAAIqB,aAAaorC,EAAS,aAC5Bj1C,IAAP2F,QAA+B3F,IAAXw3B,QAAiCx3B,IAATqd,IAC5C0gB,EAAcgX,UAAUpvC,GAAM,CAAE6xB,OAAQA,EAAQna,KAAMA,SAK/D0gB,EAGJ,UAAUp4B,GACb,OAAO9K,KAAKk6C,UAAUpvC,GAAI6xB,QCjB3B,MAAM,GAAb,cACY,KAAA0d,aAAe,IAAI,GAEpB,2BAA2B7rC,GAC9BA,EAAI+uB,cAAc6J,WAAY73B,WAAWlF,QAASgF,IAC1CA,EAAMq4B,WAAaC,KAAKC,cACxB5nC,KAAKs6C,0BAA0BjrC,KAKpC,0BAA0BkrC,GAC7B,MAAMxoB,EAAQ,IAAI,GAClBwoB,EAAQhrC,WAAWlF,QAAQgF,IACvB,OAAQA,EAAMI,UACV,IAAK,QAGL,IAAK,QACDzP,KAAKw6C,oBAAoBnrC,EAAO0iB,GAChC,MACJ,IAAK,UACD/xB,KAAKy6C,cAAcprC,EAAO0iB,GAC1B,MACJ,IAAK,QACL,IAAK,OACL,IAAK,SACL,IAAK,QAED,MACJ,QACIlhB,QAAQC,IAAI,gBAAgBzB,EAAMI,+DAI9Co3B,GAAmB6T,YAAYH,EAAQ9qC,SAAUsiB,GAG7C,oBAAoB4oB,EAA0B5oB,GAClD4oB,EAAmBprC,WAAWlF,QAAQgF,IAC9BA,EAAMq4B,WAAaC,KAAKC,cACxB5nC,KAAK46C,gBAAgBvrC,EAAO0iB,KAKhC,gBAAgB8oB,EAAsB9oB,GAC1C,MAAM+oB,EAAOntC,EAAIqB,aAAa6rC,EAAgB,QACxCl6C,EAAOgN,EAAIqB,aAAa6rC,EAAgB,aACjC11C,IAAT21C,QAA+B31C,IAATxE,GACtBoxB,EAAM3B,MAAM2qB,WAAWD,EAAMn6C,GAI7B,cAAc6nC,EAAoBzW,GACtCyW,EAAaj5B,WAAWlF,QAAQg9B,IACxBA,EAASK,WAAaC,KAAKC,cAC3B5nC,KAAKq6C,aAAa5R,SAASpB,EAAUtV,MC9D9C,MAAMipB,GAAb,cACW,KAAAjU,aAA8B5hC,EAC9B,KAAA81C,aAA4B91C,EAC5B,KAAA+1C,iBAAkC/1C,EAClC,KAAAg2C,cAA+Bh2C,EAC/B,KAAAi2C,oBAAqCj2C,EACrC,KAAAk2C,kBAAiCl2C,EACjC,KAAAm2C,iBAAgCn2C,EAChC,KAAAo2C,cAA+Bp2C,EAC/B,KAAAq2C,aAA8Br2C,EAC9B,KAAAs2C,WAA4Bt2C,EAC5B,KAAAu2C,cAA+Bv2C,EAE/B,oBAAoBqJ,GACvB,MAAMiqC,EAAiB,IAAIuC,GA4C3B,OA3CAxsC,EAAI+uB,cAAchuB,WAAWlF,QAAQsxC,IACjCA,EAAUpsC,WAAWlF,QAAQuxC,IACzB,MAAM7vC,EAAiC,OAAzB6vC,EAASjZ,YAAwB,GAAKiZ,EAASjZ,YAC7D,OAAQiZ,EAASnsC,UACb,IAAK,kBACDgpC,EAAewC,QAAUD,GAAea,iBAAiB9vC,GACzD,MACJ,IAAK,aACD0sC,EAAe1R,QAAUh7B,EACzB,MACJ,IAAK,iBACD0sC,EAAeyC,YAAcnvC,EAC7B,MACJ,IAAK,cACD0sC,EAAe0C,SAAWpvC,EAC1B,MACJ,IAAK,oBACD0sC,EAAe2C,eAAiBrvC,EAChC,MACJ,IAAK,mBACD0sC,EAAe4C,aAAeL,GAAea,iBAAiB9vC,GAC9D,MACJ,IAAK,iBACD0sC,EAAe6C,YAAcN,GAAea,iBAAiB9vC,GAC7D,MACJ,IAAK,cACD0sC,EAAe8C,SAAWjrC,SAASvE,GACnC,MACJ,IAAK,aACD0sC,EAAe+C,QAAUzvC,EACzB,MACJ,IAAK,WACD0sC,EAAegD,MAAQ1vC,EACvB,MACJ,IAAK,cACD0sC,EAAeiD,SAAW3vC,EAC1B,MACJ,QACI8E,QAAQC,IAAI,yBAAyB8qC,EAASnsC,6CAKvDgpC,EAGH,wBAAwB1sC,GAS5B,MAAM+vC,EAAOxrC,SAASvE,EAAKsqB,OAAO,EAAG,IAC/B0lB,EAAShwC,EAAKT,QAAU,EAAK,EAAIgF,SAASvE,EAAKsqB,OAAO,EAAG,IACzD2lB,EAAOjwC,EAAKT,QAAU,EAAK,EAAIgF,SAASvE,EAAKsqB,OAAO,EAAG,IAC7D,IAAI4lB,EAAO,EACP51C,EAAM,EACN61C,EAAM,EAOV,OALInwC,EAAKT,OAAS,KACd2wC,EAAO3rC,SAASvE,EAAKsqB,OAAO,GAAI,IAChChwB,EAAMiK,SAASvE,EAAKsqB,OAAO,GAAI,IAC/B6lB,EAAM5rC,SAASvE,EAAKsqB,OAAO,GAAI,KAE5B,IAAI8lB,KAAKA,KAAKC,IAAIN,EAAMC,EAAQ,EAAGC,EAAKC,EAAM51C,EAAK61C,EAN5C,KClEf,MAAM,GAGT,YAAYhwC,GACRlM,KAAKylC,SAAW,IAAI,GAASv5B,GAG1B,gBAAgB0B,GACnB5N,KAAKq8C,QACL,GAAQC,YAAY1uC,GAAKwX,KAAM+W,IAC3Bn8B,KAAKu8C,iBAAiBpgB,KACvB3W,MAAO4W,IACNvrB,QAAQC,IAAI,kBAAkBlD,MAAQwuB,OAIvC,kBAAkBC,GACrBr8B,KAAKq8C,QACL,GAAQG,aAAangB,GAAOjX,KAAM+W,IAC9Bn8B,KAAKu8C,iBAAiBpgB,KAItB,iBAAiBA,GACrBA,EAAKkB,cAAc,gCAAgCjY,KAAKq3B,IACpD,MAAMvZ,EAAgB,GAAcwZ,aAAaD,EAAQtwC,UACzDgwB,EAAKkB,cAAc,mBAAmBjY,KAAKu3B,IACvC,MAAM5I,EAAS,IAAI,GAAY4I,GAC/B5I,EAAOhV,eACP5C,EAAKkB,cAAc,qBAAqBjY,KAAKw3B,IACzC,MAAMnE,EAAiBuC,GAAe0B,aAAaE,EAAKzwC,UACpDgwB,EAAK0gB,QAAQ,sBACb1gB,EAAKkB,cAAc,sBAAsBjY,KAAK03B,IAC1C,MAAMrsC,EAAa,IAAI,GAAmBqsC,GAC1CrsC,EAAWsuB,aAAagV,GACxB/zC,KAAK+8C,cAAc5gB,EAAM+G,EAAe6Q,EAAQ0E,EAAgBhoC,KAGpEzQ,KAAK+8C,cAAc5gB,EAAM+G,EAAe6Q,EAAQ0E,OAAgBtzC,SAO5E,cACJg3B,EACA+G,EACA6Q,EACA0E,EACAhoC,GAEA0rB,EAAKkB,cAAc,qBAAqBjY,KAAKkZ,IACzC,MAAMjD,EAAO,IAAI,GAAUc,EAAMmC,GACjCjD,EAAK2hB,iBAAiB9Z,GACtB7H,EAAK4hB,eAAelJ,GACpB1Y,EAAK6hB,kBAAkBzE,QACJtzC,IAAfsL,GACA4qB,EAAK8hB,cAAc1sC,GAEvB4qB,EAAK0D,eACL,MAAMqe,EAAOp9C,KAAKylC,SAAS4X,eAAehiB,GAC1Cr7B,KAAKylC,SAAS5J,aAAauhB,KAI3B,QACJ7xC,EAAQ+xC,OACRt9C,KAAKylC,SAAS7J,QACdjuB,EAAI2uC,YAAY,gCAAgCl3B,KAAK5W,KACjD,IAAI,IAAoB+uC,2BAA2B/uC,KACpDgX,MAAM,KACL3U,QAAQC,IAAI","file":"potlood.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Potlood\"] = factory();\n\telse\n\t\troot[\"Potlood\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export enum InSequence {\r\n    Middle = 0,\r\n    First = 1,\r\n    Last = 2,\r\n    Only = 3,\r\n    Special = 4\r\n}\r\n","import { Box } from \"../utils/geometry/box\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { Point } from \"../utils/geometry/point\";\r\n\r\nexport enum ShapeAnchorMode {\r\n    /** Inline with the text */\r\n    Inline,\r\n    /** Floating on top of text */\r\n    Floating\r\n}\r\n\r\nexport enum ShapePositionReference {\r\n    /** Not relative to any outside element */\r\n    None,\r\n    /** Relative to the current position in the run. X coordinate: character, Y coordinate: line */\r\n    Character,\r\n    /** Relative to the extents of the column containing this anchor, X coordinate only */\r\n    Column,\r\n    /** Relative to the Bottom or Right margin */\r\n    EndMargin,\r\n    /** Relative to the inside margin. X coordinate: left for oddpages, right for even pages. */\r\n    InsideMargin,\r\n    /** Relative to the page margins */\r\n    Margin,\r\n    /** Relative to the outside margin. X coordinate: right for oddpages, left for even pages. */\r\n    OutsideMargin,\r\n    /** Relative to the edge of the page */\r\n    Page,\r\n    /** Relative to the Paragraph containing this anchor. Y coordinate only. */\r\n    Paragraph,\r\n    /** Relative to the Top or Left margin */\r\n    StartMargin\r\n}\r\n\r\nexport enum ShapePositionAlignMode {\r\n    /** Align with Right or Bottom of its Reference */\r\n    End,\r\n    /** Align with Center of its Reference */\r\n    Center,\r\n    /** Align with Inside of its Reference */\r\n    Inside,\r\n    /** Align with Outside of its Reference */\r\n    Outside,\r\n    /** Align with Left or Top of its Reference */\r\n    Start\r\n}\r\n\r\nexport class ShapeBounds {\r\n    public offsetX: number = 0;\r\n    public offsetY: number = 0;\r\n    public referenceX = ShapePositionReference.None;\r\n    public referenceY = ShapePositionReference.None;\r\n    public referenceOffsetX: number = 0;\r\n    public referenceOffsetY: number = 0;\r\n    public alignX = ShapePositionAlignMode.Start;\r\n    public alignY = ShapePositionAlignMode.Start;\r\n    public sizeX: number = 0;\r\n    public sizeY: number = 0;\r\n    public flipHorizontal = false;\r\n    public flipVertical = false;\r\n    public rotation = 0;\r\n    public anchor = ShapeAnchorMode.Inline;\r\n\r\n    public getBox(flow: VirtualFlow): Box {\r\n        const start = this._getStartPoint(flow);\r\n        return new Box(start.x, start.y, this.sizeX, this.sizeY);\r\n    }\r\n\r\n    private _getStartPoint(flow: VirtualFlow): Point {\r\n        let x = flow.getReferenceX(this.referenceX, this.sizeX);\r\n        let y = flow.getReferenceY(this.referenceY);\r\n        switch (this.referenceX) {\r\n            case ShapePositionReference.None:\r\n                x += this.offsetX;\r\n                break;\r\n            case ShapePositionReference.Column:\r\n            default:\r\n                x += this.referenceOffsetX;\r\n                break;\r\n        }\r\n        switch (this.referenceY) {\r\n            case ShapePositionReference.None:\r\n                y += this.offsetY;\r\n                break;\r\n            case ShapePositionReference.Paragraph:\r\n            default:\r\n                y += this.referenceOffsetY;\r\n                break;\r\n        }\r\n        return new Point(x, y);\r\n    }\r\n}","import { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { Metrics } from \"../utils/metrics\";\r\nimport { Justification } from \"./par-style\";\r\n\r\nexport enum TabLeader {\r\n    None,\r\n    Dot\r\n}\r\n\r\nexport enum TabAlignment {\r\n    Clear,\r\n    Left,\r\n    Right,\r\n    Center,\r\n    Numbering\r\n}\r\n\r\nexport class TabStop {\r\n    public position: number | undefined = undefined;\r\n    public leader: TabLeader = TabLeader.None;\r\n    private _pos: number;\r\n    private _alignment: TabAlignment;\r\n\r\n    public static fromTabsNode(tabsNode: Node): TabStop[] {\r\n        const stops: TabStop[] = [];\r\n        tabsNode.childNodes.forEach(tabNode => {\r\n            const alignStr = Xml.getStringValue(tabNode);\r\n            const leaderAttr = Xml.getAttribute(tabNode, \"w:leader\");\r\n            const posAttr = Xml.getAttribute(tabNode, \"w:pos\");\r\n            if (alignStr !== undefined && posAttr !== undefined) {\r\n                const alignment = this._readTabAlignment(alignStr);\r\n                const leader = this._readTabLeader(leaderAttr);\r\n                const pos = Metrics.convertTwipsToPixels(parseInt(posAttr));\r\n                const stop = new TabStop(pos, alignment, leader);\r\n                stops.push(stop);\r\n            }\r\n        });\r\n        return stops;\r\n    }\r\n\r\n    private static _readTabAlignment(align: string): TabAlignment {\r\n        let alignment = TabAlignment.Left;\r\n        switch (align.toLowerCase()) {\r\n            case \"num\":\r\n                alignment = TabAlignment.Numbering;\r\n                break;\r\n            case \"center\":\r\n                alignment = TabAlignment.Center;\r\n                break;\r\n            case \"clear\":\r\n                alignment = TabAlignment.Clear;\r\n                break;\r\n            case \"left\":\r\n                alignment = TabAlignment.Left;\r\n                break;\r\n            case \"right\":\r\n            case \"decimal\":\r\n                alignment = TabAlignment.Right;\r\n                break;\r\n            default:\r\n                console.log(`Unknown tab alignment value encountered: ${align}`);\r\n                break;\r\n        }\r\n        return alignment;\r\n    }\r\n\r\n    private static _readTabLeader(leaderAttr: string | undefined): TabLeader {\r\n        let leader = TabLeader.None;\r\n        if (leaderAttr !== undefined) {\r\n            switch (leaderAttr.toLowerCase()) {\r\n                case \"dot\":\r\n                    leader = TabLeader.Dot;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n        return leader;\r\n    }\r\n\r\n    constructor(pos: number, align: TabAlignment, leader: TabLeader) {\r\n        this._pos = pos;\r\n        this._alignment = align;\r\n        this.leader = leader;\r\n    }\r\n\r\n    public get isClear(): boolean {\r\n        return this._alignment === TabAlignment.Clear;\r\n    }\r\n\r\n    public get justification(): Justification {\r\n        let justification = Justification.left;\r\n        if (this._alignment === TabAlignment.Center) {\r\n            justification = Justification.center;\r\n        } else if (this._alignment === TabAlignment.Right) {\r\n            justification = Justification.right;\r\n        }\r\n        return justification;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow) {\r\n        if (this._alignment !== TabAlignment.Clear) {\r\n            this.position = flow.getX() + this._pos;\r\n        }\r\n    }\r\n}","import { Xml } from \"../utils/xml\";\r\nimport { Fonts } from \"../utils/fonts\";\r\nimport { Metrics } from \"../utils/metrics\";\r\nimport { Style } from \"./style\";\r\nimport { NamedStyles } from \"./named-styles\";\r\n\r\nexport enum UnderlineMode {\r\n    None,\r\n    Dash,\r\n    DashDotDotHeavy,\r\n    DashDotHeavy,\r\n    DashedHeavy,\r\n    DashLong,\r\n    DashLongHeavy,\r\n    DotDash,\r\n    DotDotDash,\r\n    Dotted,\r\n    DottedHeavy,\r\n    Double,\r\n    Single,\r\n    Thick,\r\n    Wave,\r\n    WavyDouble,\r\n    WavyHeavy,\r\n    Words\r\n}\r\n\r\nexport class RunStyle {\r\n    public _italic: boolean | undefined;\r\n    public _bold: boolean | undefined;\r\n    public _underlineMode: UnderlineMode | undefined;\r\n    public _strike: boolean | undefined;\r\n    public _dstrike: boolean | undefined;\r\n    public _fontFamily: string | undefined;\r\n    public _fontSize: number | undefined;\r\n    public _charSpacing: number | undefined;\r\n    public _charStretch: number | undefined;\r\n    public _color: string | undefined;\r\n    public _caps: boolean | undefined;\r\n    public _smallCaps: boolean | undefined;\r\n    public _shadingColor: string | undefined;\r\n    public _invisible: boolean | undefined;\r\n    private _basedOn: Style | undefined;\r\n    private _basedOnId: string | undefined;\r\n    private _docDefaults: Style | undefined;\r\n    \r\n    public static fromPresentationNode(runPresentationNode: ChildNode): RunStyle {\r\n        // TODO: Handle themeShade, themeTint, em, emboss, fitText, imprint, outline, position, shadow, vanish, vertAlign\r\n        const style = new RunStyle();\r\n        runPresentationNode.childNodes.forEach(child => {\r\n            switch(child.nodeName) {\r\n                case \"w:rStyle\":\r\n                    style._basedOnId = Xml.getStringValue(child);\r\n                    break;\r\n                case \"w:b\":\r\n                    style._bold = Xml.getBooleanValue(child);\r\n                    break;\r\n                case \"w:i\":\r\n                    style._italic = Xml.getBooleanValue(child);\r\n                    break;\r\n                case \"w:shd\":\r\n                    style._shadingColor = Style.readShading(child);\r\n                    break;\r\n                case \"w:highlight\":\r\n                    // Highlight equals yellow shading\r\n                    style._shadingColor = \"ffff00\";\r\n                    break\r\n                case \"w:u\":\r\n                    const underlineMode = Xml.getStringValue(child);\r\n                    if (underlineMode !== undefined) {\r\n                        style._underlineMode = RunStyle.readUnderlineMode(underlineMode);\r\n                    }\r\n                    break;\r\n                case \"w:strike\":\r\n                    style._strike = Xml.getBooleanValue(child);\r\n                    break;\r\n                case \"w:dstrike\":\r\n                    style._dstrike = Xml.getBooleanValue(child);\r\n                    break;\r\n                case \"w:rFonts\":\r\n                    const families = RunStyle.readFontFamily(child);\r\n                    if (families !== undefined) {\r\n                        style._fontFamily = families[Fonts.tryAddFonts(families)];\r\n                    } else {\r\n                        style._fontFamily = undefined;\r\n                    }\r\n                    break;\r\n                case \"w:sz\":\r\n                    style._fontSize = RunStyle.readFontSize(child);\r\n                    break;\r\n                case \"w:spacing\":\r\n                    const spacingTwips = Xml.getNumberValue(child);\r\n                    if (spacingTwips !== undefined) {\r\n                        style._charSpacing = Metrics.convertTwipsToPixels(spacingTwips);\r\n                    }\r\n                    break;\r\n                case \"w:w\":\r\n                    const stretchPercent =  Xml.getNumberValue(child);\r\n                    if (stretchPercent !== undefined) {\r\n                        style._charStretch = stretchPercent / 100;\r\n                    }\r\n                    break;\r\n                case \"w:color\":\r\n                    style._color = Xml.getStringValue(child);\r\n                    ;break;\r\n                case \"w:caps\":\r\n                    style._caps = Xml.getBooleanValue(child);\r\n                    break;\r\n                case \"w:smallCaps\":\r\n                    style._smallCaps = Xml.getBooleanValue(child);\r\n                    break;\r\n                case \"w:webHidden\":\r\n                case \"w:vanish\":\r\n                    style._invisible = true;\r\n                    break;\r\n                case \"w:shadow\":\r\n                case \"w:outline\":\r\n                case \"w:position\":\r\n                case \"w:vertAlign\":\r\n                case \"w:em\":\r\n                    // TODO: Implement.\r\n                    break;\r\n                case \"w:szCs\":\r\n                case \"w:iCs\":\r\n                case \"w:bCs\":\r\n                case \"w:lang\":\r\n                case \"w:kern\":\r\n                        // Ignore\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during RunStyle reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return style;\r\n    }\r\n\r\n    public get parent(): Style | undefined {\r\n        return this._basedOn || this._docDefaults;\r\n    }\r\n\r\n    public applyNamedStyles(namedStyles: NamedStyles | undefined): void {\r\n        if (namedStyles !== undefined) {\r\n            this._docDefaults = namedStyles.docDefaults;\r\n            if (this._basedOnId !== undefined) {\r\n                const baseStyle = namedStyles.getNamedStyle(this._basedOnId);\r\n                if (baseStyle !== undefined) {\r\n                    this._basedOn = baseStyle;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public updateFont(fontFamily: string, bold: boolean, fontSize: number): void {\r\n        this._fontFamily = fontFamily;\r\n        this._bold = bold;\r\n        this._fontSize = fontSize;\r\n    }\r\n\r\n    public toString(): string {\r\n        const i = (this._italic !== undefined) ? `i=${this._italic}` : \"\";\r\n        const b = (this._bold !== undefined) ? `b=${this._bold.toString()}` : \"\";\r\n        const u = (this._underlineMode !== undefined) ? `u=${this._underlineMode.toString()}` : \"\";\r\n        const strike = (this._strike !== undefined) ? `strike=${this._strike.toString()}` : \"\";\r\n        const font = (this._fontFamily !== undefined) ? `font=${this._fontFamily.toString()}` : \"\";\r\n        const size = (this._fontSize !== undefined) ? `size=${this._fontSize.toString()}` : \"\";\r\n        const dstrike = (this._dstrike !== undefined) ? `dstrike=${this._dstrike.toString()}` : \"\";\r\n        const charSpacing = (this._charSpacing !== undefined) ? `char_spacing=${this._charSpacing.toString()}` : \"\";\r\n        const charStretch = (this._charStretch !== undefined) ? `char_stretch=${this._charStretch.toString()}` : \"\";\r\n        const color = (this._color !== undefined) ? `color=${this._color.toString()}` : \"\";\r\n        const caps = (this._caps !== undefined) ? `caps=${this._caps.toString()}` : \"\";\r\n        const smallcaps = (this._smallCaps !== undefined) ? `smallcaps=${this._smallCaps.toString()}` : \"\";\r\n        return `RunStyle: ${i} ${b} ${u} ${strike} ${font} ${size} ${dstrike} ${charSpacing} ${charStretch} ${color} ${caps} ${smallcaps}`;\r\n    }\r\n\r\n    /**\r\n     * Return fonts from specified node in reverse order.\r\n     */\r\n    private static readFontFamily(fontNode: ChildNode): string[] | undefined {\r\n        let fonts: string[] | undefined = undefined;\r\n        const asciiFont = Xml.getAttribute(fontNode, \"w:ascii\");\r\n        if (asciiFont !== undefined) {\r\n            fonts = asciiFont.split(';');\r\n        }\r\n        return fonts;\r\n    }\r\n\r\n    private static readFontSize(sizeNode: ChildNode): number | undefined {\r\n        const sizeInPoints = Xml.getNumberValue(sizeNode);\r\n        return (sizeInPoints !== undefined) ? Metrics.convertPointToFontSize(sizeInPoints) : undefined;\r\n    }\r\n\r\n    private static readUnderlineMode(underlineStr: string): UnderlineMode {\r\n        let underlineMode: UnderlineMode;\r\n        switch(underlineStr) {\r\n            case \"dash\":\r\n                underlineMode = UnderlineMode.Dash;\r\n                break;\r\n            case \"dashDotDotHeavy\":\r\n                underlineMode = UnderlineMode.DashDotDotHeavy;\r\n                break;\r\n            case \"dashDotHeavy\":\r\n                underlineMode = UnderlineMode.DashDotHeavy;\r\n                break;\r\n            case \"dashedHeavy\":\r\n                underlineMode = UnderlineMode.DashedHeavy;\r\n                break;\r\n            case \"dashLong\":\r\n                underlineMode = UnderlineMode.DashLong;\r\n                break;\r\n            case \"dashLongHeavy\":\r\n                underlineMode = UnderlineMode.DashLongHeavy;\r\n                break;\r\n            case \"dotDash\":\r\n                underlineMode = UnderlineMode.DotDash;\r\n                break;\r\n            case \"dotDotDash\":\r\n                underlineMode = UnderlineMode.DotDotDash;\r\n                break;\r\n            case \"dotted\":\r\n                underlineMode = UnderlineMode.Dotted;\r\n                break;\r\n            case \"dottedHeavy\":\r\n                underlineMode = UnderlineMode.DottedHeavy;\r\n                break;\r\n            case \"double\":\r\n                underlineMode = UnderlineMode.Double;\r\n                break;\r\n            case \"single\":\r\n                underlineMode = UnderlineMode.Single;\r\n                break;\r\n            case \"thick\":\r\n                underlineMode = UnderlineMode.Thick;\r\n                break;\r\n            case \"wave\":\r\n                underlineMode = UnderlineMode.Wave;\r\n                break;\r\n            case \"wavyDouble\":\r\n                underlineMode = UnderlineMode.WavyDouble;\r\n                break;\r\n            case \"wavyHeavy\":\r\n                underlineMode = UnderlineMode.WavyHeavy;\r\n                break;\r\n            case \"words\":\r\n                underlineMode = UnderlineMode.Words;\r\n                break;\r\n            case \"none\":\r\n            default:\r\n                underlineMode = UnderlineMode.None;\r\n                break;\r\n        }\r\n        return underlineMode;\r\n    }\r\n}","import { Xml } from \"../utils/xml\";\r\nimport { Metrics } from \"../utils/metrics\";\r\nimport { NamedStyles } from \"../text/named-styles\";\r\nimport { Style } from \"../text/style\";\r\nimport { NumberingStyle } from \"../numbering/num-style\";\r\nimport { AbstractNumberings } from \"../numbering/abstract-numberings\";\r\nimport { TabStop } from \"./tab-stop\";\r\nimport { RunStyle } from \"../text/run-style\";\r\n\r\nexport enum Justification {\r\n    center = \"center\",\r\n    both = \"both\",\r\n    left = \"left\",\r\n    right = \"right\"\r\n}\r\n\r\nexport enum LineRule {\r\n    exactly = \"exactly\",\r\n    atLeast = \"atLeast\",\r\n    auto = \"auto\"\r\n}\r\n\r\nexport class ParStyle {\r\n    public justification: Justification | undefined = undefined;\r\n    public indentation: number | undefined;\r\n    public hanging: number | undefined;\r\n    private _lineSpacing: number | undefined;\r\n    private _lineRule: LineRule | undefined;\r\n    public numStyle: NumberingStyle | undefined;\r\n    public shadingColor: string | undefined;\r\n    private _parSpacingBefore: number | undefined;\r\n    private _parSpacingAfter: number | undefined;\r\n    private _parLinesBefore: number | undefined;\r\n    private _parLinesAfter: number | undefined;\r\n    private _parAutoSpacingBefore: boolean | undefined;\r\n    private _parAutoSpacingAfter: boolean | undefined;\r\n    public tabStops: TabStop[] | undefined;\r\n    public runStyle: RunStyle | undefined;\r\n    private _basedOn: Style | undefined;\r\n    private _basedOnId: string | undefined;\r\n    private _docDefaults: Style | undefined;\r\n\r\n    public static fromParPresentationNode(parPresentationNode: ChildNode): ParStyle {\r\n        const parStyle = new ParStyle();\r\n        parPresentationNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"w:pStyle\":\r\n                    parStyle._basedOnId = Xml.getStringValue(child);\r\n                    break;\r\n                case \"w:jc\":\r\n                    const justification = Xml.getStringValue(child);\r\n                    if (justification !== undefined) {\r\n                        parStyle.justification = Justification[justification as keyof typeof Justification];\r\n                    }\r\n                    break;\r\n                case \"w:ind\":\r\n                    const hangingAttr = Xml.getAttribute(child, \"w:hanging\");\r\n                    if (hangingAttr !== undefined) {\r\n                        parStyle.hanging = Metrics.convertTwipsToPixels(parseInt(hangingAttr, 10));\r\n                    }\r\n                    const leftAttr = Xml.getAttribute(child, \"w:left\");\r\n                    if (leftAttr !== undefined) {\r\n                        parStyle.indentation = Metrics.convertTwipsToPixels(parseInt(leftAttr, 10));\r\n                    }\r\n                    break;\r\n                case \"w:numPr\":\r\n                    parStyle.numStyle = NumberingStyle.fromNumPresentationNode(child);\r\n                    break;\r\n                case \"w:spacing\":\r\n                    parStyle.setLineSpacingFromNode(child);\r\n                    parStyle.setParSpacingFromNode(child);\r\n                    break;\r\n                case \"w:shd\":\r\n                    parStyle.shadingColor = Style.readShading(child);\r\n                    break;\r\n                case \"w:tabs\":\r\n                    parStyle.tabStops = TabStop.fromTabsNode(child);\r\n                    break;\r\n                case \"w:rPr\":\r\n                    parStyle.runStyle = RunStyle.fromPresentationNode(child);\r\n                    break;\r\n                case \"w:widowControl\":\r\n                case \"w:snapToGrid\":\r\n                case \"w:sectPr\":\r\n                case \"w:pBdr\":\r\n                case \"w:contextualSpacing\":\r\n                case \"w:keepLines\":\r\n                case \"w:bidi\":\r\n                case \"w:keepNext\":\r\n                case \"w:suppressAutoHyphens\":\r\n                case \"w:suppressLineNumbers\":\r\n                case \"w:outlineLvl\":\r\n                        // Ignore\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during ParStyle reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return parStyle;\r\n    }\r\n\r\n    public get parent(): Style | undefined {\r\n        return this._basedOn || this._docDefaults;\r\n    }\r\n\r\n    public getLineSpacing(style: Style): number | undefined {\r\n        let spacing = this._lineSpacing;\r\n        if (spacing !== undefined) {\r\n            const lineRule = this._lineRule;\r\n            switch(lineRule) {\r\n                case LineRule.auto:\r\n                    // Line Spacing is interpreted as 1/240th of a line.\r\n                    const lineSize = style.fontSize * 1.08;\r\n                    spacing = lineSize * spacing / 240; \r\n                break;\r\n                default:\r\n                    // Line spacing is interpreted as 1/20th of a point.\r\n                    spacing = Metrics.convertTwipsToPixels(spacing);\r\n                    break\r\n            }\r\n        }\r\n        return spacing;        \r\n    }\r\n\r\n    public setLineSpacing(spacing: number): void {\r\n        this._lineSpacing = spacing;\r\n        this._lineRule = LineRule.atLeast;\r\n    }\r\n\r\n    public get spacingBefore(): number {\r\n        let spacing: number = 0;\r\n        if (this._parLinesBefore !== undefined && this._lineSpacing !== undefined) {\r\n            spacing = this._parLinesBefore * this._lineSpacing;\r\n        } else if (this._parSpacingBefore !== undefined) {\r\n            spacing = this._parSpacingBefore;\r\n        } else if (this._parAutoSpacingBefore === true && this._lineSpacing !== undefined) {\r\n            spacing = 1.08 * this._lineSpacing;\r\n        }\r\n        return spacing;\r\n    }\r\n\r\n    public get spacingAfter(): number {\r\n        let spacing: number = 0;\r\n        if (this._parLinesAfter !== undefined && this._lineSpacing !== undefined) {\r\n            spacing = this._parLinesAfter * this._lineSpacing;\r\n        } else if (this._parSpacingAfter !== undefined) {\r\n            spacing = this._parSpacingAfter;\r\n        } else if (this._parAutoSpacingAfter === true && this._lineSpacing !== undefined) {\r\n            spacing = 1.08 * this._lineSpacing;\r\n        }\r\n        return spacing;\r\n    }\r\n\r\n    public applyNamedStyles(namedStyles: NamedStyles | undefined): void {\r\n        if (namedStyles !== undefined) {\r\n            this._docDefaults = namedStyles.docDefaults;\r\n            if (this._basedOnId !== undefined) {\r\n                const baseStyle = namedStyles.getNamedStyle(this._basedOnId);\r\n                if (baseStyle !== undefined) {\r\n                    this._basedOn = baseStyle;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public applyNumberings(numberings: AbstractNumberings | undefined): void {\r\n        if (this.numStyle !== undefined) {\r\n            this.numStyle.applyNumberings(numberings);\r\n        }\r\n    }\r\n\r\n    public clone(): ParStyle {\r\n        const cloned = new ParStyle();\r\n        cloned._docDefaults = this._docDefaults;\r\n        cloned._basedOn = this._basedOn;\r\n        cloned._basedOnId = this._basedOnId;\r\n        cloned.justification = this.justification;\r\n        cloned.indentation = this.indentation;\r\n        cloned.hanging = this.hanging;\r\n        cloned._lineSpacing = this._lineSpacing;\r\n        cloned._lineRule = this._lineRule;\r\n        cloned.numStyle = this.numStyle;\r\n        cloned.shadingColor = this.shadingColor;\r\n        cloned._parSpacingBefore = this._parSpacingBefore;\r\n        cloned._parSpacingAfter = this._parSpacingAfter;\r\n        cloned._parLinesBefore = this._parLinesBefore;\r\n        cloned._parLinesAfter = this._parLinesAfter;\r\n        cloned._parAutoSpacingBefore = this._parAutoSpacingBefore;\r\n        cloned._parAutoSpacingAfter = this._parAutoSpacingAfter;\r\n        cloned.tabStops = this.tabStops;\r\n        return cloned;\r\n    }\r\n\r\n    public toString(): string {\r\n        const baseText = (this._basedOnId !== undefined) ? `base=${this._basedOnId}` : \"\";\r\n        const justText = (this.justification !== undefined) ? `jc=${this.justification.toString()}` : \"\";\r\n        const indText = (this.indentation !== undefined) ? `ind=${this.indentation.toString()}` : \"\";\r\n        const lineText = (this._lineSpacing !== undefined) ? `line=${this._lineSpacing.toString()}` : \"\";\r\n        return `ParStyle: ${baseText} ${justText} ${indText} ${lineText}`;\r\n    }\r\n\r\n    private setLineSpacingFromNode(spacingNode: ChildNode): void {\r\n        const lineAttr = Xml.getAttribute(spacingNode, \"w:line\");\r\n        if (lineAttr !== undefined) {\r\n            this._lineSpacing = parseInt(lineAttr, 10);\r\n            this._lineRule = LineRule.exactly;\r\n        }\r\n        const ruleAttr = Xml.getAttribute(spacingNode, \"w:lineRule\");\r\n        if (ruleAttr !== undefined) {\r\n            this._lineRule = LineRule[ruleAttr as keyof typeof LineRule];\r\n        }\r\n    }\r\n\r\n    private setParSpacingFromNode(spacingNode: ChildNode): void {\r\n        const beforeAttr = Xml.getAttribute(spacingNode, \"w:before\");\r\n        if (beforeAttr !== undefined) {\r\n            this._parSpacingBefore = Metrics.convertTwipsToPixels(parseInt(beforeAttr, 10));\r\n        }\r\n        const beforeLinesAttr = Xml.getAttribute(spacingNode, \"w:beforeLines\");\r\n        if (beforeLinesAttr !== undefined) {\r\n            this._parLinesBefore = parseInt(beforeLinesAttr, 10) / 100;\r\n        }\r\n        const beforeAutoAttr = Xml.getAttribute(spacingNode, \"w:beforeAutospacing\");\r\n        if (beforeAutoAttr !== undefined) {\r\n            this._parAutoSpacingBefore = Xml.attributeAsBoolean(beforeAutoAttr);\r\n        }\r\n        const afterAttr = Xml.getAttribute(spacingNode, \"w:after\");\r\n        if (afterAttr !== undefined) {\r\n            this._parSpacingAfter = Metrics.convertTwipsToPixels(parseInt(afterAttr, 10));\r\n        }\r\n        const afterLinesAttr = Xml.getAttribute(spacingNode, \"w:afterLines\");\r\n        if (afterLinesAttr !== undefined) {\r\n            this._parLinesAfter = parseInt(afterLinesAttr, 10) / 100;\r\n        }\r\n        const afterAutoAttr = Xml.getAttribute(spacingNode, \"w:afterAutospacing\");\r\n        if (afterAutoAttr !== undefined) {\r\n            this._parAutoSpacingAfter = Xml.attributeAsBoolean(afterAutoAttr);\r\n        }\r\n    }\r\n}","import { Justification } from \"../paragraph/par-style\";\r\n\r\n/**\r\n * Bit flags for empasis of fonts (bold, italic, small caps).\r\n */\r\nexport enum Emphasis {\r\n    Normal = 0,\r\n    Bold = 1,\r\n    Italic = 2,\r\n    SmallCaps = 4\r\n}\r\n\r\n/**\r\n * A line of text with its position on the screen.\r\n */\r\nexport interface IPositionedTextLine {\r\n    text: string;\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    stretched: boolean;\r\n    following: boolean;\r\n    color: string;\r\n    fontFamily: string;\r\n    fontSize: number;\r\n    emphasis: Emphasis;\r\n    justification?: Justification\r\n}\r\n\r\n/**\r\n * Line with its position on screen.\r\n */\r\nexport interface IPositionedLine {\r\n    x1: number,\r\n    x2: number,\r\n    y1: number,\r\n    y2: number\r\n}","\r\nexport enum WordSeperator {\r\n    Space,\r\n    Dash,\r\n    Tab,\r\n    LineFeed\r\n}\r\n\r\nexport class WordSplitter {\r\n    private _texts: string[];\r\n    private _words: string[] | undefined;\r\n    private _seperators: WordSeperator[] | undefined;\r\n\r\n    constructor(texts: string[]){\r\n        this._texts = texts;\r\n    }\r\n\r\n    public get words(): string[] {\r\n        if (this._words === undefined) {\r\n            this._split();\r\n        }\r\n        return this._words || [];\r\n    }\r\n\r\n    public getSeperator(index: number): WordSeperator {\r\n        if (this._words === undefined) {\r\n            this._split();\r\n        }\r\n        return this._seperators![index];\r\n    }\r\n\r\n    /**\r\n     * Combine the words from start to end index, inclusive.\r\n     */\r\n    public combine(start: number, end: number): string {\r\n        const results: string[] = [];\r\n        if (this._words === undefined) {\r\n            this._split();\r\n        }\r\n        const words = this._words!;\r\n        for (let i = start; i <= end; i++) {\r\n            results.push(words![i]);\r\n            const sep = this.getSeperator(i);\r\n            switch(sep) {\r\n                case WordSeperator.Dash:\r\n                    results.push(\"-\");\r\n                    break;\r\n                case WordSeperator.Tab:\r\n                    // Push nothing\r\n                    break;\r\n                default:\r\n                    results.push(\" \");\r\n                    break;\r\n            }\r\n        }\r\n        return results.join(\"\");\r\n    }\r\n\r\n    private _split(): void {\r\n        const txt = this._texts.join('');\r\n        this._words = txt.split(/[\\s-\\t]/);\r\n        const seperators: WordSeperator[] = [];\r\n        let index = 0;\r\n        for (let i = 1; i < this._words.length; i++) {\r\n            index += this._words[i - 1].length;\r\n            const currentChar = txt.charAt(index);\r\n            switch(currentChar) {\r\n                case \" \":\r\n                    seperators.push(WordSeperator.Space);\r\n                    break;\r\n                case \"-\":\r\n                    seperators.push(WordSeperator.Dash);\r\n                    break;\r\n                case \"\\t\":\r\n                    seperators.push(WordSeperator.Tab);\r\n                    break;\r\n                case \"\\r\":\r\n                case \"\\n\":\r\n                    seperators.push(WordSeperator.LineFeed);\r\n                    break;\r\n                default:\r\n                    console.log(\"Invalid seperator character found, assuming a space.\");\r\n                    seperators.push(WordSeperator.Space);\r\n                    break;\r\n            }\r\n            index++;\r\n        }\r\n        this._seperators = seperators;\r\n    }\r\n}","import { TextRun } from \"../text/text-run\";\r\nimport { ILayoutable } from \"../utils/i-layoutable\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { ParStyle } from \"./par-style\";\r\nimport { FontMetrics } from \"../utils/font-metrics\";\r\n\r\nexport enum ParagraphType {\r\n    Text = 0,\r\n    TableCell = 1,\r\n    Drawing = 2\r\n}\r\n\r\nexport interface IRun extends ILayoutable {\r\n    getUsedWidth(): number;\r\n    getHeight(): number;\r\n    previousXPos: number | undefined;\r\n    lastXPos: number | undefined;\r\n}\r\n\r\nexport class Paragraph implements ILayoutable {\r\n    private _type: ParagraphType;\r\n    private _runs: IRun[];\r\n    private _numberingRun: TextRun | undefined;\r\n\r\n    constructor(runs: IRun[], numberingRun: TextRun | undefined) {\r\n        this._type = ParagraphType.Text;\r\n        this._runs = runs;\r\n        this._numberingRun = numberingRun;\r\n    }\r\n\r\n    public get style(): ParStyle {\r\n        let idx = 0;\r\n        while(idx < this._runs.length && !(this._runs[idx] instanceof TextRun)) {\r\n            idx++;\r\n            if (idx == this._runs.length) {\r\n                return new ParStyle();\r\n            }\r\n        }\r\n        const foundRun = this._runs[idx];\r\n        if (foundRun === undefined) {\r\n            return new ParStyle();\r\n        }\r\n        return (foundRun as TextRun).style.parStyle;\r\n    }\r\n\r\n    public get runs(): IRun[] {\r\n        return this._runs!;\r\n    }\r\n\r\n    public get numberingRun(): TextRun | undefined {\r\n        return this._numberingRun;\r\n    }\r\n\r\n    public get type(): ParagraphType {\r\n        return this._type;\r\n    }\r\n\r\n    public set type(type: ParagraphType) {\r\n        this._type = type;\r\n        this._runs.forEach(run => {\r\n            if (run instanceof TextRun) {\r\n                run.paragraphType = type;\r\n            }\r\n        })\r\n    }\r\n\r\n    public getUsedWidth(availableWidth: number): number {\r\n        let usedWidth = 0;\r\n        const runs = this.runs;\r\n        for(let i = 0; i < runs.length; i++) {\r\n            const runsWidth = runs[i].getUsedWidth();\r\n            if (runsWidth >= availableWidth) {\r\n                usedWidth = availableWidth;\r\n                break;\r\n            }\r\n            usedWidth += runsWidth;\r\n        }\r\n        return Math.min(usedWidth, availableWidth);\r\n    }\r\n\r\n    public getHeight(): number {\r\n        const style = this.style;\r\n        let height = (style !== undefined) ? style.spacingAfter + style.spacingBefore : 0;\r\n        this.runs.forEach(run => {\r\n            height += run.getHeight();\r\n        });\r\n        return height;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow): void {\r\n        flow.mentionParagraphPosition();\r\n        const startY = flow.getY();\r\n        let previousXPos: number | undefined = 0;\r\n        if (this.style !== undefined) {\r\n            flow.advancePosition(this.style.spacingBefore);\r\n        }\r\n        if (this.style.tabStops !== undefined) {\r\n            this.style.tabStops.forEach(stop => {\r\n                stop.performLayout(flow);\r\n                if (stop.isClear) {\r\n                    flow.removeTabStop();\r\n                } else {\r\n                    flow.addTabStop(stop);\r\n                }\r\n            });\r\n        }\r\n        if (this._numberingRun !== undefined) {\r\n            const clonedFlow = flow.clone();\r\n            // Fix bug in TextFitter.\r\n            clonedFlow.advancePosition(-FontMetrics.getTopToBaseline(this._numberingRun.style));\r\n            this._numberingRun.performLayout(clonedFlow);\r\n            previousXPos = this._numberingRun.lastXPos;\r\n        }\r\n        this.runs.forEach(run => {\r\n            run.previousXPos = previousXPos;\r\n            run.performLayout(flow);\r\n            previousXPos = run.lastXPos;\r\n            flow.mentionCharacterPosition(run.lastXPos!);\r\n        });\r\n        if (this.style !== undefined) {\r\n            flow.advancePosition(this.style.spacingAfter);\r\n        }\r\n        const lineSpacing = this._getLineSpacing();\r\n        if (flow.getY() - startY < lineSpacing) {\r\n            flow.advancePosition(lineSpacing);\r\n        }\r\n    }\r\n\r\n    private _getLineSpacing(): number {\r\n        return (this.runs[0] instanceof TextRun) ? (this.runs[0] as TextRun).style.lineSpacing : 10;\r\n    }\r\n}","import { Justification } from \"../paragraph/par-style\";\r\nimport { Picture } from \"../drawing/picture\";\r\n\r\nexport interface IRectangle {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\nexport enum DashMode {\r\n    Solid,\r\n    Dashed,\r\n    Dotted,\r\n    DashedSmallGap,\r\n    DotDash,\r\n    DotDotDash,\r\n    LongDash\r\n}\r\n\r\nexport interface IPainter {\r\n    paintText(x: number, y: number, width: number, stretched: boolean, text: string, color: string, justification: Justification, fontFamily: string, fontSize: number, bold: boolean, italic: boolean): void;\r\n\r\n    measureLastText(): IRectangle;\r\n\r\n    clear(): void;\r\n\r\n    setWidth(width: number): void;\r\n    \r\n    ensureHeight(height: number): void;\r\n\r\n    paintLine(x1: number, y1: number, x2: number, y2: number, color: string, thickness: number, dashing: DashMode): void;\r\n\r\n    paintPolygon(path: string, fillColor: string | undefined, strokeColor: string | undefined, strokeThickness: number | undefined, dashing: DashMode): void;\r\n\r\n    paintPicture(x: number, y: number, width: number, height: number, pic: Picture): void;\r\n\r\n    startLink(url: string): void;\r\n    \r\n    endLink(): void;\r\n}","\r\nexport enum TableBorderType {\r\n    None,\r\n    Single,\r\n    DashDotStroked,\r\n    Dashed,\r\n    DashSmallGap,\r\n    DotDash,\r\n    DotDotDash,\r\n    Dotted,\r\n    Double,\r\n    DoubleWave,\r\n    Inset,\r\n    Outset,\r\n    Thick,\r\n    ThickThinLargeGap,\r\n    ThickThinMediumGap,\r\n    ThickThinSmallGap,\r\n    ThinThickLargeGap,\r\n    ThinThickMediumGap,\r\n    ThinThickSmallGap,\r\n    ThinThickThinLargeGap,\r\n    ThinThickThinMediumGap,\r\n    ThinThickThinSmallGap,\r\n    Emboss3D,\r\n    Engrave3D,\r\n    Triple,\r\n    Wave\r\n}\r\n\r\nexport class TableBorder {\r\n    public type: TableBorderType;\r\n    public size: number;\r\n    public spacing: number;\r\n    public color: string;\r\n\r\n    constructor() {\r\n        this.type = TableBorderType.None;\r\n        this.size = 1;\r\n        this.spacing = 0;\r\n        this.color = \"000000\";\r\n    }\r\n}\r\n","import { ChartSpace, ChartType } from \"./chart-space\";\r\nimport { FontMetrics } from \"../utils/font-metrics\";\r\nimport { ChartStyle } from \"./chart-style\";\r\nimport { IPositionedTextLine, IPositionedLine } from \"../text/positioned-text-line\";\r\nimport { Justification } from \"../paragraph/par-style\";\r\n\r\nexport enum ChartAxisPosition {\r\n    Top,\r\n    Bottom,\r\n    Left,\r\n    Right\r\n}\r\n\r\nexport enum ChartAxisTickMode {\r\n    None,\r\n    Outwards\r\n}\r\n\r\nexport enum ChartAxisLabelAlignment {\r\n    Center\r\n}\r\n\r\nexport enum ChartAxisCrossMode {\r\n    AutoZero\r\n}\r\n\r\nexport class ChartAxis {\r\n    public position: ChartAxisPosition;\r\n    public majorTickMode: ChartAxisTickMode;\r\n    public minorTickMode: ChartAxisTickMode;\r\n    public majorGridStyle: ChartStyle;\r\n    public minorGridStyle: ChartStyle;\r\n    public labelAlignment: ChartAxisLabelAlignment = ChartAxisLabelAlignment.Center;\r\n    public labelOffset: number;\r\n    public crossMode: ChartAxisCrossMode = ChartAxisCrossMode.AutoZero;\r\n    public style: ChartStyle;\r\n    public positionedTexts: IPositionedTextLine[] | undefined = undefined;\r\n    public positionedLines: IPositionedLine[] | undefined = undefined;\r\n    private _space: ChartSpace;\r\n    private _isValueAxis: boolean;\r\n    private static _labelSpacing = 5;\r\n    private static _majorOutwardLength = 5;\r\n    private static _minorOutwardLength = 5;\r\n    private static _numMajorTicks = 6;\r\n\r\n    constructor(space: ChartSpace, style: ChartStyle, pos: ChartAxisPosition, major: ChartAxisTickMode, minor: ChartAxisTickMode, offset: number, isValueAxis: boolean) {\r\n        this._space = space;\r\n        this.style = style;\r\n        this.position = pos;\r\n        this.majorTickMode = major;\r\n        this.minorTickMode = minor;\r\n        this.labelOffset = offset;\r\n        this.majorGridStyle = new ChartStyle();\r\n        this.minorGridStyle = new ChartStyle();\r\n        this._isValueAxis = isValueAxis;\r\n    }\r\n\r\n    public get isValueAxis(): boolean {\r\n        return this._isValueAxis;\r\n    }\r\n\r\n    public get isCategoryAxis(): boolean {\r\n        return !this._isValueAxis;\r\n    }\r\n\r\n    public getMaxDistanceFromPlot() {\r\n        let maxDistance : number;\r\n        if (this.position === ChartAxisPosition.Bottom || this.position === ChartAxisPosition.Top) {\r\n            maxDistance = ChartAxis._labelSpacing + this._space.textStyle.lineSpacing;\r\n        } else {\r\n            let maxChars = 0;\r\n            this._getTexts().forEach(text => {\r\n                maxChars = Math.max(maxChars, text.length);\r\n            });\r\n            maxDistance = maxChars * FontMetrics.averageCharWidth(this._space.textStyle);\r\n            maxDistance += ChartAxis._labelSpacing;\r\n        }\r\n        if (this.majorTickMode === ChartAxisTickMode.Outwards) {\r\n            maxDistance += ChartAxis._majorOutwardLength;\r\n        } else if (this.minorTickMode === ChartAxisTickMode.Outwards) {\r\n            maxDistance += ChartAxis._minorOutwardLength;\r\n        }\r\n        return maxDistance;\r\n    }\r\n\r\n    public performLayout(): void {\r\n        this.positionedTexts = [];\r\n        this.positionedLines = [];\r\n        const textLines = this.positionedTexts;\r\n        const lines = this.positionedLines;\r\n        const plotBounds = this._space.plotArea.bounds;\r\n        const hasNumericValues = this._hasNumericValues();\r\n        switch(this.position) {\r\n            case ChartAxisPosition.Left:\r\n                if (hasNumericValues) {\r\n                    const { min, max } = this._space.chart.getValueRange();\r\n                    const texts = this._getMajorValues(min, max).reverse();\r\n                    const halfLineSpacing = this._space.textStyle.fontSize / 2;\r\n                    const segmentHeight = plotBounds.height / (texts.length - 1);\r\n                    let currentY = plotBounds.top;\r\n                    let textX = plotBounds.left - ChartAxis._labelSpacing;\r\n                    let lineX1 = plotBounds.left;\r\n                    let lineX2 = plotBounds.left;\r\n                    if (this.majorTickMode === ChartAxisTickMode.Outwards) {\r\n                        textX -= ChartAxis._majorOutwardLength;\r\n                        lineX2 -= ChartAxis._majorOutwardLength;\r\n                    } else if (this.minorTickMode === ChartAxisTickMode.Outwards) {\r\n                        textX -= ChartAxis._minorOutwardLength;\r\n                        lineX2 -= ChartAxis._minorOutwardLength;\r\n                    }\r\n                    if (this.majorGridStyle.lineColor !== undefined) {\r\n                        lineX1 = plotBounds.right;\r\n                    }\r\n                    texts.forEach(text => {\r\n                        textLines.push(this._createPositionedText(textX, currentY + halfLineSpacing, text, Justification.right));\r\n                        lines.push({\r\n                            x1: lineX1,\r\n                            x2: lineX2,\r\n                            y1: currentY,\r\n                            y2: currentY\r\n                        });\r\n                        currentY += segmentHeight;\r\n                    });\r\n                }\r\n                break;\r\n            case ChartAxisPosition.Right:\r\n                \r\n                break;\r\n            case ChartAxisPosition.Top:\r\n                \r\n                break;\r\n            case ChartAxisPosition.Bottom:\r\n                if (!hasNumericValues) {\r\n                    const texts = this._getTexts();\r\n                    let numSegments = texts.length;\r\n                    let applyTextDelta = 1;\r\n                    if (this._space.chartType !== ChartType.Bar) {\r\n                        numSegments--;\r\n                        applyTextDelta = 0;\r\n                    }\r\n                    const halfSegmentWidth = (plotBounds.width / numSegments) / 2;\r\n                    let currentX = plotBounds.x;\r\n                    let textY = plotBounds.bottom + ChartAxis._labelSpacing + FontMetrics.getTopToBaseline(this._space.textStyle);\r\n                    let lineY1 = plotBounds.bottom;\r\n                    let lineY2 = plotBounds.bottom;\r\n                    if (this.majorTickMode === ChartAxisTickMode.Outwards) {\r\n                        textY += ChartAxis._majorOutwardLength;\r\n                        lineY2 += ChartAxis._majorOutwardLength;\r\n                    } else if (this.minorTickMode === ChartAxisTickMode.Outwards) {\r\n                        textY += ChartAxis._minorOutwardLength;\r\n                        lineY2 += ChartAxis._minorOutwardLength;\r\n                    }\r\n                    if (this.majorGridStyle.lineColor !== undefined) {\r\n                        lineY1 = plotBounds.top;\r\n                    }\r\n                    texts.forEach(text => {\r\n                        textLines.push(this._createPositionedText(currentX + applyTextDelta * halfSegmentWidth, textY, text, Justification.center));\r\n                        lines.push({\r\n                            x1: currentX,\r\n                            x2: currentX,\r\n                            y1: lineY1,\r\n                            y2: lineY2\r\n                        });\r\n                        currentX += 2 * halfSegmentWidth;\r\n                    });\r\n                    lines.push({\r\n                        x1: currentX,\r\n                        x2: currentX,\r\n                        y1: lineY1,\r\n                        y2: lineY2\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _hasNumericValues(): boolean {\r\n        const chart = this._space.chart;\r\n        return (this.isValueAxis) ? chart.series[0].hasNumericValues : chart.series[0].hasNumericCategories;\r\n    }\r\n\r\n    private _getTexts(): string[] {\r\n        const { min, max } = this._space.chart.getValueRange();\r\n        return (this.isValueAxis) ? this._getMajorValues(min, max) : this._getCategoryNames();\r\n    }\r\n\r\n    private _getCategoryNames(): string[]  {\r\n        return this._space.chart.series[0].categories.map(cat => {\r\n            return cat.toString();\r\n        });\r\n    }\r\n\r\n    private _getMajorValues(min: number, max: number): string[] {\r\n        const texts: string[] = [];\r\n        const delta = (max - min) / ChartAxis._numMajorTicks;\r\n        for (let i = min; i <= max; i += delta) {\r\n            texts.push(i.toString());\r\n        }\r\n        return texts;\r\n    }\r\n\r\n    private _createPositionedText(x: number, y: number, text: string, justification: Justification): IPositionedTextLine {\r\n        const textStyle = this._space.textStyle;\r\n        return {\r\n            text: text,\r\n            x: x,\r\n            y: y,\r\n            width: 0,\r\n            stretched: false,\r\n            following: false,\r\n            justification: justification,\r\n            color: textStyle.color,\r\n            fontFamily: textStyle.fontFamily,\r\n            fontSize: textStyle.fontSize,\r\n            emphasis: textStyle.emphasis\r\n        };\r\n    }\r\n}","import { BarChart } from \"./bar-chart\";\r\nimport { ChartStyle } from \"./chart-style\";\r\nimport { ChartPlotArea } from \"./chart-plot-area\";\r\nimport { ChartLegend } from \"./chart-legend\";\r\nimport { ILayoutable } from \"../utils/i-layoutable\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { Box } from \"../utils/geometry/box\";\r\nimport { Style } from \"../text/style\";\r\nimport { ChartAxisPosition, ChartAxis } from \"./chart-axis\";\r\nimport { BaseChart } from \"./base-chart\";\r\nimport { LineChart } from \"./line-chart\";\r\nimport { AreaChart } from \"./area-chart\";\r\nimport { PieChart } from \"./pie-chart\";\r\n\r\nexport enum ChartType {\r\n    Bar,\r\n    Line,\r\n    Area,\r\n    Pie\r\n}\r\n\r\nexport class ChartSpace implements ILayoutable {\r\n    private _promise: Promise<void> | undefined = undefined;\r\n    private _chart: BaseChart | undefined = undefined;\r\n    private _type = ChartType.Bar;\r\n    public style: ChartStyle = new ChartStyle();\r\n    public textStyle: Style = new Style();\r\n    public plotArea: ChartPlotArea;\r\n    public legend: ChartLegend | undefined = undefined;\r\n    public bounds: Box = new Box(0, 0, 0, 0);\r\n\r\n    constructor() {\r\n        // Hard coded text style.\r\n        this.textStyle.runStyle.updateFont(\"Arial\", false, 11);\r\n        this.textStyle.parStyle.setLineSpacing(240);\r\n        this.plotArea = new ChartPlotArea(this);\r\n    }\r\n\r\n    public async ensureLoaded(): Promise<void> {\r\n        if (this._promise !== undefined) {\r\n            await this._promise;\r\n            this._promise = undefined;\r\n        }\r\n    }\r\n\r\n    public get chartType(): ChartType {\r\n        return this._type;\r\n    }\r\n\r\n    public get chart(): BaseChart {\r\n        return this._chart!;\r\n    }\r\n\r\n    public setAreaChart(areaChart: AreaChart): void {\r\n        this._chart = areaChart;\r\n        this._type = ChartType.Area;\r\n    }\r\n\r\n    public setLineChart(lineChart: LineChart): void {\r\n        this._chart = lineChart;\r\n        this._type = ChartType.Line;\r\n    }\r\n\r\n    public setBarChart(barChart: BarChart): void {\r\n        this._chart = barChart;\r\n        this._type = ChartType.Bar;\r\n    }\r\n\r\n    public setPieChart(pieChart: PieChart): void {\r\n        this._chart = pieChart;\r\n        this._type = ChartType.Pie;\r\n    }\r\n\r\n    public setPromise(promise: Promise<void>): void {\r\n        this.ensureLoaded();\r\n        this._promise = promise;\r\n    }\r\n\r\n    public performLayout(_flow: VirtualFlow): void {\r\n        // Ensure layouting is done before external promise returns.\r\n        const promise = new Promise<void>(async (resolve, _reject) => {\r\n            await this._promise;\r\n            this._performLayout();\r\n            resolve();\r\n        });\r\n        this.setPromise(promise);\r\n    }\r\n\r\n    private _performLayout(): void {\r\n        this.plotArea.determineRange();\r\n        let plotBounds = this.bounds.subtractSpacing(10);\r\n        if (this.legend !== undefined) {\r\n            plotBounds = this._layoutLegend(plotBounds, this.legend);\r\n        }\r\n        if (this.plotArea.valueAxis !== undefined) {\r\n            plotBounds = this._subtractAxis(plotBounds, this.plotArea.valueAxis);\r\n        }\r\n        if (this.plotArea.categoryAxis !== undefined) {\r\n            plotBounds = this._subtractAxis(plotBounds, this.plotArea.categoryAxis);\r\n        }\r\n        this.plotArea.bounds = plotBounds;\r\n        if (this.plotArea.valueAxis !== undefined) {\r\n            this.plotArea.valueAxis.performLayout();\r\n        }\r\n        if (this.plotArea.categoryAxis !== undefined) {\r\n            this.plotArea.categoryAxis.performLayout();\r\n        }\r\n    }\r\n\r\n    private _layoutLegend(plotBounds: Box, legend: ChartLegend): Box {\r\n        legend.performLayout();\r\n        if (!legend.overlayOnPlot) {\r\n            let left = 0;\r\n            let right = 0;\r\n            let top = 0;\r\n            let bottom = 0;\r\n            switch (legend.position) {\r\n                case ChartAxisPosition.Left:\r\n                    left += legend.bounds.width + ChartLegend.spacing;\r\n                    break;\r\n                case ChartAxisPosition.Right:\r\n                    right += legend.bounds.width + ChartLegend.spacing;\r\n                    break;\r\n                case ChartAxisPosition.Top:\r\n                    top += legend.bounds.height + ChartLegend.spacing;\r\n                    break;\r\n                case ChartAxisPosition.Bottom:\r\n                    bottom += legend.bounds.height + ChartLegend.spacing;\r\n                    break;\r\n            }\r\n            return plotBounds.subtractBorder(left, top, right, bottom);\r\n        }\r\n        // Legend over plot area, no update to plot bounds required.\r\n        return plotBounds;\r\n    }\r\n\r\n    private _subtractAxis(plotBounds: Box, axis: ChartAxis): Box {\r\n        const distance = axis.getMaxDistanceFromPlot();\r\n        let left = 0;\r\n        let right = 0;\r\n        let top = 0;\r\n        let bottom = 0;\r\n        switch (axis.position) {\r\n            case ChartAxisPosition.Left:\r\n                left += distance;\r\n                break;\r\n            case ChartAxisPosition.Right:\r\n                right += distance;\r\n                break;\r\n            case ChartAxisPosition.Top:\r\n                top += distance;\r\n                break;\r\n            case ChartAxisPosition.Bottom:\r\n                bottom += distance;\r\n                break;\r\n        }\r\n        return plotBounds.subtractBorder(left, top, right, bottom);\r\n    }\r\n}","import { ShapeBounds, ShapeAnchorMode } from \"./shape-bounds\";\r\nimport { Picture } from \"./picture\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { ChartSpace } from \"../chart/chart-space\";\r\nimport { Shape } from \"./shape\";\r\nimport { IRun } from \"../paragraph/paragraph\";\r\nimport { Box } from \"../utils/geometry/box\";\r\n\r\nexport enum WrapMode {\r\n    None,\r\n    Square,\r\n    Through,\r\n    Tight,\r\n    TopAndBottom\r\n}\r\n\r\nexport class DrawingRun implements IRun {\r\n    public bounds: ShapeBounds;\r\n    public wrapping: WrapMode;\r\n    public picture: Picture | undefined;\r\n    public chart: ChartSpace | undefined;\r\n    public shape: Shape | undefined;\r\n    public previousXPos: number | undefined;\r\n    public lastXPos: number | undefined;\r\n\r\n    constructor(bounds: ShapeBounds, wrapping: WrapMode) {\r\n        this.bounds = bounds;\r\n        this.wrapping = wrapping;\r\n    }\r\n\r\n    public getUsedWidth(): number {\r\n        return this.bounds.sizeX;\r\n    }\r\n\r\n    public getHeight(): number {\r\n        return this.bounds.sizeY;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow): void {\r\n        const bounds = this.bounds.getBox(flow);\r\n        const isFloating = this.bounds.anchor === ShapeAnchorMode.Floating;\r\n        if (this.picture !== undefined) {\r\n            this.picture.bounds = bounds;\r\n            this.picture.performLayout(flow);\r\n        }\r\n        if (this.chart !== undefined) {\r\n            this.chart.bounds = bounds;\r\n            this.chart.performLayout(flow);\r\n        }\r\n        if (this.shape !== undefined) {\r\n            this.shape.performLayout(bounds);\r\n        }\r\n        this.lastXPos = 0;\r\n        this._addObstacle(flow, bounds, isFloating);\r\n    }\r\n\r\n    private _addObstacle(flow: VirtualFlow, bounds: Box, isFloating: boolean): void {\r\n        const box = bounds.clone();\r\n        if (this.wrapping === WrapMode.TopAndBottom) {\r\n            box.width = flow.getWidth();\r\n        }\r\n        flow.addObstacle(box, isFloating);\r\n    }\r\n}","import { ChartSpace } from \"./chart-space\";\r\nimport { BaseChart } from \"./base-chart\";\r\n\r\nexport enum ChartOrientation {\r\n    Horizontal,\r\n    Vertical\r\n}\r\n\r\nexport class BarChart extends BaseChart {\r\n    public orientation = ChartOrientation.Horizontal;\r\n    constructor(space: ChartSpace) {\r\n        super(space);\r\n    }\r\n\r\n}","\r\n\r\nexport enum FractionType {\r\n    NoBar,\r\n    Bar,\r\n    Skewed,\r\n    Linear\r\n}\r\n\r\nexport class FractionStyle {\r\n    public type: FractionType = FractionType.NoBar;\r\n\r\n    public setType(typeStr: string | undefined): void {\r\n        switch (typeStr) {\r\n            case \"bar\":\r\n                this.type = FractionType.Bar;\r\n                break;\r\n            case \"skw\":\r\n                this.type = FractionType.Skewed;\r\n                break;\r\n            case \"lin\":\r\n                this.type = FractionType.Linear;\r\n                break;\r\n            case \"noBar\":\r\n            default:\r\n                this.type = FractionType.NoBar;\r\n                break;\r\n        }\r\n    }\r\n}","import { MatrixColumnStyle } from \"./matrix-column-style\";\r\n\r\nexport enum MatrixYAlign {\r\n    Inline,\r\n    Top,\r\n    Center,\r\n    Bottom,\r\n    Inside,\r\n    Outside\r\n}\r\n\r\nexport enum MatrixColumnXAlign {\r\n    Left,\r\n    Center,\r\n    Right,\r\n    Inside,\r\n    Outside\r\n}\r\n\r\nexport enum MatrixSpacingRule {\r\n    Single,\r\n    OneAndAHalf,\r\n    Two,\r\n    Exactly,\r\n    Multiple\r\n}\r\n\r\nexport class MatrixStyle {\r\n    public baseJustification: MatrixYAlign = MatrixYAlign.Inline;\r\n    public hidePlaceholder: boolean = false;\r\n    public rowSpacingRule: MatrixSpacingRule = MatrixSpacingRule.Single;\r\n    public rowSpacing: number = 1;\r\n    public columnGapRule: MatrixSpacingRule = MatrixSpacingRule.Single;\r\n    public columnGap: number = 1;\r\n    public columnMinimalWidth: number = 1;\r\n    public columnStyles: MatrixColumnStyle[] | undefined = undefined;\r\n\r\n    public setJustification(jcStr: string | undefined): void {\r\n        switch (jcStr) {\r\n            case \"inline\":\r\n            case \"top\":\r\n            case \"center\":\r\n            case \"bottom\":\r\n            case \"inside\":\r\n            case \"outside\":\r\n                break;\r\n        }\r\n    }\r\n}\r\n","import { Style } from \"../text/style\";\r\nimport { NamedStyles } from \"../text/named-styles\";\r\nimport { Xml } from \"../utils/xml\";\r\n\r\nexport enum NumberingFormat {\r\n    none = \"none\",\r\n    bullet = \"bullet\",\r\n    cardinalText = \"cardinalText\",\r\n    chicago = \"chicago\",\r\n    decimal = \"decimal\",\r\n    decimalEnclosedCircle = \"decimalEnclosedCircle\",\r\n    decimalEnclodedFullStop = \"decimalEnclosedFullstop\",\r\n    decimalEnclosedParentheses = \"decimalEnclosedParen\",\r\n    decimalZero = \"decimalZero\",\r\n    lowerLetter = \"lowerLetter\",\r\n    lowerRoman = \"lowerRoman\",\r\n    ordinalText = \"ordinalText\",\r\n    upperLetter = \"upperLetter\",\r\n    upperRoman = \"upperRoman\"\r\n}\r\n\r\nexport enum NumberingSuffix {\r\n    nothing = \"nothing\",\r\n    space = \"space\",\r\n    tab = \"tab\"\r\n} \r\n\r\nexport class NumberingLevel {\r\n    public index: number;\r\n    public style: Style = new Style();\r\n    public format: NumberingFormat = NumberingFormat.none;\r\n    public start: number | undefined = undefined;\r\n    public suffix: NumberingSuffix = NumberingSuffix.tab;\r\n    public text: string | undefined = undefined;\r\n\r\n    public static fromLevelNode(namedStyles: NamedStyles | undefined, levelNode: ChildNode): NumberingLevel | undefined {\r\n        const indexAttr = Xml.getAttribute(levelNode, \"w:ilvl\");\r\n        if (indexAttr === undefined) {\r\n            return undefined;\r\n        }\r\n        const index = parseInt(indexAttr, 10);\r\n        const level = new NumberingLevel(index);\r\n        level.style = Style.fromStyleNode(levelNode);\r\n        level.style.applyNamedStyles(namedStyles);\r\n        levelNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"w:start\":\r\n                    level.start = Xml.getNumberValue(child);\r\n                    break;\r\n                case \"w:suff\":\r\n                    const suffix = Xml.getStringValue(child);\r\n                    if (suffix !== undefined) {\r\n                        level.suffix = NumberingSuffix[suffix as keyof typeof NumberingSuffix];\r\n                    }                                \r\n                    break;\r\n                case \"w:numFmt\":\r\n                    const format = Xml.getStringValue(child);\r\n                    if (format !== undefined) {\r\n                        level.format = NumberingFormat[format as keyof typeof NumberingFormat];\r\n                    }\r\n                    break;\r\n                case \"w:lvlText\":\r\n                    level.text = Xml.getStringValue(child);\r\n                    break;\r\n                case \"w:lvlJc\":\r\n                case \"w:pPr\":\r\n                case \"w:rPr\":\r\n                case \"w:pStyle\":\r\n                    // Ignore, part of Style.\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Numbering Level reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return level;\r\n    }\r\n\r\n    constructor(index: number) {\r\n        this.index = index;\r\n    }\r\n\r\n    public getText(indices: number[]): string {\r\n        //if (this.text !== undefined) {\r\n        //    // Work around for FireFox 71+, crashing on non ASCII characters.\r\n        //   return (this.text === \"\") ? \"\" : \"-\";\r\n        //}\r\n        return this.getFormatted(indices);\r\n    }\r\n\r\n    private getFormatted(indices: number[]): string {\r\n        let text: string;\r\n        switch (this.format) {\r\n            case NumberingFormat.bullet:\r\n                text = \"&#x2002;\";\r\n                // Work around for FireFox 71+, crashing on non ASCII characters.\r\n                text = \"-\";\r\n                break;\r\n            case NumberingFormat.none:\r\n                text = \"\";\r\n                break;\r\n            case NumberingFormat.decimal:\r\n                text = indices.map(idx => idx.toString()).join(\".\");\r\n                break;\r\n            case NumberingFormat.lowerLetter:\r\n                text = indices.map(this._toDecimal).join(\".\");\r\n                break;\r\n            case NumberingFormat.upperLetter:\r\n                text = indices.map(this._toDecimal).join(\".\").toLocaleUpperCase();\r\n                break;\r\n            case NumberingFormat.lowerRoman:\r\n                text = indices.map(this._toRoman).join(\".\");\r\n                break;\r\n            case NumberingFormat.upperRoman:\r\n                text = indices.map(this._toRoman).join(\".\").toLocaleUpperCase();\r\n                break;\r\n            default:\r\n                console.log(`Don't know how to render numbering format ${this.format}`);\r\n                text = \"-\";\r\n                break;\r\n        }\r\n        return text;\r\n    }\r\n\r\n    private _toDecimal(num: number): string {\r\n        if (num > 26) {\r\n            return this._toDecimal(num / 26) + this._toDecimal(num % 26);\r\n        }\r\n        // 1 maps to a, which is charcode 97.\r\n        return String.fromCharCode(96 + Math.floor(num));\r\n    }\r\n\r\n    private _romanCodes = [\r\n        [\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"],         // Ones\r\n        [\"\",\"X\",\"XX\",\"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"],   // Tens\r\n        [\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"]];        // Hundreds\r\n\r\n    private _toRoman(num: number): string {\r\n        var numeral = \"\";\r\n        var digits = num.toString().split('').reverse();\r\n        for (let i = 0; i < digits.length; i++) {\r\n            numeral = this._romanCodes[i][parseInt(digits[i])] + numeral;\r\n        }\r\n        return numeral;  \r\n    }\r\n}","export class Point {\r\n    public x: number;\r\n    public y: number;\r\n\r\n    constructor(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public static difference(startPoint: Point, endPoint: Point): Point {\r\n        return new Point(startPoint.x - endPoint.x, startPoint.y - endPoint.y);\r\n    }\r\n\r\n    public translate(offset: Point): Point {\r\n        return new Point(this.x + offset.x, this.y + offset.y);\r\n    }\r\n\r\n    public scale(factor: number | Point): Point {\r\n        let factor1: number;\r\n        let factor2: number;\r\n        if (factor instanceof Point) {\r\n            factor1 = factor.x;\r\n            factor2 = factor.y;\r\n        } else {\r\n            factor1 = factor;\r\n            factor2 = factor;\r\n        }\r\n        return new Point(this.x * factor1, this.y * factor2);\r\n    }\r\n\r\n    public toString(): string {\r\n        return `(${this.x}, ${this.y})`;\r\n    }\r\n\r\n    public clone(): Point {\r\n        return new Point(this.x, this.y);\r\n    }\r\n}","import { InSequence } from \"../in-sequence\";\r\nimport { Point } from \"./point\";\r\nimport { TableBorderSet } from \"../../table/table-border-set\";\r\nimport { TableMarginSet } from \"../../table/table-margin-set\";\r\n\r\nexport class Box {\r\n    public x: number;\r\n    public y: number;\r\n    public width: number;\r\n    public height: number;\r\n\r\n    constructor(x: number, y: number, width: number, height: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    public get left(): number {\r\n        return this.x;\r\n    }\r\n\r\n    public get top(): number {\r\n        return this.y;\r\n    }\r\n\r\n    public get right(): number {\r\n        return this.x + this.width;\r\n    }\r\n\r\n    public get bottom(): number {\r\n        return this.y + this.height;\r\n    }\r\n\r\n    public get topLeft(): Point {\r\n        return new Point(this.left, this.top);\r\n    }\r\n\r\n    public get topRight(): Point {\r\n        return new Point(this.right, this.top);\r\n    }\r\n\r\n    public get bottomLeft(): Point {\r\n        return new Point(this.left, this.bottom);\r\n    }\r\n\r\n    public get bottomRight(): Point {\r\n        return new Point(this.right, this.bottom);\r\n    }\r\n\r\n    public translate(x: number, y: number): Box {\r\n        return new Box(this.x + x, this.y + y, this.width, this.height);\r\n    }\r\n\r\n    public addBorder(left: number, top: number, right: number, bottom: number): Box {\r\n        return new Box(this.x - left, this.y - top, this.width + left + right, this.height + top + bottom);\r\n    }\r\n\r\n    public addBordersAndMargins(set: TableBorderSet, margins: TableMarginSet, _rowOrder: InSequence, _columnOrder: InSequence): Box {\r\n        const start = ((set.borderStart !== undefined) ? set.borderStart.size : 0) + margins.cellMarginStart;\r\n        const end = ((set.borderEnd !== undefined) ? set.borderEnd.size : 0) + margins.cellMarginEnd;\r\n        const top = ((set.borderTop !== undefined) ? set.borderTop.size : 0) + margins.cellMarginTop;\r\n        const bottom = ((set.borderBottom !== undefined) ? set.borderBottom.size : 0) + margins.cellMarginBottom;\r\n        return this.addBorder(start, top, end, bottom);\r\n    }\r\n\r\n    public addSpacing(spacing: number): Box {\r\n        return this.addBorder(spacing, spacing, spacing, spacing);\r\n    }\r\n\r\n    public subtractBorder(left: number, top: number, right: number, bottom: number): Box {\r\n        return new Box(this.x + left, this.y + top, this.width - left - right, this.height - top - bottom);\r\n    }\r\n\r\n    public subtractBordersAndMargins(set: TableBorderSet, margins: TableMarginSet, _rowOrder: InSequence, _columnOrder: InSequence): Box {\r\n        const start = ((set.borderStart !== undefined) ? set.borderStart.size : 0) + margins.cellMarginStart;\r\n        const end = ((set.borderEnd !== undefined) ? set.borderEnd.size : 0) + margins.cellMarginEnd;\r\n        const top = ((set.borderTop !== undefined) ? set.borderTop.size : 0) + margins.cellMarginTop;\r\n        const bottom = ((set.borderBottom !== undefined) ? set.borderBottom.size : 0) + margins.cellMarginBottom;\r\n        return this.subtractBorder(start, top, end, bottom);\r\n    }\r\n\r\n    public subtractSpacing(spacing: number): Box {\r\n        return this.subtractBorder(spacing, spacing, spacing, spacing);\r\n    }\r\n\r\n    public includePoint(x: number, y: number): Box;\r\n    public includePoint(point: Point): Box;\r\n    public includePoint(arg1: number | Point, arg2?: number): Box {\r\n        const x = (arg1 instanceof Point) ? arg1.x : arg1;\r\n        const y = (arg1 instanceof Point) ? arg1.y : arg2!;\r\n        const newX = Math.min(this.x, x);\r\n        const newY = Math.min(this.y, y);\r\n        const newWidth = Math.max(this.x + this.width, x + this.width) - newX;\r\n        const newHeight = Math.min(this.y + this.height, y + this.height) - newY;\r\n        return new Box(newX, newY, newWidth, newHeight);\r\n    }\r\n\r\n    public placeInRectangle(width: number, height: number, xPos: InSequence, yPos: InSequence): Box {\r\n        let x = 0;\r\n        let y = 0;\r\n        if (xPos === InSequence.Middle) {\r\n            x = this.x + (this.width / 2) - (width / 2);\r\n        } else if (xPos === InSequence.Last) {\r\n            x = this.right - width;\r\n        }\r\n        if (yPos === InSequence.Middle) {\r\n            y = this.y + (this.height / 2) - (height / 2);\r\n        } else if (xPos === InSequence.Last) {\r\n            y = this.bottom - height;\r\n        }\r\n        return new Box(x, y, width, height);\r\n    }\r\n\r\n    public addOnTopOf(other: Box, spacing: number = 0): Box {\r\n        const width = Math.max(this.width, other.width);\r\n        const height = this.height + other.height + spacing;\r\n        return new Box(this.x, this.y, width, height);\r\n    }\r\n\r\n    public addInFrontOf(other: Box, spacing: number = 0): Box {\r\n        const width = this.width + other.width + spacing;\r\n        const height = Math.max(this.height, other.height);\r\n        return new Box(this.x, this.y, width, height);\r\n    }\r\n\r\n    public intersectX(x: number): boolean {\r\n        return this.left <= x && this.right >= x;\r\n    }\r\n\r\n    public intersectY(y: number): boolean {\r\n        return this.top <= y && this.bottom >= y;\r\n    }\r\n\r\n    public intersectPoint(point: Point): boolean {\r\n        return this.intersectX(point.x) && this.intersectY(point.y);\r\n    }\r\n\r\n    public clone(): Box {\r\n        return new Box(this.x, this.y, this.width, this.height);\r\n    }\r\n\r\n    public toString(): string {\r\n        return `{${this.x}, ${this.y}, ${this.width}, ${this.height}}`;\r\n    }\r\n}","import { Section } from \"../section\";\r\nimport { ShapePositionReference } from \"../drawing/shape-bounds\";\r\nimport { TabStop } from \"../paragraph/tab-stop\";\r\nimport { Box } from \"./geometry/box\";\r\n\r\nclass Obstacle {\r\n    public bounds: Box;\r\n    public isFloating: boolean;\r\n\r\n    constructor(bounds: Box, isFloating: boolean = false) {\r\n        this.bounds = bounds;\r\n        this.isFloating = isFloating;\r\n    }\r\n}\r\n\r\nexport class VirtualFlow {\r\n    // private _width: number;\r\n    private _xMin: number;\r\n    private _xMax: number;\r\n    // private _pageHeight: number;\r\n    private _pos: number;\r\n    private _lastParPos: number = 0;\r\n    private _lastCharX: number = 0;\r\n    private _stops: TabStop[] = [];\r\n    private _nums: any = {};\r\n    private _obstacles: Obstacle[] = [];\r\n\r\n    public static fromSection(section: Section | undefined): VirtualFlow {\r\n        const flow = new VirtualFlow(40, 700 - 40);\r\n        // this._width = content.clientWidth - 2 * 40;\r\n        // this._pageHeight = 400;\r\n        if (section !== undefined) {\r\n            let pageWidth = 700;\r\n            if (section.pageWidth !== undefined) {\r\n                pageWidth = section.pageWidth;\r\n            }\r\n            const pageHeight = section.pageHeight;\r\n            if (pageHeight !== undefined) {\r\n                // this._pageHeight = Metrics.convertPointsToPixels(pageHeight);\r\n            }\r\n            const marginLeft = section.marginLeft;\r\n            if (marginLeft !== undefined) {\r\n                flow._xMin = marginLeft;\r\n            }\r\n            const marginRight = section.marginRight;\r\n            if (marginRight !== undefined) {\r\n                flow._xMax = pageWidth - marginRight;\r\n            }\r\n        };\r\n        return flow;\r\n    }\r\n\r\n    constructor(xMin: number, xMax: number, position: number = 0) {\r\n        this._xMin = xMin;\r\n        this._xMax = xMax;\r\n        this._pos = position;\r\n    }\r\n\r\n    public getX(needsWidth: number = 0): number {\r\n        let x = this._xMin;\r\n        const obstacle = this._getApplicableObstacle();\r\n        if (obstacle !== undefined) {\r\n            // Is obstacle all the width?\r\n            const isWide = obstacle.bounds.width >= ((this._xMax - this._xMin) - needsWidth);\r\n            if (isWide) {\r\n                this.advancePosition(obstacle.bounds.height);\r\n            } else {\r\n                // TODO: Remove assumption that obstacle is to the left of the page\r\n                x = obstacle.bounds.right;\r\n            }\r\n        }\r\n        return x;\r\n    }\r\n\r\n    public getReferenceX(reference: ShapePositionReference, width: number): number {\r\n        let x = this.getX(width);\r\n        // TODO: Support more reference modes.\r\n        switch(reference) {\r\n            case ShapePositionReference.Character:\r\n                x = this._lastCharX;\r\n                break;\r\n            case ShapePositionReference.None:\r\n            case ShapePositionReference.Column:\r\n            default:\r\n                x = this._xMin;\r\n                break;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    public getY(): number {\r\n        return this._pos;\r\n    }\r\n\r\n    public getMaxY(includeFloating: boolean): number {\r\n        let maxY = this._pos;\r\n        this._obstacles.forEach(obstacle => {\r\n            if (!obstacle.isFloating || (includeFloating && obstacle.isFloating)) {\r\n                maxY = Math.max(maxY, obstacle.bounds.bottom);\r\n            }\r\n        });\r\n        return maxY;\r\n    }\r\n\r\n    public getReferenceY(reference: ShapePositionReference): number {\r\n        let pos = this._pos;\r\n        // TODO: Support more reference modes.\r\n        switch(reference) {\r\n            case ShapePositionReference.Paragraph:\r\n                pos = this._lastParPos;\r\n                break;\r\n            default:\r\n                pos = this._pos;\r\n                break;\r\n        }\r\n        return pos;\r\n    }\r\n\r\n    public getWidth(): number {\r\n        let width = this._xMax - this._xMin;\r\n        const obstacle = this._getApplicableObstacle();\r\n        if (obstacle !== undefined) {\r\n            width -= obstacle.bounds.width;\r\n        }\r\n        return width;\r\n    }\r\n\r\n    public addObstacle(bounds: Box, isFloating: boolean): void {\r\n        this._obstacles.push(new Obstacle(bounds, isFloating));\r\n    }\r\n\r\n    public copyObstaclesFrom(other: VirtualFlow): void {\r\n        other._obstacles.forEach(obstacle => {\r\n            return this.addObstacle(obstacle.bounds, obstacle.isFloating);\r\n        });\r\n    }\r\n\r\n    public advanceX(startDelta: number, endDelta: number): VirtualFlow {\r\n        this._xMin += startDelta;\r\n        this._xMax -= startDelta - endDelta;\r\n        return this;\r\n    }\r\n\r\n    public advancePosition(delta: number): VirtualFlow {\r\n        this._pos += delta;\r\n        return this;\r\n    }\r\n\r\n    public advanceNumbering(numId: number, level: number): void {\r\n        const id = `${numId}-${level}`;\r\n        const currentNum = this._nums[id];\r\n        if (currentNum === undefined) {\r\n            this._nums[id] = 2;\r\n        } else {\r\n            this._nums[id] = currentNum + 1;\r\n        }\r\n    }\r\n\r\n    public getNumbering(numId: number, level: number): number {\r\n        const id = `${numId}-${level}`;\r\n        return this._nums[id] || 1;\r\n    }\r\n\r\n    public getTab(index: number): TabStop {\r\n        return this._stops[index];\r\n    }\r\n\r\n    public addTabStop(tabStop: TabStop): void {\r\n        this._stops.push(tabStop);\r\n    }\r\n\r\n    public removeTabStop(): void {\r\n        this._stops.pop();\r\n    }\r\n\r\n    public mentionParagraphPosition(): void {\r\n        this._lastParPos = this._pos;\r\n    }\r\n\r\n    public mentionCharacterPosition(xDelta: number): void {\r\n        this._lastCharX = this._xMin + xDelta;\r\n    }\r\n\r\n    public clone(): VirtualFlow {\r\n        const cloned = new VirtualFlow(this._xMin, this._xMax, this._pos);\r\n        cloned._stops = this._stops;\r\n        cloned._nums = this._nums;\r\n        cloned._obstacles = this._obstacles;\r\n        return cloned;\r\n    }\r\n\r\n    private _getApplicableObstacle(): Obstacle | undefined {\r\n        let found: Obstacle | undefined = undefined;\r\n        for (let i = 0; i < this._obstacles.length; i++) {\r\n            if (this._obstacles[i].bounds.intersectY(this._pos)) {\r\n                found = this._obstacles[i];\r\n                break;\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n}","import { Style } from \"../text/style\";\r\n\r\nexport class Metrics {\r\n\r\n  /**\r\n   * Convert twentieths of a point in DocX coordinates to SVG pixels.\r\n   * @param twips Twentieths of a point.\r\n   */\r\n  public static convertTwipsToPixels(twips: number): number {\r\n    // Normal screen is 28 dots per inch\r\n    // 20 twips = 1 point\r\n    // 72 points = 1 inch\r\n    // 1440 twips = 1 inch\r\n    // (567 twips = 1 cm)\r\n    // (1 point = 1.333333 px)\r\n    return twips / 15;\r\n  }\r\n\r\n  /**\r\n   * Convert a number of point in DocX coordinates to SVG pixels.\r\n   * @param points DocX point.\r\n   */\r\n  public static convertPointToPixels(points: number): number {\r\n    return Metrics.convertTwipsToPixels(points * 20);\r\n  }\r\n\r\n  /**\r\n   * Convert EMU's (used in DrawingML) to SVG pixels.\r\n   * @param emu EMU's to convert into pixels.\r\n   */\r\n  public static convertEmuToPixels(emu: number): number {\r\n    // 1 inch = 914400 EMU\r\n    // 1 inch = 72 points\r\n    // 1 point = 1270 EMU\r\n    return Metrics.convertPointToPixels(emu / 12700);\r\n  }\r\n\r\n  /**\r\n   * Convert a number of point in Word coordinates to SVG font size\r\n   * @param points Word point.\r\n   */\r\n  public static convertPointToFontSize(points: number): number {\r\n    return points * 46 / 72;\r\n  }\r\n\r\n  /**\r\n   * Convert rotation to radians.\r\n   * @param rot Rotation in 60000th of a degree.\r\n   */\r\n  public static convertRotationToRadians(rot: number): number {\r\n    return (rot * Math.PI) / (180 * 60000);\r\n  }\r\n\r\n  public static getTextWidth(text: string, style: Style) {\r\n    return this.getTextWidthFromCanvas(text, style);\r\n  }\r\n\r\n  public static getTextWidthFromSvg(text: string, style: Style) {\r\n    var element = document.createElementNS('http://www.w3.org/2000/svg', 'text');\r\n    element.setAttribute('font-family', style.fontFamily);\r\n    element.setAttribute('font-size', `${style.fontSize}`);\r\n    if (style.bold) {\r\n      element.setAttribute('font-weight', 'bold');\r\n    }\r\n    if (style.italic) {\r\n      element.setAttribute('font-style', 'italic');\r\n    }\r\n    const node = document.createTextNode(text);\r\n    element.appendChild(node);\r\n    this.svg.appendChild(element);\r\n    const width = element.getComputedTextLength();\r\n    // const width = element.getBBox().width;\r\n    // const width = element.getBoundingClientRect().width;\r\n    this.svg.removeChild(element);\r\n    return width;\r\n  }\r\n\r\n  public static getTextWidthFromCanvas(\r\n    text: string,\r\n    style: Style\r\n  ): number {\r\n    const metrics = this.getTextMetrics(text, style);\r\n    return metrics.width;\r\n  }\r\n\r\n  public static getTextMetrics(text: string, style: Style) {\r\n    const italicText = (style.italic) ? \"italic \": \"\";\r\n    const boldText = (style.bold) ? \"bold \": \"\";\r\n    this.context.font = italicText + boldText + Math.round(style.fontSize) + 'px ' + style.fontFamily;\r\n    const metrics = this.context.measureText(text);\r\n    return metrics;\r\n  }\r\n\r\n  public static init(): void {\r\n    if (this.canvas === undefined) {\r\n      this.canvas = document.createElement('canvas');\r\n      this.context = this.canvas.getContext('2d')!;\r\n      this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\r\n      this.svg.setAttribute('width', '1000');\r\n      this.svg.setAttribute('height', '240');\r\n      this.svg.setAttribute('visibility', 'hidden');\r\n      document.body.appendChild(this.svg);\r\n    }\r\n  }\r\n\r\n  private static canvas: HTMLCanvasElement | undefined;\r\n  private static context: CanvasRenderingContext2D;\r\n  private static svg: SVGElement;\r\n}\r\n","export class Xml {\r\n\r\n    public static loadFromUrl(url: string): Promise<Document> {\r\n        return new Promise<Document>((resolve, reject) => {\r\n            var oReq = new XMLHttpRequest();\r\n            oReq.open(\"GET\", url, true);\r\n            oReq.responseType = \"text\";\r\n            \r\n            oReq.onload = (_oEvent) => {\r\n                if (oReq.status === 200) {\r\n                    var text = oReq.response as string;\r\n                    const doc = new DOMParser().parseFromString(text, \"application/xml\");\r\n                    resolve(doc);\r\n                } else {\r\n                    reject(`File not found: ${url}`);\r\n                }\r\n            };\r\n            oReq.onerror = (evt) => {\r\n                reject(evt);\r\n            }\r\n            oReq.send(null);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the value of the attribute.\r\n     * @param node Node to get the attribute from.\r\n     * @param name Name of the attribute to get from the node.\r\n     */\r\n    public static getAttribute(node: Node, name: string): string | undefined {\r\n        let val: string | undefined = undefined;\r\n        const element = node as Element;\r\n        const attrVal = element.getAttribute(name);\r\n        if (attrVal !== null) {\r\n            val = attrVal;\r\n        }\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Get first of the direct child nodes which have nodeName equal to name.\r\n     * @param parent The node under which to search for nodes.\r\n     * @param name  The node name to search for.\r\n     */\r\n    public static getFirstChildOfName(parent: Node, name: string | string[]): ChildNode | undefined {\r\n        if (!Array.isArray(name)) {\r\n            return this.getFirstChildOfName(parent, [name]);\r\n        }\r\n        let child: ChildNode | undefined = undefined;\r\n        const children = parent.childNodes;\r\n        for (let i = 0; i < children.length; i++) {\r\n            if (name.indexOf(children[i].nodeName) !== -1) {\r\n                child = children[i];\r\n                break;\r\n            }\r\n        }\r\n        return child;\r\n    }\r\n\r\n    /**\r\n     * Get the \"w:val\" attribute as string, from the node.\r\n     */\r\n    public static getStringValue(node: Node): string | undefined {\r\n        let val: string | undefined = undefined;\r\n        let attr = Xml.getAttribute(node, \"w:val\");\r\n        if (attr !== undefined) {\r\n            val = attr;\r\n        } else {\r\n            attr = Xml.getAttribute(node, \"val\");\r\n            if (attr !== undefined) {\r\n                val = attr;\r\n            } else {\r\n                attr = Xml.getAttribute(node, \"m:val\");\r\n                if (attr !== undefined) {\r\n                    val = attr;\r\n                }\r\n            }\r\n        }\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Get the \"w:val\" attribute as string, from the child node with the specified name.\r\n     */\r\n    public static getStringValueFromNode(parent: ChildNode, name: string): string | undefined {\r\n        let val: string | undefined = undefined;\r\n        const child = Xml.getFirstChildOfName(parent, name) as Element;\r\n        if (child !== undefined) {\r\n            val = Xml.getStringValue(child);\r\n        }\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Get the \"w:val\" attribute as boolean, from the node.\r\n     */\r\n    public static getBooleanValue(node: Node): boolean | undefined {\r\n        let val: boolean | undefined = undefined;\r\n        const attr = Xml.getStringValue(node);\r\n        if (attr !== undefined) {\r\n            val = Xml.attributeAsBoolean(attr);\r\n        } else {\r\n            // Absence of w:val means true\r\n            val = true;\r\n        }\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Get the \"w:val\" attribute as boolean, from the child node with the specified name.\r\n     */\r\n    public static getBooleanValueFromNode(parent: ChildNode, name: string): boolean | undefined {\r\n        let val: boolean | undefined = undefined;\r\n        const child = Xml.getFirstChildOfName(parent, name) as Element;\r\n        if (child !== undefined) {\r\n            val = Xml.getBooleanValue(child);\r\n        }\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Get the \"w:val\" attribute as boolean, from the node.\r\n     */\r\n    public static getNumberValue(node: ChildNode): number | undefined {\r\n        let val: number | undefined = undefined;\r\n        const attr = Xml.getStringValue(node);\r\n        if (attr !== undefined) {\r\n            val = parseFloat(attr);\r\n        }\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Get the \"w:val\" attribute as boolean, from the child node with the specified name.\r\n     */\r\n    public static getNumberValueFromNode(parent: ChildNode, name: string): number | undefined {\r\n        let val: number | undefined = undefined;\r\n        const child = Xml.getFirstChildOfName(parent, name);\r\n        if (child !== undefined) {\r\n            val = Xml.getNumberValue(child);\r\n        }\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Interprets the attribute value as boolean.\r\n     */\r\n    public static attributeAsBoolean(attr: string): boolean {\r\n        return (attr === 'true') || (attr === '1');\r\n    }\r\n}","import { AbstractNumberings } from \"./abstract-numberings\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { NumberingLevel } from \"./numbering-level\";\r\nimport { Style } from \"../text/style\";\r\n\r\nexport class NumberingStyle {\r\n    public numId: number; \r\n    public level: NumberingLevel | undefined;\r\n    private _levelIndex: number;\r\n\r\n    public static fromNumPresentationNode(numPrNode: ChildNode | undefined): NumberingStyle | undefined {\r\n        let style: NumberingStyle | undefined = undefined;\r\n        if (numPrNode) {\r\n            const indexAttr = Xml.getStringValueFromNode(numPrNode, \"w:ilvl\");\r\n            const numIdAttr = Xml.getStringValueFromNode(numPrNode, \"w:numId\");\r\n            if (indexAttr !== undefined && numIdAttr !== undefined) {\r\n                const index = parseInt(indexAttr);\r\n                const numId = parseInt(numIdAttr);\r\n                style = new NumberingStyle(numId, index);\r\n            }\r\n        }\r\n        return style;\r\n    }\r\n\r\n    constructor(numId: number, levelIndex: number) {\r\n        this.numId = numId;\r\n        this._levelIndex = levelIndex;\r\n    }\r\n\r\n    public getPrefixText(indices: number[]): string {\r\n        return (this.level) ? this.level.getText(indices) : \"\";\r\n    }\r\n\r\n    public get style(): Style | undefined {\r\n        let style: Style | undefined = undefined;\r\n        if (this.level !== undefined) {\r\n            style = this.level.style;\r\n        }\r\n        return style;\r\n    }\r\n\r\n    public applyNumberings(numberings: AbstractNumberings | undefined): void {\r\n        if (numberings !== undefined) {\r\n            const numbering = numberings.getNumberingById(this.numId);\r\n            if (numbering !== undefined) {\r\n                this.level = numbering.getLevel(this._levelIndex);\r\n            } else {\r\n                console.log(`Could not find numbering ID ${this.numId}`);\r\n            }\r\n        }\r\n    }\r\n}","import { NamedStyles } from \"./named-styles\";\r\nimport { ParStyle, Justification } from \"../paragraph/par-style\";\r\nimport { RunStyle, UnderlineMode } from \"./run-style\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\nimport { TableStyle } from \"../table/table-style\";\r\nimport { Emphasis } from \"./positioned-text-line\";\r\n\r\nexport class Style {\r\n    private _basedOn: Style | undefined;\r\n    private _basedOnId: string | undefined;\r\n\r\n    public runStyle: RunStyle;\r\n    public parStyle: ParStyle;\r\n    public tableStyle: TableStyle | undefined;\r\n\r\n    public static fromDocDefaultsNode(docDefaultsNode: ChildNode): Style {\r\n        let parStyle: ParStyle | undefined = undefined;\r\n        let runStyle: RunStyle | undefined = undefined;\r\n        const runDefaults = Xml.getFirstChildOfName(docDefaultsNode, \"w:rPrDefault\");\r\n        if (runDefaults !== undefined) {\r\n            const runStyleNode = Xml.getFirstChildOfName(runDefaults, \"w:rPr\");\r\n            if (runStyleNode !== undefined) {\r\n                runStyle = RunStyle.fromPresentationNode(runStyleNode);\r\n            }\r\n        }\r\n        const parDefaults = Xml.getFirstChildOfName(docDefaultsNode, \"w:pPrDefault\");\r\n        if (parDefaults !== undefined) {\r\n            const parStyleNode = Xml.getFirstChildOfName(parDefaults, \"w:pPr\");\r\n            if (parStyleNode !== undefined) {\r\n                parStyle = ParStyle.fromParPresentationNode(parStyleNode);\r\n            }\r\n        }\r\n        return new Style(parStyle, runStyle);\r\n    }\r\n\r\n    public static fromStyleNode(styleNode: ChildNode): Style {\r\n        let parStyle: ParStyle | undefined = undefined;\r\n        let runStyle: RunStyle | undefined = undefined;\r\n        let basedOnId: string | undefined = undefined;\r\n        styleNode.childNodes.forEach(child => {\r\n            // ISO/IEC 29500-1:2016 section: 17.7.4\r\n            switch (child.nodeName) {\r\n                case \"w:pPr\":\r\n                    parStyle = ParStyle.fromParPresentationNode(child);\r\n                    break;\r\n                case \"w:rPr\":\r\n                    runStyle = RunStyle.fromPresentationNode(child);\r\n                    break;\r\n                case \"w:basedOn\":\r\n                    basedOnId = Xml.getStringValue(child);\r\n                    break;\r\n                case \"w:name\":\r\n                case \"w:aliases\":\r\n                case \"w:autoRedefine\":\r\n                case \"w:qFormat\":\r\n                case \"w:semiHidden\":\r\n                case \"w:uiPriority\":\r\n                case \"w:unhideWhenUsed\":\r\n                case \"w:rsid\":\r\n                case \"w:locked\":\r\n                case \"w:lsdException\":\r\n                case \"w:personal\":\r\n                case \"w:personalCompose\":\r\n                case \"w:personalReply\":\r\n                    // Ignore\r\n                    break;\r\n                case \"w:start\":\r\n                case \"w:lvlText\":\r\n                case \"w:lvlJc\":\r\n                case \"w:numFmt\":\r\n                case \"w:suff\":\r\n                    // Ignore, Numbering style related.\r\n                    break;\r\n                case \"w:next\":\r\n                case \"w:link\":\r\n                case \"w:tblPr\":\r\n                case \"w:hidden\":\r\n                case \"w:latentStyles\":\r\n                case \"w:pStyle\":\r\n                    // TODO: Read these attributes\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Style reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        const style = new Style(parStyle, runStyle);\r\n        style._basedOnId = basedOnId;\r\n        return style;\r\n    }\r\n\r\n    public static readShading(shadingNode: ChildNode): string | undefined {\r\n        let shadingColor: string | undefined = undefined;\r\n        // TODO: Parse patterns also.\r\n        const fillAttr = Xml.getAttribute(shadingNode, \"w:fill\");\r\n        if (fillAttr !== undefined) {\r\n            shadingColor = fillAttr;\r\n        }\r\n        return shadingColor;\r\n    }\r\n\r\n    constructor(parStyle?: ParStyle, runStyle?: RunStyle) {\r\n        this.parStyle = (parStyle !== undefined) ? parStyle : new ParStyle();\r\n        this.runStyle = (runStyle !== undefined) ? runStyle : new RunStyle();\r\n    }\r\n\r\n    public applyNamedStyles(namedStyles: NamedStyles | undefined): void {\r\n        if (this._basedOnId !== undefined && namedStyles !== undefined) {\r\n            const baseStyle = namedStyles.getNamedStyle(this._basedOnId);\r\n            if (baseStyle !== undefined) {\r\n                this._basedOn = baseStyle;\r\n            }\r\n        }\r\n        if (this.runStyle !== undefined) {\r\n            this.runStyle.applyNamedStyles(namedStyles);\r\n        }\r\n        if (this.parStyle !== undefined) {\r\n            this.parStyle.applyNamedStyles(namedStyles);\r\n        }\r\n    }\r\n\r\n    public get italic(): boolean {\r\n        return this.getValue(false, undefined, (runStyle) => runStyle._italic);\r\n    }\r\n\r\n    public get bold(): boolean {\r\n        return this.getValue(false, undefined, (runStyle) => runStyle._bold);\r\n    }\r\n\r\n    public get underlineMode(): UnderlineMode {\r\n        return this.getValue(UnderlineMode.None, undefined, (runStyle) => runStyle._underlineMode);\r\n    }\r\n\r\n    public get strike(): boolean {\r\n        return this.getValue(false, undefined, (runStyle) => runStyle._strike);\r\n    }\r\n\r\n    public get doubleStrike(): boolean {\r\n        return this.getValue(false, undefined, (runStyle) => runStyle._dstrike);\r\n    }\r\n\r\n    public get fontFamily(): string {\r\n        return this.getValue(\"Arial\", undefined, (runStyle) => runStyle._fontFamily);\r\n    }\r\n\r\n    public get fontSize(): number {\r\n        return this.getValue(12, undefined, (runStyle) => runStyle._fontSize);\r\n    }\r\n\r\n    public get charSpacing(): number {\r\n        return this.getValue(0, undefined, (runStyle) => runStyle._charSpacing);\r\n    }\r\n\r\n    public get charStretch(): number {\r\n        return this.getValue(1, undefined, (runStyle) => runStyle._charStretch);\r\n    }\r\n\r\n    public get lineSpacing(): number {\r\n        const style = this;\r\n        let complexSpacing = this.getValue(\r\n            undefined,\r\n            (parStyle) => {\r\n                return parStyle.getLineSpacing(style);\r\n            },\r\n            undefined\r\n        );\r\n        if (complexSpacing === undefined) {\r\n            complexSpacing = this.fontSize * 1.08;\r\n        }\r\n        return complexSpacing;\r\n    }\r\n\r\n    public get shadingColor(): string {\r\n        return this.getValue(\"000000\", (parStyle) => parStyle.shadingColor, (runStyle) => runStyle._shadingColor);\r\n    }\r\n\r\n    public getIndentation(inRun: InSequence, inParagaph: InSequence): number {\r\n        let identation = this.getValue(0, (parStyle) => parStyle.indentation, undefined);\r\n        if (\r\n            (inParagaph === InSequence.First || inParagaph === InSequence.Only) &&\r\n            (inRun === InSequence.First || inRun === InSequence.Only)\r\n        ) {\r\n            const hanging = this.getValue(undefined, (parStyle) => parStyle.hanging, undefined);\r\n            if (hanging !== undefined) {\r\n                identation -= hanging;\r\n            }\r\n        }\r\n        return identation!;\r\n    }\r\n\r\n    public get caps(): boolean {\r\n        return this.getValue(false, undefined, (runStyle) => runStyle._caps);\r\n    }\r\n\r\n    public get smallCaps(): boolean {\r\n        return this.getValue(false, undefined, (runStyle) => runStyle._smallCaps);\r\n    }\r\n\r\n    public get color(): string {\r\n        return this.getValue(\"000000\", undefined, (runStyle) => runStyle._color);\r\n    }\r\n\r\n    public get justification(): Justification {\r\n        return this.getValue(Justification.left, (parStyle) => parStyle.justification, undefined);\r\n    }\r\n\r\n    public get invisible(): boolean {\r\n        return this.getValue(false, undefined, (runStyle) => runStyle._invisible);\r\n    }\r\n\r\n    public get emphasis(): Emphasis {\r\n        let emphasis = Emphasis.Normal;\r\n        if (this.bold) {\r\n            emphasis |= Emphasis.Bold;\r\n        }\r\n        if (this.italic) {\r\n            emphasis |= Emphasis.Italic;\r\n        }\r\n        if (this.smallCaps) {\r\n            emphasis |= Emphasis.SmallCaps;\r\n        }\r\n        return emphasis;\r\n    }\r\n\r\n    public get font(): string {\r\n        const italicText = (this.italic) ? \"italic \": \"\";\r\n        const boldText = (this.bold) ? \"bold \": \"\";\r\n        const font = italicText + boldText + Math.round(this.fontSize) + 'px ' + this.fontFamily;\r\n        return font;\r\n    }\r\n\r\n    public toString(): string {\r\n        const base = (this._basedOnId !== undefined) ? `base=${this._basedOnId}` : \"\";\r\n        const just = `jc=${this.justification.toString()}`;\r\n        const ind = `ind=${this.getIndentation(InSequence.First, InSequence.First).toString()}`;\r\n        const hang = `ind=${this.getIndentation(InSequence.Middle, InSequence.Middle).toString()}`;\r\n        const i = `i=${this.italic}`;\r\n        const b = `b=${this.bold.toString()}`;\r\n        const u = `u=${this.underlineMode.toString()}`;\r\n        const strike = `strike=${this.strike.toString()}`;\r\n        const font = `font=${this.fontFamily.toString()}`;\r\n        const size = `size=${this.fontSize.toString()}`;\r\n        const dstrike = `dstrike=${this.doubleStrike.toString()}`;\r\n        const charSpacing = `char_spacing=${this.charSpacing.toString()}`;\r\n        const lineSpacing = `line_spacing=${this.lineSpacing.toString()}`;\r\n        const color = `color=${this.color.toString()}`;\r\n        const caps = `caps=${this.caps.toString()}`;\r\n        const smallcaps = `smallcaps=${this.smallCaps.toString()}`;\r\n        return `Style: ${base} ${just} ${ind} ${hang} ${i} ${b} ${u} ${strike} ${font} ${size} ${dstrike} ${charSpacing} ${lineSpacing} ${color} ${caps} ${smallcaps}`;\r\n    }\r\n\r\n    private getValue<T>(initial: T, parCb?: (parStyle: ParStyle) => T | undefined, runCb?: (runStyle: RunStyle) => T | undefined): T {\r\n        let val = this.getRecursive(parCb, runCb);\r\n        // If still not defined, assign the initial value.\r\n        if (val === undefined) {\r\n            val = initial;\r\n        }\r\n        return val;\r\n    }\r\n\r\n    private getRecursive<T>(\r\n        parCb?: (parStyle: ParStyle) => T | undefined,\r\n        runCb?: (runStyle: RunStyle) => T | undefined,\r\n        tableCb?: (runStyle: TableStyle) => T | undefined\r\n    ): T | undefined {\r\n        // Style hierarchy:\r\n        // 1 Document defaults\r\n        // 2 Table styles\r\n        // 3 Numbering styles\r\n        // 4 Paragraph styles\r\n        // 5 Run styles\r\n        // 6 Local Styles\r\n        // We inspect the hierarchy backward, for performance reasons\r\n        let val: T | undefined = undefined;\r\n        // First look at local RUN presentation.\r\n        if (this.runStyle !== undefined) {\r\n            if (runCb !== undefined) {\r\n                const localRun = runCb(this.runStyle);\r\n                if (localRun !== undefined) {\r\n                    val = localRun;\r\n                }\r\n            }\r\n            const runParent = this.runStyle.parent;\r\n            if (val === undefined && runParent !== undefined) {\r\n                // Secondly look at the base styles of the RUN style.\r\n                val = runParent.getRecursive<T>(parCb, runCb);\r\n            }\r\n        }\r\n        // Thirdly look at local PARAGRAPH presentation.\r\n        if (val === undefined) {\r\n            if (this.parStyle !== undefined) {\r\n                if (parCb !== undefined) {\r\n                    const localPar = parCb(this.parStyle);\r\n                    if (localPar !== undefined) {\r\n                        val = localPar;\r\n                    }\r\n                }\r\n                const parRunStyle = this.parStyle.runStyle;\r\n                if (val === undefined && runCb !== undefined && parRunStyle !== undefined) {\r\n                    val = runCb(parRunStyle);\r\n                }\r\n                if (val === undefined && this.parStyle.numStyle !== undefined) {\r\n                    // Fourthly look at the numbering style.\r\n                    const numStyle = this.parStyle.numStyle.style;\r\n                    if (numStyle !== undefined) {\r\n                        val = numStyle.getRecursive<T>(parCb, runCb);\r\n                    }\r\n                }\r\n                const parParent = this.parStyle.parent;\r\n                if (val === undefined && parParent !== undefined) {\r\n                    // Fifthly look at the base styles of the PARAGRAPH style.\r\n                    val = parParent.getRecursive<T>(parCb, runCb);\r\n                }\r\n            }\r\n        }\r\n        // Sixthly look at the Table Style.\r\n        if (val === undefined) {\r\n            if (this.tableStyle !== undefined) {\r\n                if (tableCb !== undefined) {\r\n                    const table = tableCb(this.tableStyle);\r\n                    if (table !== undefined) {\r\n                        val = table;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Sevently look at the Style where this style is based upon.\r\n        if (val === undefined) {\r\n            const basedOn = this._basedOn;\r\n            if (basedOn !== undefined) {\r\n                val = basedOn.getRecursive<T>(parCb, runCb);\r\n            }\r\n        }\r\n        return val;\r\n    }\r\n}","import { Metrics } from \"./metrics\";\r\nimport { Style } from \"../text/style\";\r\n\r\nexport class Fonts {\r\n  private static _initialized = false;\r\n  private static _foundFonts: { [key: string]: number } = {};\r\n  private static _notFoundFonts: { [key: string]: number } = {};\r\n  private static testString = 'mmmmmllnnrr';\r\n  private static testSize = 72;\r\n  private static baseline: number | undefined = undefined;\r\n  \r\n  /**\r\n   * List of available fonts on this device.\r\n   */\r\n  public static availableFonts(): { [key: string]: number } {\r\n    if (!Fonts._initialized) {\r\n      Fonts._initialized = true;\r\n      const families = [\r\n        'Arial',\r\n        'Helvetica',\r\n        'Times',\r\n        'Courier',\r\n        'Verdana',\r\n        'Georgia',\r\n        'Garamond',\r\n        'Comic Sans MS',\r\n        'Trebuchet MS',\r\n        'Arial Black',\r\n        'Impact'\r\n      ];\r\n      const style = new Style();\r\n      style.runStyle.updateFont('Times New Roman', false, Fonts.testSize);\r\n      Fonts.baseline = Metrics.getTextWidth(Fonts.testString, style) / Fonts.testString.length;\r\n      Fonts._foundFonts['Times New Roman'] = Fonts.baseline;\r\n      families.forEach(family => {\r\n        Fonts.testFont(family, false);\r\n      });\r\n    }\r\n    return Fonts._foundFonts;\r\n  }\r\n\r\n  public static tryAddFonts(families: string[]): number {\r\n    for (let i = 0; i < families.length; i++) {\r\n      if (this.tryAddFont(families[i], false)) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  public static tryAddFont(family: string, bold: boolean): boolean {\r\n    const name = Fonts._getName(family, bold);\r\n    const isAvailable = Fonts.availableFonts()[name] !== undefined;\r\n    if (!isAvailable) {\r\n      const isNotAvailable = Fonts._notFoundFonts[name] !== undefined;\r\n      if (!isNotAvailable) {\r\n        return Fonts.testFont(family, bold);\r\n      } \r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  private static testFont(family: string, bold: boolean): boolean {\r\n    const style = new Style();\r\n    style.runStyle.updateFont(family, bold, Fonts.testSize);\r\n    const name = Fonts._getName(family, bold);\r\n    const widthOfString = Metrics.getTextWidth(Fonts.testString, style);\r\n    const widthOfChar = widthOfString / Fonts.testString.length;\r\n    if (widthOfChar !== Fonts.baseline) {\r\n      Fonts._foundFonts[name] = widthOfChar;\r\n      return true;\r\n    } else {\r\n      Fonts._notFoundFonts[name] = widthOfChar;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private static _getName(family: string, bold: boolean): string {\r\n    return family + ((bold) ? \"-bold\" : \"\");\r\n  }\r\n}\r\n","import { Fonts } from \"./fonts\";\r\nimport { Style } from \"../text/style\";\r\nimport { Metrics } from \"./metrics\";\r\n\r\nexport class FontMetrics {\r\n    private static _fonts: { [key: string]: TextMetrics } = {};\r\n    private static _testString = \"The quick brown fox jumped over the fence\";\r\n    private static _testSize = 72;\r\n    private static _topToBaseFactor = 13 / 16;\r\n  \r\n    public static fitCharacters(width: number, style: Style): number {\r\n        const charWidth = FontMetrics.averageCharWidth(style);\r\n        return Math.floor(width / charWidth);\r\n    }\r\n    \r\n    public static averageCharWidth(style: Style): number {\r\n        const fontSize = style.fontSize;\r\n        const fontFamily = style.fontFamily;\r\n        Fonts.tryAddFont(fontFamily, style.bold);\r\n        const metric = this.getFontMetrics(style);\r\n        const width = metric.width / this._testString.length;\r\n        const charWidth = width * fontSize / this._testSize;\r\n        return charWidth;\r\n    }\r\n \r\n    public static getTotalHeight(style: Style): number {\r\n        const metric = this.getFontMetrics(style);\r\n        const testHeight = metric.fontBoundingBoxAscent + metric.fontBoundingBoxDescent;\r\n        return testHeight * style.fontSize / this._testSize;\r\n    }\r\n\r\n    public static getTopToBaseline(style: Style): number {\r\n        const metric = this.getFontMetrics(style);\r\n        const testHeight = metric.fontBoundingBoxAscent || this._testSize * FontMetrics._topToBaseFactor;\r\n        return testHeight * style.fontSize / this._testSize;\r\n    }\r\n\r\n    public static getBaselineToBottom(style: Style): number {\r\n        const metric = this.getFontMetrics(style);\r\n        const baseToBottomFactor = 1 - FontMetrics._topToBaseFactor;\r\n        const testHeight = metric.fontBoundingBoxDescent || this._testSize * baseToBottomFactor;\r\n        return testHeight * style.fontSize / this._testSize;\r\n    }\r\n\r\n    private static getFontMetrics(style: Style) {\r\n        const id = style.fontFamily + (style.bold) ? \"-bold\" : \"\";\r\n        let metrics = FontMetrics._fonts[id];\r\n        if (metrics === undefined) {\r\n            const metricStyle = new Style();\r\n            metricStyle.runStyle.updateFont(style.fontFamily, style.bold, this._testSize);\r\n            metrics = Metrics.getTextMetrics(FontMetrics._testString, metricStyle);\r\n        }\r\n        return metrics;\r\n    }\r\n}","import { IPositionedTextLine } from \"./positioned-text-line\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\nimport { TextRun } from \"./text-run\";\r\nimport { Metrics } from \"../utils/metrics\";\r\nimport { FontMetrics } from \"../utils/font-metrics\";\r\nimport { Style } from \"./style\";\r\nimport { Justification } from \"../paragraph/par-style\";\r\nimport { WordSplitter, WordSeperator } from \"./word-splitter\";\r\nimport { ParagraphType } from \"../paragraph/paragraph\";\r\n\r\nexport class TextFitter {\r\n    public lines: IPositionedTextLine[];\r\n    public lastXPadding = 0;\r\n    private _run: TextRun;\r\n    private _lineHeight: number;\r\n\r\n    constructor(run: TextRun) {\r\n        this._run = run;\r\n        this._lineHeight = this._run.style.lineSpacing;\r\n        this.lines = [];\r\n    }\r\n\r\n    public getFlowLines(flow: VirtualFlow): void {\r\n        let inRun = InSequence.First;\r\n        let currentXPadding = this._getInitialXPadding();\r\n        let isFollowing = this._isFollowing;\r\n        if (this._run.hasEmptyText) {\r\n            this.lastXPadding = currentXPadding;\r\n            return;\r\n        }\r\n        this._fixYPosition(isFollowing, flow);\r\n        const texts = this._fixAllCaps(this._run.texts);\r\n        const splitter = new WordSplitter(texts);\r\n        const words = splitter.words;\r\n        if (this._run.texts.length === 1 && this._run.texts[0] === \" \") {\r\n            this.lastXPadding = currentXPadding + FontMetrics.averageCharWidth(this._run.style);\r\n            return;\r\n        }\r\n        const strictFit = this._run.paragraphType === ParagraphType.TableCell;\r\n        let tabIndex = 0;\r\n        let previousIndex = 0;\r\n        let currentLength = 0;\r\n        let numAvailableChars = this._getAvailableChars(currentXPadding, flow);\r\n        let isLastLine = false;\r\n        let justification = this._run.style.justification;\r\n        for(let i = 0; i < words.length; i++) {\r\n            currentLength += words[i].length + 1;\r\n            isLastLine = (i === words.length - 1);\r\n            const seperator = splitter.getSeperator(i);\r\n            const isNewLine = seperator === WordSeperator.LineFeed;\r\n            const isTab = seperator === WordSeperator.Tab;\r\n            let reachedEndOfLine = isLastLine || isNewLine || isTab;\r\n            if (!reachedEndOfLine && !this._fitReasonably(currentLength, numAvailableChars, strictFit, words[i + 1])) {\r\n                // Next word would go over the boundary, chop now.\r\n                reachedEndOfLine = true;\r\n            }\r\n            if (reachedEndOfLine) {\r\n                inRun = (isLastLine) ? InSequence.Last : inRun;\r\n                // Ready to push the line out to the renderer.\r\n                this._pushNewLine(splitter.combine(previousIndex, i), flow, isFollowing, isTab, inRun, currentXPadding, justification, this._run.style);\r\n                // Resetting the state for next line.\r\n                if (!isLastLine) {\r\n                    isFollowing = false;\r\n                    inRun = InSequence.Middle;\r\n                    if (isTab) {\r\n                        currentXPadding = this._getTabPadding(tabIndex, flow);\r\n                        justification = this._getTabJustification(tabIndex, this._run.style, flow);\r\n                        tabIndex++;\r\n                    } else {\r\n                        currentXPadding = this._getIndentation(inRun);\r\n                        tabIndex = 0;\r\n                    }\r\n                    numAvailableChars = this._getAvailableChars(currentXPadding, flow);\r\n                    currentLength = 0;\r\n                    previousIndex = i + 1;\r\n                }\r\n            }\r\n        }\r\n        this.lastXPadding = this._finalXPadding(currentXPadding, flow);\r\n    }\r\n\r\n    private get _isFirstRun(): boolean {\r\n        return (this._run.inParagraph === InSequence.First || this._run.inParagraph === InSequence.Only);\r\n    }\r\n\r\n    private get _isLastRun(): boolean {\r\n        return (this._run.inParagraph === InSequence.Last || this._run.inParagraph === InSequence.Only);        \r\n    }\r\n\r\n    private _pushNewLine(\r\n        txt: string,\r\n        flow: VirtualFlow,\r\n        isFollowing: boolean,\r\n        isTab: boolean,\r\n        inRun: InSequence,\r\n        xPadding: number,\r\n        justification: Justification,\r\n        style: Style\r\n    ): void {\r\n        const isLastLine = (inRun === InSequence.Last || inRun === InSequence.Only);\r\n        const isLastRun = (this._run.inParagraph === InSequence.Last || this._run.inParagraph === InSequence.Only);\r\n        const stretched = (style.justification === Justification.both) && !isLastLine;\r\n        this.lines.push({\r\n            text: txt,\r\n            x: flow.getX() + xPadding,\r\n            y: flow.getY(),\r\n            width: flow.getWidth() - xPadding,\r\n            stretched: stretched,\r\n            following: isFollowing,\r\n            color: style.color,\r\n            fontFamily: style.fontFamily,\r\n            fontSize: style.fontSize,\r\n            emphasis: style.emphasis,\r\n            justification: justification\r\n        });\r\n        if (!isTab && (isLastRun || !isLastLine)) {\r\n            flow.advancePosition(this._lineHeight);\r\n        }\r\n    }\r\n\r\n    private _fixAllCaps(txts: string[]): string[] {\r\n        if (this._run.style.caps || this._run.style.smallCaps) {\r\n            txts = txts.map((txt) => txt.toLocaleUpperCase());\r\n        }\r\n        return txts;\r\n    }\r\n\r\n    private _fixYPosition(isFollowing: boolean, flow: VirtualFlow): void {\r\n        if (!isFollowing) {\r\n            // Text is on baseline, flow is at the top, correcting here.\r\n            flow.advancePosition(FontMetrics.getTopToBaseline(this._run.style));\r\n        }\r\n    }\r\n\r\n    private get _isFollowing(): boolean {\r\n        let isFollowing: boolean;\r\n        if (this._run.previousXPos === undefined || this._isFirstRun) {\r\n            isFollowing = false;\r\n        } else {\r\n            isFollowing = true;\r\n        }\r\n        return isFollowing;\r\n    }\r\n\r\n    private _getIndentation(inRun: InSequence): number {\r\n        return this._run.style.getIndentation(inRun, this._run.inParagraph);\r\n    }\r\n\r\n    private _getTabPadding(tabIndex: number, flow: VirtualFlow): number {\r\n        let padding = 0;\r\n        const tab = flow.getTab(tabIndex);\r\n        if (tab !== undefined && tab.position !== undefined) {\r\n            padding = tab.position;\r\n        }\r\n        return padding;\r\n    }\r\n\r\n    private _getTabJustification(tabIndex: number, style: Style, flow: VirtualFlow): Justification {\r\n        let justification = style.justification;\r\n        const tab = flow.getTab(tabIndex);\r\n        if (tab !== undefined) {\r\n            justification = tab.justification;\r\n        }\r\n        return justification;\r\n    }\r\n\r\n    private _getAvailableChars(xPadding: number, flow: VirtualFlow): number {\r\n        return FontMetrics.fitCharacters(flow.getWidth() - xPadding, this._run.style);\r\n    }\r\n\r\n    /**\r\n     * Does the next word fit reasonably.\r\n     */\r\n    private _fitReasonably(length: number, numAvailableChars: number, strictFit: boolean, nextWord: string | undefined): boolean {\r\n        if (nextWord === undefined) {\r\n            return true;\r\n        }\r\n        const graceNumber = strictFit ? 0 : 1;\r\n        const nextLength = length + nextWord.length;\r\n        const numAcceptableChars = numAvailableChars + graceNumber;\r\n        return nextLength <= numAcceptableChars;\r\n    }\r\n\r\n    private _getInitialXPadding(): number {\r\n        let xPadding = 0;\r\n        if (this._run.previousXPos === undefined || this._isFirstRun) {\r\n            xPadding = this._getIndentation(InSequence.First);\r\n        } else {\r\n            xPadding = this._run.previousXPos;\r\n        }\r\n        return xPadding;\r\n    }\r\n\r\n    private _finalXPadding(currentXPadding: number, flow: VirtualFlow): number {\r\n        if (this._isLastRun) {\r\n            flow.advancePosition(FontMetrics.getBaselineToBottom(this._run.style));\r\n        }\r\n        const lastLineWidth = Metrics.getTextWidth(this.lines[this.lines.length - 1].text, this._run.style);\r\n        return currentXPadding + lastLineWidth;\r\n    }\r\n}","\r\nexport class Size {\r\n    public width: number;\r\n    public height: number;\r\n\r\n    constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    public addVertical(other: Size, spacing: number = 0): Size {\r\n        const newWidth = Math.max(this.width, other.width);\r\n        const newHeight = this.height + other.height + spacing;\r\n        return new Size(newWidth, newHeight);\r\n    }\r\n\r\n    public addHorizontal(other: Size, spacing: number = 0): Size {\r\n        const newWidth = this.width + other.width + spacing;\r\n        const newHeight = Math.max(this.height, other.height);\r\n        return new Size(newWidth, newHeight);\r\n    }\r\n\r\n    public clone(): Size {\r\n        return new Size(this.width, this.height);\r\n    }\r\n}","import { Style } from \"./style\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\nimport { IPositionedTextLine } from \"./positioned-text-line\";\r\nimport { TextFitter } from \"./text-fitter\";\r\nimport { Metrics } from \"../utils/metrics\";\r\nimport { ParagraphType, IRun } from \"../paragraph/paragraph\";\r\nimport { Size } from \"../utils/geometry/size\";\r\n\r\nexport class TextRun implements IRun {\r\n    public texts: string[];\r\n    public style: Style;\r\n    public inParagraph: InSequence = InSequence.Only;\r\n    public paragraphType = ParagraphType.Text;\r\n    public linkTarget: string | undefined = undefined;\r\n    public previousXPos: number | undefined;\r\n    public lastXPos = 0;\r\n    private _lines: IPositionedTextLine[] | undefined = undefined;\r\n\r\n    constructor(texts: string[], style: Style) {\r\n        this.style = style;\r\n        this.texts = texts;\r\n    }\r\n\r\n    public getSize(): Size {\r\n        return new Size(this.getUsedWidth(), this.getHeight());\r\n    }\r\n\r\n    public getUsedWidth(): number {\r\n        let maxWidth = 0;\r\n        this.getLines().forEach(line => maxWidth = Math.max(maxWidth, line.width));\r\n        return maxWidth;\r\n    }\r\n\r\n    public getWidthOfLastLine(): number {\r\n        const lines = this.getLines();\r\n        return Metrics.getTextWidth(lines[lines.length - 1].text, this.style);\r\n    }\r\n\r\n    public getHeight(): number {\r\n        return this.getLines().length * this.style.lineSpacing;\r\n    }\r\n\r\n    public getLines(): IPositionedTextLine[] {\r\n        let lines: IPositionedTextLine[];\r\n        if (this._lines !== undefined) {\r\n            lines = this._lines;\r\n        } else {\r\n            throw new Error(\"Rendering text which hasn't been included in layout\");\r\n        }\r\n        return lines;\r\n    }\r\n\r\n    public get hasEmptyText(): boolean {\r\n        return this.texts.length === 0;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow): void {\r\n        if (this._lines === undefined) {\r\n            this._lines = this._getFlowLines(flow);\r\n        }\r\n    }\r\n\r\n    private _getFlowLines(flow: VirtualFlow): IPositionedTextLine[] {\r\n        let lines: IPositionedTextLine[] = [];\r\n        if (!this.style.invisible) {\r\n            const fitter = new TextFitter(this);\r\n            fitter.getFlowLines(flow);\r\n            this.lastXPos = fitter.lastXPadding;\r\n            lines = fitter.lines;\r\n        } else {\r\n            this.lastXPos = 0;\r\n        }\r\n        return lines;\r\n    }\r\n}","import { IPainter, IRectangle, DashMode } from \"./i-painter\";\r\nimport { Justification } from \"../paragraph/par-style\";\r\nimport { Picture } from \"../drawing/picture\";\r\nimport { Xml } from \"../utils/xml\";\r\n\r\nexport class SvgPainter implements IPainter {\r\n    private static readonly svgNS = 'http://www.w3.org/2000/svg';\r\n    private _svg: Element;\r\n    private _root: Element;\r\n    private _lastText: SVGTextElement | undefined;\r\n\r\n    constructor(content: HTMLElement) {\r\n        const root = document.createElementNS(SvgPainter.svgNS, 'svg');\r\n        const width = content.clientWidth.toString();\r\n        root.setAttribute('id', 'svg');\r\n        root.setAttribute('width', width);\r\n        root.setAttribute('height', '500');\r\n        root.setAttribute('style', 'white-space:pre');\r\n        content.appendChild(root);\r\n        this._svg = root;\r\n        this._root = root;\r\n    }\r\n\r\n    public get svg(): Element {\r\n        return this._svg;\r\n    }\r\n\r\n    public paintText(x: number, y: number, width: number, stretched: boolean, text: string, color: string, justification: Justification, fontFamily: string, fontSize: number, bold: boolean, italic: boolean) {\r\n        const newText = document.createElementNS(SvgPainter.svgNS, 'text');\r\n        this._setFont(newText, fontFamily, fontSize, bold, italic);\r\n        this._setColor(newText, color);\r\n        this._setHorizontalAlignment(newText, x, width, justification, stretched);\r\n        this._setVerticalAlignment(newText, y, fontSize);\r\n        const textNode = document.createTextNode(text);\r\n        newText.appendChild(textNode);\r\n        this._svg.appendChild(newText);\r\n        this._lastText = newText;\r\n    }\r\n    \r\n    public measureLastText(): IRectangle {\r\n        let rect: IRectangle;\r\n        if (this._lastText !== undefined) {\r\n            const box = this._lastText.getBBox();\r\n            rect = {\r\n                x: box.x,\r\n                y: box.y,\r\n                width: box.width,\r\n                height: box.height\r\n            };\r\n        } else {\r\n            rect = {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n        }\r\n        return rect;\r\n    }\r\n\r\n    public paintLine(x1: number, y1: number, x2: number, y2: number, color: string, thickness: number, dashing: DashMode): void {\r\n        const line = document.createElementNS(SvgPainter.svgNS, \"line\");\r\n        line.setAttribute(\"x1\", x1.toString());\r\n        line.setAttribute(\"y1\", y1.toString());\r\n        line.setAttribute(\"x2\", x2.toString());\r\n        line.setAttribute(\"y2\", y2.toString());\r\n        line.setAttribute(\"stroke\", `#${color}`);\r\n        line.setAttribute(\"stroke-width\", thickness.toString());\r\n        this._setDashing(line, dashing);\r\n        this._svg.appendChild(line);\r\n    }\r\n\r\n    public paintPolygon(path: string, fillColor: string | undefined, strokeColor: string | undefined, strokeThickness: number | undefined, dashing: DashMode): void {\r\n        const element = document.createElementNS(SvgPainter.svgNS, \"path\");\r\n        element.setAttribute(\"d\", path);\r\n        if (fillColor !== undefined) {\r\n            element.setAttribute(\"fill\", `#${fillColor}`);\r\n        }\r\n        if (strokeColor !== undefined) {\r\n            element.setAttribute(\"stroke\", `#${strokeColor}`);\r\n        }\r\n        element.setAttribute(\"stroke-width\", `${strokeThickness}`);\r\n        this._setDashing(element, dashing);\r\n        this._svg.appendChild(element);\r\n    }\r\n\r\n    public paintPicture(x: number, y: number, width: number, height: number, pic: Picture): void {\r\n        if (pic !== undefined) {\r\n            pic.getImageUrl().then(url => {\r\n                if (url instanceof SVGElement) {\r\n                    const g = document.createElementNS(SvgPainter.svgNS, \"g\");\r\n                    url.setAttribute(\"x\", `${x}`);\r\n                    url.setAttribute(\"y\", `${y}`);\r\n                    url.setAttribute(\"width\", `${width}`);\r\n                    url.setAttribute(\"height\", `${height}`);\r\n                    this.svg.appendChild(g);\r\n                    g.appendChild(url);\r\n                } else {\r\n                    const image = document.createElementNS(SvgPainter.svgNS, \"image\");\r\n                    image.setAttribute(\"x\", `${x}`);\r\n                    image.setAttribute(\"y\", `${y}`);\r\n                    image.setAttribute(\"width\", `${width}`);\r\n                    image.setAttribute(\"height\", `${height}`);\r\n                    this.svg.appendChild(image);\r\n                    image.setAttribute(\"xlink:href\", `${url}`);\r\n                    image.setAttribute(\"href\", `${url}`);\r\n                }\r\n            }).catch(error => {\r\n                console.log(`ERROR during rendering: ${error}`);\r\n            })\r\n        }      \r\n    }\r\n\r\n    public clear(): void {\r\n        while (this.svg.lastChild) {\r\n          this.svg.removeChild(this.svg.lastChild);\r\n        }\r\n    }\r\n\r\n    public setWidth(newWidth: number): void {\r\n        const width = Xml.getAttribute(this.svg, \"width\");\r\n        if (width !== undefined) {\r\n            this._svg.setAttribute(\"width\", `${newWidth}`);\r\n            const root = this._svg.parentElement;\r\n            if (root !== null) {\r\n                root.setAttribute(\"width\", `${newWidth}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    public ensureHeight(newHeight: number): void {\r\n        const height = Xml.getAttribute(this.svg, \"height\");\r\n        if (height !== undefined) {\r\n            const heightNum = parseFloat(height);\r\n            const maxY = Math.max(heightNum, newHeight);\r\n            if (maxY > heightNum) {\r\n                this._svg.setAttribute(\"height\", `${maxY}`);\r\n                const root = this._svg.parentElement;\r\n                if (root !== null) {\r\n                    root.setAttribute(\"height\", `${maxY}`);\r\n                }\r\n            }\r\n        }  \r\n    }\r\n\r\n    public startLink(url: string): void {\r\n        const a = document.createElementNS(SvgPainter.svgNS, \"a\");\r\n        a.setAttribute(\"href\", url);\r\n        this._svg = a;\r\n        this._root.appendChild(this._svg);\r\n    }\r\n\r\n    public endLink(): void {\r\n        if (this._svg !== this._root) {\r\n            this._svg = this._root;\r\n        }\r\n    }\r\n\r\n    private _setFont(textNode: Element, fontFamily: string, fontSize: number, bold: boolean, italic: boolean): void {\r\n        textNode.setAttribute('font-family', fontFamily);\r\n        textNode.setAttribute('font-size', fontSize.toString());\r\n        if (bold) {\r\n            textNode.setAttribute('font-weight', 'bold');\r\n        }\r\n        if (italic) {\r\n            textNode.setAttribute('font-style', 'italic');\r\n        }\r\n    }\r\n    \r\n    private _setColor(textNode: Element, color: string) {\r\n        textNode.setAttribute('fill', `#${color}`);\r\n    }\r\n    \r\n    private _setDashing(node: Element, dashing: DashMode): void {\r\n        switch(dashing) {\r\n            case DashMode.Dashed:\r\n                node.setAttribute(\"stroke-dasharray\", \"5 3\");\r\n                break;\r\n            case DashMode.LongDash:\r\n                node.setAttribute(\"stroke-dasharray\", \"8 3\");\r\n                break;\r\n            case DashMode.Dotted:\r\n                node.setAttribute(\"stroke-dasharray\", \"1\");\r\n                break;\r\n            case DashMode.DashedSmallGap:\r\n                node.setAttribute(\"stroke-dasharray\", \"5 2\");\r\n                break;\r\n            case DashMode.DotDash:\r\n                node.setAttribute(\"stroke-dasharray\", \"6 2 2 2\");\r\n                break;\r\n            case DashMode.DotDotDash:\r\n                node.setAttribute(\"stroke-dasharray\", \"6 2 2 2 2 2\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _setHorizontalAlignment(textNode: Element, x: number, width: number, justification: Justification, stretched: boolean): void {\r\n        switch(justification) {\r\n            case Justification.both:\r\n                textNode.setAttribute('x', x.toString());\r\n                if (stretched) {\r\n                    textNode.setAttribute('textLength', width.toString());\r\n                    textNode.setAttribute('lengthAdjust', 'spacing');\r\n                }\r\n                break;\r\n            case Justification.right:\r\n                const right = x + width;\r\n                textNode.setAttribute('x', right.toString());\r\n                textNode.setAttribute('text-anchor', \"end\");\r\n                break;\r\n            case Justification.center:\r\n                const center = x + width / 2;\r\n                textNode.setAttribute('x', center.toString());\r\n                textNode.setAttribute('text-anchor', \"middle\");\r\n                break;\r\n            case Justification.left:\r\n            default:\r\n                textNode.setAttribute('x', x.toString());\r\n                textNode.setAttribute('text-anchor', \"start\");\r\n                break;\r\n        }\r\n    }\r\n  \r\n    private _setVerticalAlignment(textNode: Element, y: number, _fontSize: number): void {\r\n        textNode.setAttribute('y', y.toString());\r\n    }\r\n}","import { Table } from \"./table\";\r\nimport { TableCell } from \"./table-cell\";\r\nimport { TableStyle } from \"./table-style\";\r\nimport { IPainter, DashMode } from \"../painting/i-painter\";\r\nimport { ParagraphRenderer } from \"../paragraph/paragraph-renderer\";\r\nimport { TableBorderSet } from \"./table-border-set\";\r\nimport { TableBorderType, TableBorder } from \"./table-border\";\r\n\r\ninterface IColoredLine {\r\n    x1: number;\r\n    y1: number;\r\n    x2: number;\r\n    y2: number;\r\n    color: string;\r\n}\r\n\r\ninterface ISubLine {\r\n    pos: number;\r\n    width: number;\r\n    dashing: DashMode;\r\n}\r\n\r\nexport class TableRenderer {\r\n    private _parRenderer: ParagraphRenderer;\r\n    private _painter: IPainter;\r\n\r\n    constructor(painter: IPainter, paragraphRenderer: ParagraphRenderer) {\r\n        this._painter = painter;\r\n        this._parRenderer = paragraphRenderer;\r\n    }\r\n\r\n    public renderTable(table: Table): void {\r\n        table.rows.forEach(row => {\r\n            row.cells.forEach(cell => {\r\n                if (cell.numRowsInSpan > 0) {\r\n                    this.renderCellShading(cell);\r\n                    this.renderCellBorder(cell, table.style);\r\n                    cell.pars.forEach(par => {\r\n                        this._parRenderer.renderParagraph(par);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    \r\n    private renderCellShading(cell: TableCell): void {\r\n        const bounds = cell.bounds;\r\n        if (cell.style.shading !== \"\" && bounds !== undefined) {\r\n            const y = bounds.y + (bounds.height / 2);\r\n            this._painter.paintLine(\r\n                bounds.left,\r\n                y,\r\n                bounds.right,\r\n                y,\r\n                cell.style.shading,\r\n                bounds.height,\r\n                DashMode.Solid\r\n            );\r\n        }\r\n    }\r\n\r\n    private renderCellBorder(cell: TableCell, style: TableStyle): void {\r\n        let outerBorders: TableBorderSet | undefined = style.borders;\r\n        const innerBorders = cell.style.borders;\r\n        // Resolve border conflicts\r\n        if (style.cellSpacing === 0 && cell.style.hasBordersDefined) {\r\n            // Disable cell borders defined at table level.\r\n            outerBorders = undefined;\r\n        }\r\n        let bounds = cell.bounds;\r\n        if (bounds === undefined) {\r\n            return;\r\n        }\r\n        if (outerBorders !== undefined) {\r\n            if (outerBorders.borderTop !== undefined) {\r\n                this._renderBorderPart(\r\n                    outerBorders.borderTop,\r\n                    {\r\n                        x1: bounds.left,\r\n                        y1: bounds.top,\r\n                        x2: bounds.right,\r\n                        y2: bounds.top,\r\n                        color: outerBorders.borderTop.color\r\n                    }\r\n                );\r\n            }\r\n            if (outerBorders.borderBottom !== undefined) {\r\n                this._renderBorderPart(\r\n                    outerBorders.borderBottom,\r\n                    {\r\n                        x1: bounds.right,\r\n                        y1: bounds.bottom,\r\n                        x2: bounds.left,\r\n                        y2: bounds.bottom,\r\n                        color: outerBorders.borderBottom.color\r\n                    }\r\n                );\r\n            }\r\n            if (outerBorders.borderStart !== undefined) {\r\n                this._renderBorderPart(\r\n                    outerBorders.borderStart,\r\n                    {\r\n                        x1: bounds.x,\r\n                        y1: bounds.bottom,\r\n                        x2: bounds.x,\r\n                        y2: bounds.top,\r\n                        color: outerBorders.borderStart.color\r\n                    }\r\n                );\r\n            }\r\n            if (outerBorders.borderEnd !== undefined) {\r\n                this._renderBorderPart(\r\n                    outerBorders.borderEnd,\r\n                    {\r\n                        x1: bounds.right,\r\n                        y1: bounds.top,\r\n                        x2: bounds.right,\r\n                        y2: bounds.bottom,\r\n                        color: outerBorders.borderEnd.color\r\n                    }\r\n                );\r\n            }\r\n        }\r\n        if (innerBorders !== undefined) {\r\n            bounds.subtractSpacing(style.cellSpacing);\r\n            if (innerBorders.borderTop !== undefined) {\r\n                this._renderBorderPart(\r\n                    innerBorders.borderTop,\r\n                    {\r\n                        x1: bounds.left,\r\n                        y1: bounds.top,\r\n                        x2: bounds.right,\r\n                        y2: bounds.top,\r\n                        color: innerBorders.borderTop.color\r\n                    }\r\n                );\r\n            }\r\n            if (innerBorders.borderBottom !== undefined) {\r\n                this._renderBorderPart(\r\n                    innerBorders.borderBottom,\r\n                    {\r\n                        x1: bounds.right,\r\n                        y1: bounds.bottom,\r\n                        x2: bounds.left,\r\n                        y2: bounds.bottom,\r\n                        color: innerBorders.borderBottom.color\r\n                    }\r\n                );\r\n            }\r\n            if (innerBorders.borderStart !== undefined) {\r\n                this._renderBorderPart(\r\n                    innerBorders.borderStart,\r\n                    {\r\n                        x1: bounds.x,\r\n                        y1: bounds.bottom,\r\n                        x2: bounds.x,\r\n                        y2: bounds.top,\r\n                        color: innerBorders.borderStart.color\r\n                    }\r\n                );\r\n            }\r\n            if (innerBorders.borderEnd !== undefined) {\r\n                this._renderBorderPart(\r\n                    innerBorders.borderEnd,\r\n                    {\r\n                        x1: bounds.right,\r\n                        y1: bounds.top,\r\n                        x2: bounds.right,\r\n                        y2: bounds.bottom,\r\n                        color: innerBorders.borderEnd.color\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    }\r\n    \r\n    private _renderBorderPart(border: TableBorder, line: IColoredLine): void {\r\n        let relativeSize = border.size;\r\n        switch (border.type) {\r\n            case TableBorderType.None:\r\n                break;\r\n            case TableBorderType.Double:\r\n                this._renderBorderSubLines(line, [{ pos: 0, width: border.size * 2, dashing: DashMode.Solid}]);\r\n                break;\r\n            case TableBorderType.Triple:\r\n                this._renderBorderSubLines(line, [{ pos: 0, width: border.size * 3, dashing: DashMode.Solid}]);\r\n                break;\r\n            case TableBorderType.ThickThinLargeGap:\r\n                relativeSize /= 12;\r\n                this._renderBorderSubLines(line, [\r\n                    { pos: 2.5 * relativeSize, width: 5 * relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 10.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid}\r\n                ]);\r\n                break;\r\n            case TableBorderType.ThickThinMediumGap:\r\n                relativeSize /= 10;\r\n                this._renderBorderSubLines(line, [\r\n                    { pos: 2.5 * relativeSize, width: 5 * relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 8.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid}\r\n                ]);\r\n                break;\r\n            case TableBorderType.ThickThinSmallGap:\r\n                relativeSize /= 8;\r\n                this._renderBorderSubLines(line, [\r\n                    { pos: 2.5 * relativeSize, width: 5 * relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 6.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid}\r\n                ]);\r\n                break;\r\n            case TableBorderType.ThinThickLargeGap:\r\n                relativeSize /= 12;\r\n                this._renderBorderSubLines(line, [\r\n                    { pos: 0.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 8.5 * relativeSize, width: 5 * relativeSize, dashing: DashMode.Solid}\r\n                ]);\r\n                break;\r\n            case TableBorderType.ThinThickMediumGap:\r\n                relativeSize /= 10;\r\n                this._renderBorderSubLines(line, [\r\n                    { pos: 0.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 6.5 * relativeSize, width: 5 * relativeSize, dashing: DashMode.Solid}\r\n                ]);\r\n                break;\r\n            case TableBorderType.ThinThickSmallGap:\r\n                relativeSize /= 8;\r\n                this._renderBorderSubLines(line, [\r\n                    { pos: 0.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 4.5 * relativeSize, width: 5 * relativeSize, dashing: DashMode.Solid}\r\n                ]);\r\n                break;\r\n            case TableBorderType.ThinThickThinLargeGap:\r\n                relativeSize /= 18;\r\n                this._renderBorderSubLines(line, [\r\n                    { pos: 0.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 8.5 * relativeSize, width: 5 * relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 16.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid}\r\n                ]);\r\n                break;\r\n            case TableBorderType.ThinThickThinMediumGap:\r\n                relativeSize /= 14;\r\n                this._renderBorderSubLines(line, [\r\n                    { pos: 0.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 2.5 * relativeSize, width: 5 * relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 12.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid}\r\n                ]);\r\n                break;\r\n            case TableBorderType.ThinThickThinSmallGap:\r\n                relativeSize /= 10;\r\n                this._renderBorderSubLines(line, [\r\n                    { pos: 0.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 4.5 * relativeSize, width: 5 * relativeSize, dashing: DashMode.Solid},\r\n                    { pos: 8.5 * relativeSize, width: relativeSize, dashing: DashMode.Solid}\r\n                ]);\r\n                break;\r\n            case TableBorderType.DashDotStroked:\r\n                relativeSize /= 3;\r\n                this._renderBorderSubLines(line, [\r\n                    {pos: 0.5 * relativeSize, width: relativeSize, dashing: DashMode.Dashed},\r\n                    {pos: 2.5 * relativeSize, width: relativeSize, dashing: DashMode.Dotted}\r\n                ]);\r\n                break;\r\n            case TableBorderType.Dashed:\r\n                this._renderBorderSubLines(line, [{pos: 0, width: border.size, dashing: DashMode.Dashed}]);\r\n                break;\r\n            case TableBorderType.DashSmallGap:\r\n                this._renderBorderSubLines(line, [{pos: 0, width: border.size, dashing: DashMode.DashedSmallGap}]);\r\n                break;\r\n            case TableBorderType.DotDash:\r\n                relativeSize /= 3;\r\n                this._renderBorderSubLines(line, [\r\n                    {pos: 0.5 * relativeSize, width: relativeSize, dashing: DashMode.Dotted},\r\n                    {pos: 2.5 * relativeSize, width: relativeSize, dashing: DashMode.Dashed}\r\n                ]);\r\n                break;\r\n            case TableBorderType.DotDotDash:\r\n                relativeSize /= 5;\r\n                this._renderBorderSubLines(line, [\r\n                    {pos: 0.5 * relativeSize, width: relativeSize, dashing: DashMode.Dotted},\r\n                    {pos: 2.5 * relativeSize, width: relativeSize, dashing: DashMode.Dotted},\r\n                    {pos: 4.5 * relativeSize, width: relativeSize, dashing: DashMode.Dashed}\r\n                ]);\r\n                break;\r\n            case TableBorderType.Dotted:\r\n                this._renderBorderSubLines(line, [{pos: 0, width: border.size, dashing: DashMode.Dotted}]);\r\n                break;\r\n            case TableBorderType.Single:\r\n            default:\r\n                this._renderBorderSubLines(line, [{pos: 0, width: border.size, dashing: DashMode.Solid}]);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _renderBorderSubLines(line: IColoredLine, subLines: ISubLine[]): void {\r\n        const xDirection = (line.x1 === line.x2) ? ((line.y1 < line.y2) ? -1 : 1) : 0;\r\n        const yDirection = (line.y1 === line.y2) ? ((line.x1 > line.x2) ? -1 : 1) : 0;\r\n        subLines.forEach(sub => {\r\n            this._painter.paintLine(\r\n                line.x1 + xDirection * sub.pos,\r\n                line.y1 + yDirection * sub.pos,\r\n                line.x2 + xDirection * sub.pos,\r\n                line.y2 + yDirection * sub.pos,\r\n                line.color,\r\n                sub.width,\r\n                sub.dashing\r\n            );\r\n        });\r\n    }\r\n}","import { TextRun } from \"./text-run\";\r\nimport { IPositionedTextLine, Emphasis } from \"./positioned-text-line\";\r\nimport { UnderlineMode } from \"./run-style\";\r\nimport { IPainter, DashMode } from \"../painting/i-painter\";\r\nimport { Style } from \"./style\";\r\nimport { FontMetrics } from \"../utils/font-metrics\";\r\n\r\nexport class TextRenderer {\r\n    private _painter: IPainter;\r\n\r\n    constructor(painter: IPainter) {\r\n        this._painter = painter;\r\n    }\r\n\r\n    public renderTextRun(run: TextRun): void {\r\n        const linkTarget = run.linkTarget;\r\n        if (linkTarget !== undefined) {\r\n            this._painter.startLink(linkTarget);\r\n        }\r\n        run.getLines().forEach((line: IPositionedTextLine) => {\r\n            this._renderText(line, run.style);\r\n        });\r\n        if (linkTarget !== undefined) {\r\n            this._painter.endLink();\r\n        }\r\n    }\r\n    \r\n    private _renderText(line: IPositionedTextLine, style: Style): void {\r\n        const x = this._getX(line);\r\n        if (style.shadingColor !== \"000000\") {\r\n            const lineSpacing = style.lineSpacing;\r\n            const y = line.y - FontMetrics.getTopToBaseline(style) + lineSpacing / 2;\r\n            this._painter.paintLine(x, y, x + line.width, y, style.shadingColor, lineSpacing, DashMode.Solid);\r\n        }\r\n        const justification = (line.justification !== undefined) ? line.justification : style.justification;\r\n        const isBold = Boolean(line.emphasis & Emphasis.Bold);\r\n        const isItalic = Boolean(line.emphasis & Emphasis.Italic);\r\n        this._painter.paintText(x, line.y, line.width, line.stretched, line.text, line.color, justification, line.fontFamily, line.fontSize, isBold, isItalic);\r\n        if (style.underlineMode !== UnderlineMode.None || style.strike || style.doubleStrike) {\r\n            // Render underline after adding text to DOM.\r\n            this._renderUnderline(style);\r\n        }\r\n    }\r\n    \r\n    private _renderUnderline(style: Style): void {\r\n        // TODO: Support all underline modes\r\n        const textRect = this._painter.measureLastText();\r\n        const fontSize = style.fontSize;\r\n        const y = textRect.y + fontSize;\r\n        const color = (style.color === \"auto\") ? \"000000\" : style.color;\r\n        const thickness = fontSize / 24;\r\n        const heavy = 2 * thickness;\r\n        switch(style.underlineMode) {\r\n            case UnderlineMode.Double:\r\n                this._painter.paintLine(textRect.x, y, textRect.x + textRect.width, y, color, thickness, DashMode.Solid);\r\n                this._painter.paintLine(textRect.x, y + 3 * thickness, textRect.x + textRect.width, y + 3 * thickness, color, thickness, DashMode.Solid);\r\n                break;\r\n            case UnderlineMode.Thick:\r\n                this._painter.paintLine(textRect.x, y + thickness, textRect.x + textRect.width, y + thickness, color, heavy, DashMode.Solid);\r\n                break;\r\n            case UnderlineMode.Dotted:\r\n                this._painter.paintLine(textRect.x, y, textRect.x + textRect.width, y, color, thickness, DashMode.Dotted);\r\n                break;\r\n            case UnderlineMode.DottedHeavy:\r\n                this._painter.paintLine(textRect.x, y + thickness, textRect.x + textRect.width, y + thickness, color, heavy, DashMode.Dotted);\r\n                break;\r\n            case UnderlineMode.Dash:\r\n                this._painter.paintLine(textRect.x, y, textRect.x + textRect.width, y, color, thickness, DashMode.Dashed);\r\n                break;\r\n            case UnderlineMode.DashedHeavy:\r\n                this._painter.paintLine(textRect.x, y + thickness, textRect.x + textRect.width, y + thickness, color, heavy, DashMode.Dashed);\r\n                break;\r\n            case UnderlineMode.DotDash:\r\n                this._painter.paintLine(textRect.x, y, textRect.x + textRect.width, y, color, thickness, DashMode.DotDash);\r\n                break;\r\n            case UnderlineMode.DashDotHeavy:\r\n                this._painter.paintLine(textRect.x, y + thickness, textRect.x + textRect.width, y + thickness, color, heavy, DashMode.DotDash);\r\n                break;\r\n            case UnderlineMode.DotDotDash:\r\n                this._painter.paintLine(textRect.x, y, textRect.x + textRect.width, y, color, thickness, DashMode.DotDotDash);\r\n                break;\r\n            case UnderlineMode.DashDotDotHeavy:\r\n                this._painter.paintLine(textRect.x, y + thickness, textRect.x + textRect.width, y + thickness, color, heavy, DashMode.DotDotDash);\r\n                break;\r\n            case UnderlineMode.DashLong:\r\n                this._painter.paintLine(textRect.x, y, textRect.x + textRect.width, y, color, thickness, DashMode.LongDash);\r\n                break;\r\n            case UnderlineMode.DashLongHeavy:\r\n                this._painter.paintLine(textRect.x, y + thickness, textRect.x + textRect.width, y + thickness, color, heavy, DashMode.LongDash);\r\n                break;\r\n            case UnderlineMode.None:\r\n                // Nothing to be done\r\n                break;\r\n            default:\r\n            case UnderlineMode.Single:\r\n                this._painter.paintLine(textRect.x, y, textRect.x + textRect.width, y, color, thickness, DashMode.Solid);\r\n                break;\r\n        }\r\n        if (style.strike) {\r\n            this._painter.paintLine(textRect.x, y - fontSize / 2, textRect.x + textRect.width, y - fontSize / 2, color, 1, DashMode.Solid);\r\n        }\r\n        if (style.doubleStrike) {\r\n            this._painter.paintLine(textRect.x, y, textRect.x + textRect.width, y - (fontSize / 2) - 1, color, 1, DashMode.Solid);\r\n            this._painter.paintLine(textRect.x, y, textRect.x + textRect.width, y - (fontSize / 2) + 2, color, 1, DashMode.Solid);\r\n        }\r\n    }\r\n\r\n    private _getX(line: IPositionedTextLine): number {\r\n        let x = line.x;\r\n        if (line.following) {\r\n            const rect = this._painter.measureLastText();\r\n            x = Math.max(x, rect.x + rect.width);\r\n        }\r\n        return x;\r\n    }\r\n}","export class ChartStyle {\r\n    public fillColor: string | undefined = undefined;\r\n    public lineColor: string | undefined = undefined;\r\n    public lineThickness: number = 1;\r\n}","import { ChartAxis } from \"./chart-axis\";\r\nimport { ChartStyle } from \"./chart-style\";\r\nimport { Box } from \"../utils/geometry/box\";\r\nimport { ChartSpace } from \"./chart-space\";\r\n\r\nexport class ChartPlotArea {\r\n    public space: ChartSpace;\r\n    public style = new ChartStyle();\r\n    public valueAxis: ChartAxis | undefined;\r\n    public categoryAxis: ChartAxis | undefined;\r\n    public bounds: Box = new Box(0, 0, 0, 0);\r\n\r\n    constructor(space: ChartSpace) {\r\n        this.space = space;\r\n    }\r\n\r\n    public determineRange(): void {\r\n        if (this.valueAxis !== undefined && this.space.chart.series[0].hasNumericValues) {\r\n            const valueRange = this.space.chart.getValueRange();\r\n            valueRange.max = Math.ceil(1.2 * valueRange.max);\r\n            this.space.chart.setValueRange(valueRange.min, valueRange.max);\r\n        }\r\n    }\r\n}","import { ChartStyle } from \"./chart-style\";\r\nimport { ChartAxisPosition } from \"./chart-axis\";\r\nimport { Box } from \"../utils/geometry/box\";\r\nimport { ChartSpace } from \"./chart-space\";\r\nimport { FontMetrics } from \"../utils/font-metrics\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\nimport { IPositionedTextLine } from \"../text/positioned-text-line\";\r\n\r\nexport class ChartLegend {\r\n    public space: ChartSpace;\r\n    public style: ChartStyle = new ChartStyle();\r\n    public position: ChartAxisPosition = ChartAxisPosition.Right;\r\n    public overlayOnPlot: boolean = false;\r\n    public onlySeries: number | undefined = undefined;\r\n    public bounds: Box = new Box(0, 0, 0, 0);\r\n    private static _widgetSize = 10;\r\n    private static _widgetSpacing = 5;\r\n    public static spacing = 5;\r\n\r\n    constructor(space: ChartSpace) {\r\n        this.space = space;\r\n    }\r\n\r\n    public get widgetSize(): number {\r\n        return ChartLegend._widgetSize;\r\n    }\r\n\r\n    public get widgetSpacing(): number {\r\n        return ChartLegend._widgetSpacing;\r\n    }\r\n\r\n    public getLines(): IPositionedTextLine[] {\r\n        const lines: IPositionedTextLine[] = [];\r\n        const textStyle = this.space.textStyle;\r\n        const x = this.bounds.x + ChartLegend._widgetSize + ChartLegend._widgetSpacing;\r\n        let y = this.bounds.y + FontMetrics.getTopToBaseline(textStyle);\r\n        this._getNames().forEach(name => {\r\n            lines.push({\r\n                text: name,\r\n                x: x,\r\n                y: y,\r\n                width: this.bounds.width,\r\n                stretched: false,\r\n                following: false,\r\n                color: textStyle.color,\r\n                fontFamily: textStyle.fontFamily,\r\n                fontSize: textStyle.fontSize,\r\n                emphasis: textStyle.emphasis\r\n            });\r\n            y += textStyle.lineSpacing;\r\n        });\r\n        return lines;\r\n    }\r\n\r\n    public performLayout(): void {\r\n        const size = this._getSize();\r\n        const spaceBounds = this.space.bounds;\r\n        let xPos = InSequence.Last;\r\n        let yPos = InSequence.Middle;\r\n        switch(this.position) {\r\n            case ChartAxisPosition.Left:\r\n                xPos = InSequence.First;\r\n                yPos = InSequence.Middle;\r\n                break;\r\n            case ChartAxisPosition.Right:\r\n                xPos = InSequence.Last;\r\n                yPos = InSequence.Middle;\r\n                break;\r\n            case ChartAxisPosition.Top:\r\n                xPos = InSequence.Middle;\r\n                yPos = InSequence.First;\r\n                break;\r\n            case ChartAxisPosition.Right:\r\n                xPos = InSequence.Middle;\r\n                yPos = InSequence.Last;\r\n                break;\r\n        }\r\n        this.bounds = spaceBounds.subtractSpacing(ChartLegend.spacing).placeInRectangle(size.width, size.height, xPos, yPos);\r\n    }\r\n\r\n    public getColors(): string[] {\r\n        let colors: string[];\r\n        if (this.onlySeries === undefined) {\r\n            colors = this.space.chart.series.map((series) => series.style.lineColor || series.style.fillColor || \"000000\");\r\n        } else {\r\n            colors = this.space.chart.series[this.onlySeries].categories.map((cat) => {\r\n                let color = \"000000\";\r\n                if (cat.style !== undefined) {\r\n                    color = cat.style.lineColor || cat.style.fillColor || \"000000\";\r\n                }\r\n                return color;\r\n            });\r\n        }\r\n        return colors;\r\n    }\r\n\r\n    private _getNames(): string[] {\r\n        let names: string[];\r\n        if (this.onlySeries === undefined) {\r\n            names = this.space.chart.series.map((series) => series.name);\r\n        } else {\r\n            names = this.space.chart.series[this.onlySeries].categories.map((cat) => cat.text || \"\");\r\n        }\r\n        return names;\r\n    }\r\n\r\n    private _getSize(): { width: number, height: number } {\r\n        const charWidth = FontMetrics.averageCharWidth(this.space.textStyle);\r\n        let maxChars = 0;\r\n        const names = this._getNames();\r\n        names.forEach(name => {\r\n            maxChars = Math.max(maxChars, name.length);\r\n        });\r\n        const lineSpacing = this.space.textStyle.lineSpacing;\r\n        const height = names.length * lineSpacing;\r\n        const textWidth = (maxChars + 1) * charWidth;\r\n        const widgetWidth = ChartLegend._widgetSize + ChartLegend._widgetSpacing;\r\n        return { width: textWidth + widgetWidth, height: height };\r\n    }\r\n}","export class Angle {\r\n    private _degrees: number = 0;\r\n\r\n    private constructor(degrees: number) {\r\n        this._degrees = degrees;\r\n    }\r\n\r\n    public static fromRotation(rot: number): Angle {\r\n        return new Angle(rot / 60000);\r\n    }\r\n\r\n    public static fromDegrees(degrees: number): Angle {\r\n        return new Angle(degrees);\r\n    }\r\n\r\n    public static fromRadians(rad: number): Angle {\r\n        return new Angle(rad * 180 / Math.PI);\r\n    }\r\n\r\n    public static fromNormalized(norm: number): Angle {\r\n        return new Angle(norm * 360);\r\n    }\r\n\r\n    public add(other: Angle): Angle {\r\n        return new Angle(this._degrees + other._degrees);\r\n    }\r\n\r\n    public subtract(other: Angle): Angle {\r\n        return new Angle(this._degrees - other._degrees);\r\n    }\r\n\r\n    public round(fullCircle: boolean): void {\r\n        if (!fullCircle || this._degrees !== 360) {\r\n            this._degrees = (this._degrees + 360) % 360;\r\n        }\r\n    }\r\n\r\n    public toDegrees(): number {\r\n        return this._degrees;\r\n    }\r\n\r\n    public toNormalized(): number {\r\n        return this._degrees / 360;\r\n    }\r\n\r\n    public toRadians(): number {\r\n        return this._degrees * Math.PI / 180;\r\n    }\r\n\r\n    public toRotation(): number {\r\n        return this._degrees * 60000;\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this._degrees}°`;\r\n    }\r\n}","import { Shape } from \"./shape\";\r\nimport { Angle } from \"../utils/geometry/angle\";\r\n\r\ninterface IFormula {\r\n    readonly name: string;\r\n    evaluate(guide: ShapeGuide): number;\r\n    toString(): string;\r\n}\r\n\r\nclass MultiplyDevideFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string, private z: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        const z = guide.getValue(this.z);\r\n        return (x * y) / z;\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: */ ${this.x} ${this.y} ${this.z}`;\r\n    }\r\n}\r\n\r\nclass AddSubtractFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string, private z: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        const z = guide.getValue(this.z);\r\n        return (x + y) - z;\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: +- ${this.x} ${this.y} ${this.z}`;\r\n    }\r\n}\r\n\r\nclass AddDevideFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string, private z: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        const z = guide.getValue(this.z);\r\n        return (x + y) / z;\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: +* ${this.x} ${this.y} ${this.z}`;\r\n    }\r\n}\r\n\r\nclass IfElseFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string, private z: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        const z = guide.getValue(this.z);\r\n        return (x > 0) ? y : z;\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: ?: ${this.x} ${this.y} ${this.z}`;\r\n    }\r\n}\r\n\r\nclass AbsoluteFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        return Math.abs(x);\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: abs ${this.x}`;\r\n    }\r\n}\r\n\r\nclass ArcTanFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        return Math.atan2(y, x);\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: at2 ${this.x} ${this.y}`;\r\n    }\r\n}\r\n\r\nclass CosineArcTanFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string, private z: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        const z = guide.getValue(this.z);\r\n        return (x * Math.cos(Math.atan2(z, y)));\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: cat2 ${this.x} ${this.y} ${this.z}`;\r\n    }\r\n}\r\n\r\nclass CosineFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getAngleValue(this.y);\r\n        return x * Math.cos(y.toRadians());\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: cos ${this.x} ${this.y}`;\r\n    }\r\n}\r\n\r\nclass MaximumFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        return Math.max(x, y);\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: max ${this.x} ${this.y}`;\r\n    }\r\n}\r\n\r\nclass MinimumFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        return Math.min(x, y);\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: min ${this.x} ${this.y}`;\r\n    }\r\n}\r\n\r\nclass ModuloFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string, private z: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        const z = guide.getValue(this.z);\r\n        return Math.sqrt(x * x + y * y + z * z);\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: mod ${this.x} ${this.y} ${this.z}`;\r\n    }\r\n}\r\n\r\nclass PinFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string, private z: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        const z = guide.getValue(this.z);\r\n        return (y < x) ? x : (y > z) ? z : y;\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: pin ${this.x} ${this.y} ${this.z}`;\r\n    }\r\n}\r\n\r\nclass SineArcTanFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string, private z: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        const z = guide.getValue(this.z);\r\n        return x * Math.sin(Math.atan2(z, y));\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: sat2 ${this.x} ${this.y} ${this.z}`;\r\n    }\r\n}\r\n\r\nclass SineFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getAngleValue(this.y);\r\n        return x * Math.sin(y.toRadians());\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: sin ${this.x} ${this.y}`;\r\n    }\r\n}\r\n\r\nclass SquareRootFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        return Math.sqrt(x);\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: sqrt ${this.x}`;\r\n    }\r\n}\r\n\r\nclass TangentFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string, private y: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        return x * Math.tan(y);\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: tan ${this.x} ${this.y}`;\r\n    }\r\n}\r\n\r\nclass LiteralValueFormula implements IFormula {\r\n\r\n    constructor(public name: string, private x: string) {\r\n    }\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        const x = guide.getValue(this.x);\r\n        return x;\r\n    }\r\n\r\n    public toString(): string {\r\n        return `${this.name}: val ${this.x}`;\r\n    }\r\n}\r\n\r\nclass FunctionFormula implements IFormula {\r\n    constructor (public name: string, private func: (shape: Shape) => number) {\r\n    }\r\n\r\n\r\n    public evaluate(guide: ShapeGuide): number {\r\n        return this.func(guide.shape);\r\n    }\r\n\r\n    \r\n    public toString(): string {\r\n        return `${this.name}: function`;\r\n    }\r\n}\r\n\r\nexport class ShapeGuide {\r\n    public shape: Shape;\r\n    private _formulas: IFormula[] = [];\r\n    private _variables: { name: string, val: number}[] = [];\r\n\r\n    constructor(shape: Shape) {\r\n        this.shape = shape;\r\n    }\r\n\r\n    public addFormula(formula: string, name: string): void {\r\n        const parts = formula.split(' ');\r\n        if (parts.length < 2) {\r\n            console.log(`Invalid formula for shape guide: ${formula}`);\r\n            return;\r\n        }\r\n        let form: IFormula | undefined = undefined;\r\n        switch(parts[0]) {\r\n            case \"*/\":\r\n                form = new MultiplyDevideFormula(name, parts[1], parts[2], parts[3]);\r\n                break;\r\n            case \"+-\":\r\n                form = new AddSubtractFormula(name, parts[1], parts[2], parts[3]);\r\n                break;\r\n            case \"+/\":\r\n                form = new AddDevideFormula(name, parts[1], parts[2], parts[3]);\r\n                break;\r\n            case \"?:\":\r\n                form = new IfElseFormula(name, parts[1], parts[2], parts[3]);\r\n                break;\r\n            case \"abs\":\r\n                form = new AbsoluteFormula(name, parts[1]);\r\n                break;\r\n            case \"at2\":\r\n                form = new ArcTanFormula(name, parts[1], parts[2]);\r\n                break;\r\n            case \"cat2\":\r\n                form = new CosineArcTanFormula(name, parts[1], parts[2], parts[3]);\r\n                break;\r\n            case \"cos\":\r\n                form = new CosineFormula(name, parts[1], parts[2]);\r\n                break;\r\n            case \"max\":\r\n                form = new MaximumFormula(name, parts[1], parts[2]);\r\n                break;\r\n            case \"min\":\r\n                form = new MinimumFormula(name, parts[1], parts[2]);\r\n                break;\r\n            case \"mod\":\r\n                form = new ModuloFormula(name, parts[1], parts[2], parts[3]);\r\n                break;\r\n            case \"pin\":\r\n                form = new PinFormula(name, parts[1], parts[2], parts[3]);\r\n                break;\r\n            case \"sat2\":\r\n                form = new SineArcTanFormula(name, parts[1], parts[2], parts[3]);\r\n                break;\r\n            case \"sin\":\r\n                form = new SineFormula(name, parts[1], parts[2]);\r\n                break;\r\n            case \"sqrt\":\r\n                form = new SquareRootFormula(name, parts[1]);\r\n                break;\r\n            case \"tan\":\r\n                form = new TangentFormula(name, parts[1], parts[2]);\r\n                break;\r\n            case \"val\":\r\n                form = new LiteralValueFormula(name, parts[1]);\r\n                break;\r\n            default:\r\n                console.log(`Don't know how to interpret formula: ${parts[0]}`);\r\n                break;\r\n        }\r\n        if (form !== undefined) {\r\n            this._formulas.push(form);\r\n        }\r\n    }\r\n\r\n    public getValue(statement: string): number {\r\n        let val: number;\r\n        const isNumber = /^(\\d|-)/.test(statement) && statement.indexOf(\"cd\") === -1;\r\n        if (isNumber) {\r\n            val = parseFloat(statement);\r\n        } else {\r\n            val = this._getVariableValue(statement);\r\n        }\r\n        return val;\r\n    }\r\n\r\n    public getAngleValue(statement: string): Angle {\r\n        const val = this.getValue(statement);\r\n        const angle = Angle.fromRotation(val);\r\n        return angle;\r\n    }\r\n\r\n    public evaluate(): void {\r\n        this._formulas.forEach(formula => {\r\n            this._evaluateVariable(formula);\r\n        })\r\n    }\r\n\r\n    public getVariableValueSummary(): string {\r\n        return this._variables.map(val => `${val.name}:${val.val}`).join(\";\");\r\n    }\r\n\r\n    private _getVariableValue(name: string): number {\r\n        let val = this._variables.find((current) => current.name === name);\r\n        if (val === undefined) {\r\n            // Check pre-defined variables.\r\n            // Taken from: https://social.msdn.microsoft.com/Forums/en-US/3f69ebb3-62a0-4fdd-b367-64790dfb2491/presetshapedefinitionsxml-does-not-specify-width-and-height-form-some-autoshapes?forum=os_binaryfile\r\n            switch(name) {\r\n                case \"h\":\r\n                    // Height\r\n                    val = this._createNamedVariable(new FunctionFormula(\"h\", (shape: Shape) => shape.height));\r\n                    break;\r\n                case \"hd2\":\r\n                    // Height / 2\r\n                    val = this._createNamedVariable(new FunctionFormula(\"hd2\", (shape: Shape) => shape.height / 2));\r\n                    break;\r\n                case \"hd3\":\r\n                    // Height / 3\r\n                    val = this._createNamedVariable(new FunctionFormula(\"hd3\", (shape: Shape) => shape.height / 3));\r\n                    break;\r\n                case \"hd4\":\r\n                    // Height / 4\r\n                    val = this._createNamedVariable(new FunctionFormula(\"hd4\", (shape: Shape) => shape.height / 4));\r\n                    break;\r\n                case \"hd5\":\r\n                    // Height / 5\r\n                    val = this._createNamedVariable(new FunctionFormula(\"hd5\", (shape: Shape) => shape.height / 5));\r\n                    break;\r\n                case \"hd6\":\r\n                    // Height / 6\r\n                    val = this._createNamedVariable(new FunctionFormula(\"hd6\", (shape: Shape) => shape.height / 6));\r\n                    break;\r\n                case \"hd8\":\r\n                    // Height / 8\r\n                    val = this._createNamedVariable(new FunctionFormula(\"hd8\", (shape: Shape) => shape.height / 8));\r\n                    break;\r\n                case \"w\":\r\n                    // Width\r\n                    val = this._createNamedVariable(new FunctionFormula(\"w\", (shape: Shape) => shape.width));\r\n                    break;\r\n                case \"wd2\":\r\n                    // Width / 2\r\n                    val = this._createNamedVariable(new FunctionFormula(\"wd2\", (shape: Shape) => shape.width / 2));\r\n                    break;\r\n                case \"wd3\":\r\n                    // Width / 3\r\n                    val = this._createNamedVariable(new FunctionFormula(\"wd3\", (shape: Shape) => shape.width / 3));\r\n                    break;\r\n                case \"wd4\":\r\n                    // Width / 4\r\n                    val = this._createNamedVariable(new FunctionFormula(\"wd4\", (shape: Shape) => shape.width / 4));\r\n                    break;\r\n                case \"wd5\":\r\n                    // Width / 5\r\n                    val = this._createNamedVariable(new FunctionFormula(\"wd5\", (shape: Shape) => shape.width / 5));\r\n                    break;\r\n                case \"wd6\":\r\n                    // Width / 6\r\n                    val = this._createNamedVariable(new FunctionFormula(\"wd6\", (shape: Shape) => shape.width / 6));\r\n                    break;\r\n                case \"wd8\":\r\n                    // Width / 8\r\n                    val = this._createNamedVariable(new FunctionFormula(\"wd8\", (shape: Shape) => shape.width / 8));\r\n                    break;\r\n                case \"wd10\":\r\n                    // Width / 10\r\n                    val = this._createNamedVariable(new FunctionFormula(\"wd10\", (shape: Shape) => shape.width / 10));\r\n                    break;\r\n                case \"cd2\":\r\n                    // 180 degrees or PI radians.\r\n                    val = this._createNamedVariable(new FunctionFormula(\"cd2\", (_shape: Shape) => Angle.fromNormalized(1/2).toRotation()));\r\n                    break;\r\n                case \"cd4\":\r\n                    // 90 degrees or half PI radians.\r\n                    val = this._createNamedVariable(new FunctionFormula(\"cd4\", (_shape: Shape) => Angle.fromNormalized(1/4).toRotation()));\r\n                    break;\r\n                case \"cd8\":\r\n                    // 45 degrees or quarter PI radians.\r\n                    val = this._createNamedVariable(new FunctionFormula(\"cd8\", (_shape: Shape) => Angle.fromNormalized(1/8).toRotation()));\r\n                    break;\r\n                case \"3cd4\":\r\n                    // 270 degrees or 1.5 PI radians.\r\n                    val = this._createNamedVariable(new FunctionFormula(\"3cd4\", (_shape: Shape) => Angle.fromNormalized(3/4).toRotation()));\r\n                    break;\r\n                case \"3cd8\":\r\n                    // 135 degrees or 3/4 PI radians.\r\n                    val = this._createNamedVariable(new FunctionFormula(\"3cd8\", (_shape: Shape) => Angle.fromNormalized(3/8).toRotation()));\r\n                    break;\r\n                case \"5cd8\":\r\n                    // 225 degrees or 5/4 PI radians.\r\n                    val = this._createNamedVariable(new FunctionFormula(\"5cd8\", (_shape: Shape) => Angle.fromNormalized(5/8).toRotation()));\r\n                    break;\r\n                case \"7cd8\":\r\n                    // 315 degrees or 7/4 PI radians.\r\n                    val = this._createNamedVariable(new FunctionFormula(\"7cd8\", (_shape: Shape) => Angle.fromNormalized(7/8).toRotation()));\r\n                    break;\r\n                case \"hc\":\r\n                    // Horizontal center\r\n                    val = this._createNamedVariable(new FunctionFormula(\"hc\", (shape: Shape) => shape.width / 2));\r\n                    break;\r\n                case \"vc\":\r\n                    // Vertical center\r\n                    val = this._createNamedVariable(new FunctionFormula(\"vc\", (shape: Shape) => shape.height / 2));\r\n                    break;\r\n                case \"t\":\r\n                    // Top\r\n                    val = this._createNamedVariable(new FunctionFormula(\"t\", (_shape: Shape) => 0));\r\n                    break;\r\n                case \"b\":\r\n                    // Bottom\r\n                    val = this._createNamedVariable(new FunctionFormula(\"b\", (shape: Shape) => shape.height));\r\n                    break;\r\n                case \"r\":\r\n                    // Right\r\n                    val = this._createNamedVariable(new FunctionFormula(\"r\", (shape: Shape) => shape.width));\r\n                    break;\r\n                case \"l\":\r\n                    // Left\r\n                    val = this._createNamedVariable(new FunctionFormula(\"l\", (_shape: Shape) => 0));\r\n                    break;\r\n                case \"ss\":\r\n                    // Short Side\r\n                    val = this._createNamedVariable(new FunctionFormula(\"ss\", (shape: Shape) => Math.min(shape.width, shape.height)));\r\n                    break;\r\n                case \"ssd2\":\r\n                    // Short Side / 2\r\n                    val = this._createNamedVariable(new FunctionFormula(\"ssd2\", (shape: Shape) => Math.min(shape.width, shape.height) / 2));\r\n                    break;\r\n                case \"ssd3\":\r\n                    // Short Side / 3\r\n                    val = this._createNamedVariable(new FunctionFormula(\"ssd3\", (shape: Shape) => Math.min(shape.width, shape.height) / 3));\r\n                    break;\r\n                case \"ssd4\":\r\n                    // Short Side / 4\r\n                    val = this._createNamedVariable(new FunctionFormula(\"ssd4\", (shape: Shape) => Math.min(shape.width, shape.height) / 4));\r\n                    break;\r\n                case \"ssd6\":\r\n                    // Short Side / 6\r\n                    val = this._createNamedVariable(new FunctionFormula(\"ssd6\", (shape: Shape) => Math.min(shape.width, shape.height) / 6));\r\n                    break;\r\n                case \"ssd8\":\r\n                    // Short Side / 8\r\n                    val = this._createNamedVariable(new FunctionFormula(\"ssd8\", (shape: Shape) => Math.min(shape.width, shape.height) / 8));\r\n                    break;\r\n                case \"ssd16\":\r\n                    // Short Side / 8\r\n                    val = this._createNamedVariable(new FunctionFormula(\"ssd16\", (shape: Shape) => Math.min(shape.width, shape.height) / 16));\r\n                    break;\r\n                case \"ssd32\":\r\n                    // Short Side / 32\r\n                    val = this._createNamedVariable(new FunctionFormula(\"ssd32\", (shape: Shape) => Math.min(shape.width, shape.height) / 32));\r\n                    break;\r\n                case \"ls\":\r\n                    // Long Side\r\n                    val = this._createNamedVariable(new FunctionFormula(\"ls\", (shape: Shape) => Math.max(shape.width, shape.height)));\r\n                    break\r\n                default:\r\n                    const names = this._formulas.map(formula => formula.name).join(\",\");\r\n                    console.log(`Unable to find variable ${name} in Shape Guide which defines variables: ${names}.`);\r\n                    break;\r\n            }\r\n        }\r\n        return (val !== undefined) ? val.val : Number.NaN;\r\n    }\r\n\r\n    private _evaluateVariable(formula: IFormula): void {\r\n        this._variables.push(this._createNamedVariable(formula));\r\n    }\r\n\r\n    private _createNamedVariable(formula: IFormula): { name: string, val: number } {\r\n        return { name: formula.name, val : formula.evaluate(this)};\r\n    }\r\n}","import { Point } from \"./point\";\r\nimport { Angle } from \"./angle\";\r\n\r\nexport class Ellipse {\r\n    public radiusX: number;\r\n    public radiusY: number;\r\n    public center: Point;\r\n\r\n    constructor(center: Point, radiusX: number, radiusY: number) {\r\n        this.center = center;\r\n        this.radiusX = radiusX;\r\n        this.radiusY = radiusY;\r\n    }\r\n\r\n    public static fromSinglePoint(point: Point, angle: Angle, radiusX: number, radiusY: number): Ellipse {\r\n        const radians = angle.toRadians();\r\n        const radius = Ellipse._localRadius(radians, radiusX, radiusY);\r\n        const x = point.x - radius * Math.cos(radians);\r\n        const y = point.y - radius * Math.sin(radians);\r\n        const center = new Point(x, y);\r\n        return new Ellipse(center, radiusX, radiusY);\r\n    }\r\n\r\n    public pointAtAngle(angle: Angle): Point {\r\n        // Ellipse has radius which changes with angle.\r\n        const radians = angle.toRadians();\r\n        const radius = this.localRadius(angle);\r\n        const x = this.center.x + radius * Math.cos(radians);\r\n        const y = this.center.y + radius * Math.sin(radians);\r\n        return new Point(x, y);\r\n    }\r\n\r\n    public localRadius(angle: Angle): number {\r\n        const radians = angle.toRadians();\r\n        return Ellipse._localRadius(radians, this.radiusX, this.radiusY);\r\n    }\r\n\r\n    public clone(): Ellipse {\r\n        return new Ellipse(this.center.clone(), this.radiusX, this.radiusY);\r\n    }\r\n\r\n    private static _localRadius(radians: number, radiusX: number, radiusY: number): number {\r\n        // Taken from polar representation of Ellipse.\r\n        const a = radiusX * Math.sin(radians);\r\n        const b = radiusY * Math.cos(radians);\r\n        const ab = radiusX * radiusY;\r\n        return ab / Math.sqrt((b * b) + (a * a));\r\n    }\r\n}","import { Point } from \"../utils/geometry/point\";\r\nimport { ShapeGuide } from \"./shape-guide\";\r\nimport { PointGuide } from \"./point-guide\";\r\nimport { Ellipse } from \"../utils/geometry/ellipse\";\r\nimport { Angle } from \"../utils/geometry/angle\";\r\n\r\nabstract class PathSegment {\r\n    protected _offset: Point = new Point(0, 0);\r\n    protected _scaling: Point = new Point(1, 1);\r\n\r\n    public translate(offset: Point): void {\r\n        this._offset = offset;\r\n    }\r\n\r\n    public scale(scaling: Point): void {\r\n        this._scaling = scaling;\r\n    }\r\n\r\n    abstract getEndPoint(guide: ShapeGuide, startPoint: Point): Point;\r\n    abstract buildPath(guide: ShapeGuide, startPoint: Point): string;\r\n    abstract clone(): PathSegment;\r\n\r\n    protected convertPoint(point: PointGuide, guide: ShapeGuide): Point {\r\n        return point.convertToPoint(guide).scale(this._scaling).translate(this._offset);\r\n    }\r\n}\r\n\r\nclass CloseSegment extends PathSegment {\r\n    public getEndPoint(_guide: ShapeGuide, _startPoint: Point): Point {\r\n        return new Point(0, 0);\r\n    }\r\n\r\n    public buildPath(_guide: ShapeGuide, _startPoint: Point): string {\r\n        return \" Z\";\r\n    }\r\n\r\n    public clone(): CloseSegment {\r\n        return new CloseSegment();\r\n    }\r\n}\r\n\r\nclass MoveTo extends PathSegment {\r\n    constructor(public point: PointGuide) {\r\n        super();\r\n    }\r\n\r\n    public getEndPoint(guide: ShapeGuide, _startPoint: Point): Point {\r\n        return this.convertPoint(this.point, guide);\r\n    }\r\n\r\n    public buildPath(guide: ShapeGuide, _startPoint: Point): string {\r\n        const point = this.convertPoint(this.point, guide);\r\n        return ` M ${point.x} ${point.y}`;\r\n    }\r\n\r\n    public clone(): MoveTo {\r\n        return new MoveTo(this.point);\r\n    }\r\n}\r\n\r\nclass LineTo extends MoveTo {\r\n    public getEndPoint(guide: ShapeGuide, _startPoint: Point): Point {\r\n        return this.convertPoint(this.point, guide);\r\n    }\r\n\r\n    public buildPath(guide: ShapeGuide, _startPoint: Point): string {\r\n        const point = this.convertPoint(this.point, guide);\r\n        return ` L ${point.x} ${point.y}`;\r\n    }\r\n\r\n    public clone(): LineTo {\r\n        return new LineTo(this.point);\r\n    }\r\n}\r\n\r\nclass ArcTo extends PathSegment {\r\n    constructor(public sweepAngle: string, public startAngle: string, public radiusX: string, public radiusY: string) {\r\n        super();\r\n    }\r\n\r\n    public getEndPoint(guide: ShapeGuide, startPoint: Point, overrideSweepAngle?: Angle): Point {\r\n        const startAngle = this._getAngleValue(guide, this.startAngle, false);\r\n        let sweepAngle = overrideSweepAngle || this._getAngleValue(guide, this.sweepAngle, true);\r\n        const radiusX = guide.getValue(this.radiusX) * this._scaling.x;\r\n        const radiusY = guide.getValue(this.radiusY) * this._scaling.y;\r\n        const ellipse = Ellipse.fromSinglePoint(startPoint, startAngle, radiusX, radiusY);\r\n        return ellipse.pointAtAngle(startAngle.add(sweepAngle));\r\n    }\r\n\r\n    public buildPath(guide: ShapeGuide, startPoint: Point): string {\r\n        let sweepAngle = this._getAngleValue(guide, this.sweepAngle, true);\r\n        const clockwise = this._clockwise(guide);\r\n        const radiusX = guide.getValue(this.radiusX) * this._scaling.x;\r\n        const radiusY = guide.getValue(this.radiusY) * this._scaling.y;\r\n        const endPoint = this.getEndPoint(guide, startPoint);\r\n        if (this._fullRotation(guide)) {\r\n            const midPoint = this.getEndPoint(guide, startPoint, Angle.fromNormalized(0.5));\r\n            const firstHalfPath = this._buildInternalPath(midPoint, Math.PI, radiusX, radiusY, true);\r\n            const secondHalfPath = this._buildInternalPath(endPoint, Math.PI, radiusX, radiusY, true);\r\n            return `${firstHalfPath}${secondHalfPath}`;\r\n        } else {\r\n            return this._buildInternalPath(endPoint, sweepAngle.toRadians(), radiusX, radiusY, clockwise);\r\n        }\r\n    }\r\n\r\n    public clone(): ArcTo {\r\n        return new ArcTo(this.sweepAngle, this.startAngle, this.radiusX, this.radiusY);\r\n    }\r\n\r\n    private _buildInternalPath(endPoint: Point, sweepAngle: number, radiusX: number, radiusY: number, clockwise: boolean): string {\r\n        const largeArc = (sweepAngle > Math.PI) ? \"1\" : \"0\";\r\n        const sweep = (clockwise) ? \"1\" : \"0\";\r\n        return ` A ${radiusX} ${radiusY} 0 ${largeArc} ${sweep} ${endPoint.x} ${endPoint.y}`;\r\n    }\r\n\r\n    private _getAngleValue(guide: ShapeGuide, variable: string, addFullRound: boolean): Angle {\r\n        const val = guide.getValue(variable);\r\n        const angle = Angle.fromRotation(val);\r\n        angle.round(addFullRound);\r\n        return angle;\r\n    }\r\n\r\n    private _clockwise(guide: ShapeGuide): boolean {\r\n        const val = guide.getValue(this.sweepAngle);\r\n        return val > 0;\r\n    }\r\n\r\n    private _fullRotation(guide: ShapeGuide): boolean {\r\n        const val = guide.getValue(this.sweepAngle);\r\n        return Angle.fromRotation(val).toNormalized() === 1;\r\n    }\r\n}\r\n\r\nclass CubicBezierTo extends PathSegment {\r\n    constructor(public endPoint: PointGuide, public control1: PointGuide, public control2: PointGuide) {\r\n        super();\r\n    }\r\n\r\n    public getEndPoint(guide: ShapeGuide, _startPoint: Point): Point {\r\n        return this.convertPoint(this.endPoint, guide);\r\n    }\r\n\r\n    public buildPath(guide: ShapeGuide, _startPoint: Point): string {\r\n        const endPoint = this.convertPoint(this.endPoint, guide);\r\n        const control1 = this.convertPoint(this.control1, guide);\r\n        const control2 = this.convertPoint(this.control2, guide);\r\n        return ` C ${control1.x} ${control1.y}, ${control2.x} ${control2.y}, ${endPoint.x} ${endPoint.y}`;\r\n    }\r\n\r\n    public clone(): CubicBezierTo {\r\n        return new CubicBezierTo(this.endPoint, this.control1, this.control2);\r\n    }\r\n}\r\n\r\nclass QuadBezierTo extends PathSegment {\r\n    constructor(public endPoint: PointGuide, public control: PointGuide) {\r\n        super();\r\n    }\r\n\r\n    public getEndPoint(guide: ShapeGuide, _startPoint: Point) {\r\n        return this.convertPoint(this.endPoint, guide);\r\n    }\r\n\r\n    public buildPath(guide: ShapeGuide, startPoint: Point): string {\r\n        const endPoint = this.convertPoint(this.endPoint, guide);\r\n        const control = this.convertPoint(this.control, guide);\r\n        const twoThird = 2 / 3;\r\n        const cubic1 = startPoint.translate(Point.difference(control, startPoint).scale(twoThird));\r\n        const cubic2 = endPoint.translate(Point.difference(control, endPoint).scale(twoThird));\r\n        return ` C ${cubic1.x} ${cubic1.y}, ${cubic2.x} ${cubic2.y}, ${endPoint.x} ${endPoint.y}`;\r\n    }\r\n\r\n    public clone(): QuadBezierTo {\r\n        return new QuadBezierTo(this.endPoint, this.control);\r\n    }\r\n}\r\n\r\nexport class ShapePath {\r\n    public filledIn: boolean;\r\n    public stroked: boolean;\r\n\r\n    private _guide: ShapeGuide;\r\n    private segments: PathSegment[] = [];\r\n    private _path: string | undefined = undefined;\r\n\r\n    constructor(guide: ShapeGuide, filledIn: boolean = true, stroked: boolean = true) {\r\n        this._guide = guide;\r\n        this.filledIn = filledIn;\r\n        this.stroked = stroked;\r\n    }\r\n\r\n    public translate(offset: Point): void {\r\n        this.segments.forEach(segment => {\r\n            segment.translate(offset);\r\n        });\r\n    }\r\n\r\n    public scale(scaling: Point): void {\r\n        this.segments.forEach(segment => {\r\n            segment.scale(scaling);\r\n        });\r\n    }\r\n\r\n    public moveTo(point: PointGuide): void {\r\n        this.segments.push(new MoveTo(point));\r\n    }\r\n\r\n    public lineTo(point: PointGuide): void {\r\n        this.segments.push(new LineTo(point));\r\n    }\r\n\r\n    public arcTo(sweepAngle: string, startAngle: string, radiusX: string, radiusY: string): void {\r\n        this.segments.push(new ArcTo(sweepAngle, startAngle, radiusX, radiusY));\r\n    }\r\n\r\n    public quadBezierTo(endPoint: PointGuide, control: PointGuide): void {\r\n        this.segments.push(new QuadBezierTo(endPoint, control));\r\n    }\r\n\r\n    public cubicBezierTo(point: PointGuide, control1: PointGuide, control2: PointGuide): void {\r\n        this.segments.push(new CubicBezierTo(point, control1, control2));\r\n    }\r\n\r\n    public close(): void {\r\n        this.segments.push(new CloseSegment());\r\n    }\r\n\r\n    public buildPath(): string {\r\n        if (this._path === undefined) {\r\n            this._path = \"\";\r\n            this._guide.evaluate();\r\n            let currentPoint: Point = new Point(0, 0);\r\n            this.segments.forEach(segment => {\r\n                this._path += segment.buildPath(this._guide, currentPoint);\r\n                currentPoint = segment.getEndPoint(this._guide, currentPoint);\r\n            });\r\n            this._path = this._path.substr(1);\r\n        }\r\n        return this._path;\r\n    }\r\n\r\n    public clone(): ShapePath {\r\n        const clone = new ShapePath(this._guide);\r\n        clone.segments = this.segments.map(segment => segment.clone());\r\n        return clone;\r\n    }\r\n}","import { Point } from \"../utils/geometry/point\";\r\nimport { Box } from \"../utils/geometry/box\";\r\nimport { ShapeGuide } from \"./shape-guide\";\r\nimport { PointGuide } from \"./point-guide\";\r\nimport { ShapePath } from \"./shape-path\";\r\n\r\nexport class Shape {\r\n    public width: number = 1;\r\n    public height: number = 1;\r\n    public fillColor: string | undefined = undefined;\r\n    public lineColor: string | undefined = undefined;\r\n\r\n    public guide: ShapeGuide;\r\n    public paths: ShapePath[];\r\n\r\n    constructor() {\r\n        this.guide = new ShapeGuide(this);\r\n        this.paths = [];\r\n        this.paths.push(new ShapePath(this.guide));\r\n    }\r\n\r\n    public translate(offset: Point): void {\r\n        this.paths.forEach(segment => {\r\n            segment.translate(offset);\r\n        });\r\n    }\r\n\r\n    public scale(scaling: Point): void {\r\n        this.paths.forEach(segment => {\r\n            segment.scale(scaling);\r\n        });\r\n    }\r\n\r\n    public addSegmentMove(point: PointGuide): void {\r\n        this.paths[this.paths.length - 1].moveTo(point);\r\n    }\r\n\r\n    public addSegmentLine(point: PointGuide): void {\r\n        this.paths[this.paths.length - 1].lineTo(point);\r\n    }\r\n\r\n    public addSegmentArc(sweepAngle: string, startAngle: string, radiusX: string, radiusY: string): void {\r\n        this.paths[this.paths.length - 1].arcTo(sweepAngle, startAngle, radiusX, radiusY);\r\n    }\r\n\r\n    public addSegmentQuadBezier(endPoint: PointGuide, control: PointGuide): void {\r\n        this.paths[this.paths.length - 1].quadBezierTo(endPoint, control);\r\n    }\r\n\r\n    public addSegmentCubicBezier(point: PointGuide, control1: PointGuide, control2: PointGuide): void {\r\n        this.paths[this.paths.length - 1].cubicBezierTo(point, control1, control2);\r\n    }\r\n\r\n    public addSegmentClose(): void {\r\n        this.paths[this.paths.length - 1].close();\r\n    }\r\n\r\n    public addPath(filledIn: boolean, stroked: boolean) {\r\n        this.paths.push(new ShapePath(this.guide, filledIn, stroked));\r\n    }\r\n\r\n    public performLayout(bounds: Box): void {\r\n        const scalingX = bounds.width / this.width;\r\n        const scalingY = bounds.height / this.height;\r\n        this.scale(new Point(scalingX, scalingY));\r\n        this.translate(bounds.topLeft);\r\n    }\r\n\r\n    public clone(): Shape {\r\n        const clone = new Shape();\r\n        clone.width = this.width;\r\n        clone.height = this.height;\r\n        clone.guide = this.guide;\r\n        clone.lineColor = this.lineColor;\r\n        clone.fillColor = this.fillColor;\r\n        clone.paths = this.paths.map((path) => path.clone());\r\n        return clone;\r\n    }\r\n}","import { Point } from \"../utils/geometry/point\";\r\nimport { ShapeGuide } from \"./shape-guide\";\r\n\r\nexport class PointGuide {\r\n    public x: string;\r\n    public y: string;\r\n    \r\n    constructor(x: string, y: string) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public static fromPoint(point: Point): PointGuide {\r\n        return new PointGuide(point.x.toString(), point.y.toString());\r\n    }\r\n\r\n    public convertToPoint(guide: ShapeGuide): Point {\r\n        const x = guide.getValue(this.x);\r\n        const y = guide.getValue(this.y);\r\n        return new Point(x, y);\r\n    }\r\n}","import { BarChart } from \"./bar-chart\";\r\nimport { IPainter, DashMode } from \"../painting/i-painter\";\r\nimport { ChartSpace, ChartType } from \"./chart-space\";\r\nimport { ChartStyle } from \"./chart-style\";\r\nimport { Box } from \"../utils/geometry/box\";\r\nimport { ChartLegend } from \"./chart-legend\";\r\nimport { ChartAxis } from \"./chart-axis\";\r\nimport { LineChart } from \"./line-chart\";\r\nimport { ChartValue } from \"./chart-value\";\r\nimport { AreaChart } from \"./area-chart\";\r\nimport { Point } from \"../utils/geometry/point\";\r\nimport { Shape } from \"../drawing/shape\";\r\nimport { PieChart } from \"./pie-chart\";\r\nimport { Ellipse } from \"../utils/geometry/ellipse\";\r\nimport { PointGuide } from \"../drawing/point-guide\";\r\nimport { Angle } from \"../utils/geometry/angle\";\r\n\r\nexport class ChartRenderer {\r\n    private _painter: IPainter;\r\n\r\n    constructor(painter: IPainter) {\r\n        this._painter = painter;\r\n    }\r\n\r\n    public renderChartSpace(space: ChartSpace) {\r\n        const spaceBounds = space.bounds;\r\n        if (spaceBounds !== undefined) {\r\n            this._renderBorderAndShading(space.style, spaceBounds);\r\n            const plotBounds = this._renderBorderAndShading(space.plotArea.style, space.plotArea.bounds);\r\n            if (space.legend !== undefined) {\r\n                this._renderLegend(space.legend);\r\n            }\r\n            if (space.plotArea.categoryAxis !== undefined) {\r\n                this._renderAxis(space.plotArea.categoryAxis);\r\n            }\r\n            if (space.plotArea.valueAxis !== undefined) {\r\n                this._renderAxis(space.plotArea.valueAxis);\r\n            }\r\n            switch(space.chartType) {\r\n                case ChartType.Bar:\r\n                    this._renderBarChart(space.chart as BarChart, plotBounds);\r\n                    break;\r\n                case ChartType.Line:\r\n                    this._renderLineChart(space.chart as LineChart, plotBounds);\r\n                    break;\r\n                case ChartType.Area:\r\n                    this._renderAreaChart(space.chart as AreaChart, plotBounds);\r\n                    break;\r\n                case ChartType.Pie:\r\n                    this._renderPieChart(space.chart as PieChart, plotBounds);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _renderBorderAndShading(style: ChartStyle, bounds: Box): Box {\r\n        let spacing = 0;\r\n        const x = bounds.left;\r\n        const y = bounds.top;\r\n        const xMax = bounds.right;\r\n        const yMax = bounds.bottom;\r\n        const lineColor = style.lineColor;\r\n        if (lineColor !== undefined) {\r\n            const thickness = style.lineThickness;\r\n            this._painter.paintLine(x, y, xMax, y, lineColor, thickness, DashMode.Solid);\r\n            this._painter.paintLine(xMax, y, xMax, yMax, lineColor, thickness, DashMode.Solid);\r\n            this._painter.paintLine(x, yMax, xMax, yMax, lineColor, thickness, DashMode.Solid);\r\n            this._painter.paintLine(x, y, x, yMax, lineColor, thickness, DashMode.Solid);\r\n            spacing = thickness;\r\n        }\r\n        const shading = style.fillColor;\r\n        if (shading !== undefined) {\r\n            const yMid = y + (bounds.height / 2);\r\n            this._painter.paintLine(x, yMid, xMax, yMid, shading, bounds.height, DashMode.Solid);\r\n        }\r\n        return bounds.subtractSpacing(spacing);\r\n    }\r\n\r\n    private _renderLegend(legend: ChartLegend): void {\r\n        this._renderBorderAndShading(legend.style, legend.bounds);\r\n        const colors = legend.getColors();\r\n        const widgetSize = legend.widgetSize;\r\n        legend.getLines().forEach((line, index) => {\r\n            const widgetX = line.x - widgetSize - legend.widgetSpacing;\r\n            const widgetY = line.y - 3;\r\n            this._painter.paintLine(widgetX, widgetY, widgetX + widgetSize, widgetY, colors[index], widgetSize, DashMode.Solid);\r\n            this._painter.paintText(line.x, line.y, line.width, line.stretched, line.text, line.color, line.justification!, line.fontFamily, line.fontSize, false, false);\r\n        });\r\n    }\r\n\r\n    private _renderAxis(axis: ChartAxis): void {\r\n        if (axis.positionedTexts !== undefined) {\r\n            axis.positionedTexts.forEach(line => {\r\n                this._painter.paintText(line.x, line.y, line.width, line.stretched, line.text, line.color, line.justification!, line.fontFamily, line.fontSize, false, false);\r\n            })\r\n        }\r\n        if (axis.positionedLines !== undefined && axis.style.lineColor !== undefined) {\r\n            const lineColor = axis.style.lineColor;\r\n            const thickness = axis.style.lineThickness;\r\n            axis.positionedLines.forEach(line => {\r\n                this._painter.paintLine(line.x1, line.y1, line.x2, line.y2, lineColor, thickness, DashMode.Solid);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _renderAreaChart(areaChart: AreaChart, bounds: Box): void {\r\n        const counts = areaChart.getCounts();\r\n        const catSpacing = bounds.width / counts.numSeries;\r\n        const flowX = bounds.x;\r\n        const topY = bounds.y;\r\n        const bottomY = topY + bounds.height;\r\n        const range = areaChart.getValueRange();\r\n        // Loop backward, to got correct Z index.\r\n        for(let seriesIndex = counts.numSeries - 1; seriesIndex >= 0; seriesIndex--) {\r\n            const shape = new Shape();\r\n            shape.addSegmentMove(PointGuide.fromPoint(bounds.bottomLeft));\r\n            const style = areaChart.series[seriesIndex].style;\r\n            for(let catIndex = 0; catIndex < counts.numCats; catIndex++) {\r\n                if (style.fillColor === undefined || style.fillColor === \"ffffff\") {\r\n                    break;\r\n                }\r\n                const val = this._normalizeValue(areaChart.getValue(catIndex, seriesIndex), range);\r\n                const x = flowX + catIndex * catSpacing;\r\n                const y = bottomY - (bottomY - topY) * val;\r\n                shape.addSegmentLine(new PointGuide(x.toString(), y.toString()));\r\n            }\r\n            shape.addSegmentLine(PointGuide.fromPoint(bounds.bottomRight));\r\n            shape.addSegmentLine(PointGuide.fromPoint(bounds.bottomLeft));\r\n            const path = shape.paths[0].buildPath();\r\n            this._painter.paintPolygon(path, style.fillColor, style.lineColor, style.lineThickness, DashMode.Solid);\r\n        }\r\n    }\r\n\r\n    private _renderLineChart(lineChart: LineChart, bounds: Box): void {\r\n        const counts = lineChart.getCounts();\r\n        const catSpacing = bounds.width / counts.numSeries;\r\n        const flowX = bounds.x;\r\n        const topY = bounds.y;\r\n        const bottomY = topY + bounds.height;\r\n        const range = lineChart.getValueRange();\r\n        for(let seriesIndex = 0; seriesIndex < counts.numSeries; seriesIndex++) {\r\n            let previousVal = this._normalizeValue(lineChart.getValue(0, seriesIndex), range);\r\n            for(let catIndex = 1; catIndex < counts.numCats; catIndex++) {\r\n                const style = lineChart.getSeriesStyle(seriesIndex, catIndex);\r\n                const val = this._normalizeValue(lineChart.getValue(catIndex, seriesIndex), range);\r\n                const x1 = flowX + (catIndex - 1) * catSpacing;\r\n                const y1 = bottomY - (bottomY - topY) * previousVal;\r\n                const x2 = flowX + catIndex * catSpacing;\r\n                const y2 = bottomY - (bottomY - topY) * val;\r\n                this._painter.paintLine(x1, y1, x2, y2, style.lineColor || \"000000\", style.lineThickness, DashMode.Solid);\r\n                previousVal = val;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _renderBarChart(barChart: BarChart, bounds: Box): void {\r\n        const counts = barChart.getCounts();\r\n        const seriesSpacing = bounds.width / ((counts.numCats + 1) * (counts.numSeries + 1));\r\n        const catSpacing = bounds.width / (counts.numSeries + 1);\r\n        const flowX = bounds.x + seriesSpacing;\r\n        const topY = bounds.y;\r\n        const bottomY = topY + bounds.height;\r\n        const range = barChart.getValueRange();\r\n        for(let seriesIndex = 0; seriesIndex < counts.numSeries; seriesIndex++) {\r\n            for(let catIndex = 0; catIndex < counts.numCats; catIndex++) {\r\n                const color = barChart.getSeriesStyle(seriesIndex, catIndex).fillColor || \"000000\";\r\n                const val = this._normalizeValue(barChart.getValue(catIndex, seriesIndex), range);\r\n                const x = flowX + catIndex * catSpacing + seriesIndex * seriesSpacing;\r\n                const y = bottomY - (bottomY - topY) * val;\r\n                this._painter.paintLine(x, bottomY, x, y, color, seriesSpacing, DashMode.Solid);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _renderPieChart(pieChart: PieChart, bounds: Box): void {\r\n        const counts = pieChart.getCounts();\r\n        const middle = new Point(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2);\r\n        const seriesIndex = 0;\r\n        const range = { min: 0, max: pieChart.getValueSum(seriesIndex)};\r\n        const radius = bounds.height / 2;\r\n        const circle = new Ellipse(middle, radius, radius);\r\n        // Start angle is relative to vertical (instead of horizontal axis of circle class).\r\n        let previousAngle = Angle.fromRotation(pieChart.startAngle).subtract(Angle.fromNormalized(0.25));\r\n        for(let catIndex = 0; catIndex < counts.numCats; catIndex++) {\r\n            const color = pieChart.getSeriesStyle(seriesIndex, catIndex).fillColor || \"000000\";\r\n            const val = Angle.fromNormalized(this._normalizeValue(pieChart.getValue(catIndex, seriesIndex), range));\r\n            const path = new Shape();\r\n            path.addSegmentMove(PointGuide.fromPoint(middle));\r\n            path.addSegmentLine(PointGuide.fromPoint(circle.pointAtAngle(previousAngle)));\r\n            path.addSegmentArc((val.toRotation()).toString(), (previousAngle.toRotation()).toString(), radius.toString(), radius.toString());\r\n            path.addSegmentLine(PointGuide.fromPoint(middle));\r\n            this._painter.paintPolygon(path.paths[0].buildPath(), color, undefined, undefined, DashMode.Solid);\r\n            previousAngle = previousAngle.add(val);\r\n        }\r\n    }\r\n\r\n    private _normalizeValue(val: ChartValue, range: { max: number, min: number }): number {\r\n        return (val.numeric! - range.min) / (range.max - range.min);\r\n    }\r\n}","import { DrawingRun } from \"./drawing-run\";\r\nimport { IPainter, DashMode } from \"../painting/i-painter\";\r\nimport { ChartRenderer } from \"../chart/chart-renderer\";\r\n\r\nexport class DrawingRenderer {\r\n    private _painter: IPainter;\r\n    private _chartRenderer: ChartRenderer;\r\n\r\n    constructor(painter: IPainter) {\r\n        this._painter = painter;\r\n        this._chartRenderer = new ChartRenderer(this._painter);\r\n    }\r\n\r\n    public renderDrawing(drawing: DrawingRun) {\r\n        const picture = drawing.picture;\r\n        if (picture !== undefined && picture.bounds !== undefined) {\r\n            const picBounds = picture.bounds;\r\n            this._painter.paintPicture(picBounds.x, picBounds.y, picBounds.width, picBounds.height, picture);\r\n        }\r\n        const chart = drawing.chart;\r\n        if (chart !== undefined) {\r\n            chart.ensureLoaded().then(() => {\r\n                this._chartRenderer.renderChartSpace(chart);\r\n            });\r\n        }\r\n        const shape = drawing.shape;\r\n        if (shape !== undefined) {\r\n            shape.paths.forEach(path => {\r\n                const g = path.buildPath();\r\n                const fillColor = (path.filledIn) ? shape.fillColor : undefined;\r\n                const lineColor = (path.stroked) ? shape.lineColor : undefined;\r\n                this._painter.paintPolygon(g, fillColor, lineColor, 1, DashMode.Solid);    \r\n            });\r\n        }\r\n    }\r\n    \r\n}","import { IPainter } from \"../painting/i-painter\";\r\nimport { MathRun } from \"./math-run\";\r\n\r\n\r\nexport class MathRenderer {\r\n    private _painter: IPainter;\r\n\r\n    constructor(painter: IPainter) {\r\n        this._painter = painter;\r\n    }\r\n\r\n    public renderMathRun(run: MathRun): void {\r\n        const objs = run.equation.objects;\r\n        objs.forEach(obj => {\r\n            obj.render(this._painter);\r\n        });\r\n    }\r\n}","import { IRun } from \"../paragraph/paragraph\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { Equation } from \"./equation\";\r\nimport { Size } from \"../utils/geometry/size\";\r\n\r\nexport class MathRun implements IRun {\r\n    public previousXPos: number | undefined;\r\n    public lastXPos: number | undefined;\r\n    public equation: Equation;\r\n    private _size: Size | undefined = undefined;\r\n\r\n    constructor(equation: Equation) {\r\n        this.equation = equation;\r\n    }\r\n\r\n    public getUsedWidth(): number {\r\n        if (this._size === undefined) {\r\n            this._size = this.equation.objects.getSize();\r\n        }\r\n        return this._size!.width;\r\n    }\r\n\r\n    public getHeight(): number {\r\n        if (this._size === undefined) {\r\n            this._size = this.equation.objects.getSize();\r\n        }\r\n        return this._size!.height;\r\n    }\r\n    \r\n    public performLayout(flow: VirtualFlow): void {\r\n        const padding = this.previousXPos || flow.getX();\r\n        this.lastXPos = this.equation.objects.performLayout(flow, padding);\r\n    }\r\n\r\n\r\n}","import { Paragraph } from \"./paragraph\";\r\nimport { TextRenderer } from \"../text/text-renderer\";\r\nimport { DrawingRenderer } from \"../drawing/drawing-renderer\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { TextRun } from \"../text/text-run\";\r\nimport { DrawingRun } from \"../drawing/drawing-run\";\r\nimport { MathRenderer } from \"../math/math-renderer\";\r\nimport { MathRun } from \"../math/math-run\";\r\n\r\nexport class ParagraphRenderer {\r\n    private _textRenderer: TextRenderer;\r\n    private _drawingRenderer: DrawingRenderer;\r\n    private _mathRenderer: MathRenderer;\r\n\r\n    constructor(painter: IPainter) {\r\n        this._textRenderer = new TextRenderer(painter);\r\n        this._drawingRenderer = new DrawingRenderer(painter);\r\n        this._mathRenderer = new MathRenderer(painter);\r\n    }\r\n\r\n    public renderParagraph(par: Paragraph): void {\r\n        let previousXPos: number | undefined = 0;\r\n        if (par.numberingRun !== undefined) {\r\n          this._textRenderer.renderTextRun(par.numberingRun);\r\n          previousXPos = par.numberingRun.lastXPos;\r\n        }\r\n        par.runs.forEach((run) => {\r\n            run.previousXPos = previousXPos;\r\n            if (run instanceof TextRun) {\r\n                this._textRenderer.renderTextRun(run);\r\n            } else if (run instanceof DrawingRun) {\r\n                this._drawingRenderer.renderDrawing(run);\r\n            } else if (run instanceof MathRun) {\r\n                this._mathRenderer.renderMathRun(run as MathRun);\r\n            } else {\r\n                console.log('Unknown Run type encountered during rendering, skipping it');\r\n            }\r\n            previousXPos = run.lastXPos;\r\n        });\r\n    }\r\n}","import { DocumentX } from '../document-x';\r\nimport { VirtualFlow } from '../utils/virtual-flow';\r\nimport { Paragraph } from '../paragraph/paragraph';\r\nimport { SvgPainter } from './svg-painter';\r\nimport { TableRenderer } from '../table/table-renderer';\r\nimport { ParagraphRenderer } from '../paragraph/paragraph-renderer';\r\n\r\nexport class Renderer {\r\n    private _painter: SvgPainter;\r\n    private _paragraphRenderer: ParagraphRenderer;\r\n    private _tableRenderer: TableRenderer;\r\n\r\n    constructor(content: HTMLElement) {\r\n        this._painter = new SvgPainter(content);\r\n        this._paragraphRenderer = new ParagraphRenderer(this._painter);\r\n        this._tableRenderer = new TableRenderer(this._painter, this._paragraphRenderer);\r\n    }\r\n\r\n    public renderDocument(docx: DocumentX): number {\r\n        const flow = VirtualFlow.fromSection(docx.section);\r\n        if (docx.section !== undefined && docx.section.pageWidth !== undefined) {\r\n            this._painter.setWidth(docx.section!.pageWidth);\r\n        }\r\n        docx.paragraphs.forEach(parOrTable => {\r\n            parOrTable.performLayout(flow);\r\n        });\r\n        docx.paragraphs.forEach(parOrTable => {\r\n            if (parOrTable instanceof Paragraph) {\r\n                this._paragraphRenderer.renderParagraph(parOrTable);\r\n            } else {\r\n                this._tableRenderer.renderTable(parOrTable);\r\n            }\r\n        });\r\n        return flow.getMaxY(true);\r\n    }\r\n\r\n    public clear() {\r\n        this._painter.clear();\r\n    }\r\n\r\n    public ensureHeight(newHeight: number): void {\r\n        this._painter.ensureHeight(newHeight);\r\n    }\r\n}\r\n","export class XmlPart {\r\n    private doc: Document;\r\n\r\n    constructor(doc: Document) {\r\n        this.doc = doc;\r\n    }\r\n\r\n    public get document(): Document {\r\n        return this.doc;\r\n    }\r\n}","import { XmlPart } from \"./xml-part\";\r\nimport { Xml } from \"../utils/xml\";\r\n\r\ndeclare var JSZip: any;\r\n\r\nexport class Package {\r\n    private package: any;\r\n    private content: { [key: string]: string[]} = {};\r\n\r\n    constructor(jsZip: any) {\r\n        this.package = jsZip;\r\n    }\r\n\r\n    public static ChartContentType = \"officedocument.drawingxml.chart\";\r\n    public static WordDocumentContentType = \"officedocument.wordprocessing.document.main\";\r\n    public static WordFontTableContentType = \"officedocument.wordprocessing.fontTable\";\r\n    public static WordNumberingContentType = \"officedocument.wordprocessing.numbering\";\r\n    public static WordSettingsContentType = \"officedocument.wordprocessing.settings\";\r\n    public static WordStylesContentType = \"officedocument.wordprocessing.styles\";\r\n    public static ExtendedPropertiesContentType = \"officedocument.extended-properties\";\r\n    public static CorePropertiesContentType = \"package.core-properties\";\r\n    public static RelationshipsContentType = \"package.relationships\";\r\n    public static JpegContentType = \"image/jpeg\";\r\n    public static PngContentType = \"image/png\";\r\n\r\n    public static loadFromUrl(url: string): Promise<Package> {\r\n        return new Promise<Package>((resolve, reject) => {\r\n            var oReq = new XMLHttpRequest();\r\n            oReq.open(\"GET\", url, true);\r\n            oReq.responseType = \"arraybuffer\";\r\n            \r\n            oReq.onload = (_oEvent) => {\r\n                if (oReq.status === 200) {\r\n                    var arrayBuffer = oReq.response;\r\n                    Package._loadFromArrayBuffer(arrayBuffer)\r\n                        .then((pack) => resolve(pack))\r\n                        .catch((err) => reject(err));\r\n                } else {\r\n                    reject(`File not found: ${url}`);\r\n                }\r\n            };\r\n            oReq.onerror = (evt) => {\r\n                reject(evt);\r\n            }\r\n            oReq.send(null);\r\n        });\r\n    }\r\n\r\n    public static loadFromFile(files: FileList): Promise<Package> {\r\n        return new Promise<Package>((resolve, reject) => {\r\n            for (var i=0, file; file=files[i]; i++) {\r\n                if (file.name.endsWith('.docx')) {\r\n                    var reader = new FileReader();\r\n        \r\n                    reader.onload = (e2) => {\r\n                        // finished reading file data.\r\n                        Package._loadFromArrayBuffer((e2.target as any).result).then(pack => resolve(pack)).catch(err => reject(err));\r\n                    }\r\n        \r\n                    reader.readAsArrayBuffer(file); // start reading the file data.\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private static _loadFromArrayBuffer(arrayBuffer: ArrayBuffer): Promise<Package> {\r\n        return new Promise<Package>((resolve, reject) => {\r\n            if (arrayBuffer && arrayBuffer.byteLength > 0) {\r\n                new JSZip().loadAsync(arrayBuffer).then((unzipped: any) => {\r\n                    const pack = new Package(unzipped);\r\n                    pack._loadContentTypes().then(() => {\r\n                        resolve(pack);\r\n                    }).catch((error: any) => {\r\n                        reject(error);\r\n                    });\r\n                }).catch((error: any) => {\r\n                    reject(error);\r\n                });\r\n            } else {\r\n                reject(\"No data received.\");\r\n            }\r\n        });\r\n    }\r\n\r\n    public hasPart(name: string): boolean {\r\n        return this.package.file(name) !== null;\r\n    }\r\n\r\n    public loadPartAsXml(name: string): Promise<XmlPart> {\r\n        return new Promise<XmlPart>((resolve, reject) => {\r\n            this.package.file(name).async(\"text\").then((partContent: string) => {\r\n                const partXml = new DOMParser().parseFromString(partContent, \"application/xml\");\r\n                resolve(new XmlPart(partXml));\r\n            }).catch((error: any) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    public loadPartAsBase64(name: string): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            this.package.file(name).async(\"base64\").then((content: string) => {\r\n                resolve(content);\r\n              }).catch((error: any) => {\r\n                  reject(error);\r\n              });\r\n        });\r\n    }\r\n\r\n    public loadPartAsBinary(name: string): Promise<ArrayBuffer> {\r\n        return new Promise<ArrayBuffer>((resolve, reject) => {\r\n            this.package.file(name).async(\"arraybuffer\").then((content: ArrayBuffer) => {\r\n                resolve(content);\r\n              }).catch((error: any) => {\r\n                  reject(error);\r\n              });\r\n        });\r\n    }\r\n\r\n    public getNamesByContentType(key: string): string[] {\r\n        return this.content[key];\r\n    }\r\n\r\n    private _loadContentTypes(): Promise<void> {\r\n        return new Promise<void>((resolve, reject) => {\r\n            this.loadPartAsXml('[Content_Types].xml').then(contentTypePart => {\r\n                contentTypePart.document.getRootNode().childNodes.forEach(content => {\r\n                    if (content.nodeName === \"Override\") {\r\n                        const partName = Xml.getAttribute(content, \"PartName\");\r\n                        const contentType = Xml.getAttribute(content, \"ContentType\");\r\n                        if (partName !== undefined && contentType !== undefined) {\r\n                            let key = contentType.replace('application/vnd.openxmlformats-', '');\r\n                            key = key.replace('+xml', '');\r\n                            if (this.content[key] === undefined) {\r\n                                this.content[key] = [];\r\n                            }\r\n                            this.content[key].push(partName);\r\n                        }\r\n                    }\r\n                });\r\n                resolve();\r\n            }).catch(error => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n}","import { Style } from \"./style\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { XmlPart } from \"../package/xml-part\";\r\n\r\nexport class NamedStyles {\r\n    private doc: Document;\r\n    private named: { [name: string]: Style} = {};\r\n    private _docDefaultStyle: Style;\r\n\r\n    constructor(part: XmlPart) {\r\n        this.doc = part.document;\r\n        this._docDefaultStyle = new Style();\r\n    }\r\n\r\n    public parseContent(): void {\r\n        if (this.named[\"Normal\"] === undefined) {\r\n            const root = Xml.getFirstChildOfName(this.doc, \"w:styles\");\r\n            if (root !== undefined) {\r\n                root.childNodes.forEach(child => {\r\n                    switch(child.nodeName) {\r\n                        case \"w:style\":\r\n                            const styleType = Xml.getAttribute(child, \"w:type\");\r\n                            if (styleType !== undefined && styleType !== \"numbering\") {\r\n                                const style = Style.fromStyleNode(child);\r\n                                const styleId = Xml.getAttribute(child, \"w:styleId\");\r\n                                if (styleId !== undefined) {\r\n                                    this.named[styleId] = style;\r\n                                }\r\n                            }\r\n                            break;\r\n                        case \"w:docDefaults\":\r\n                            this._docDefaultStyle = Style.fromDocDefaultsNode(child);\r\n                            break;\r\n                        case \"w:latentStyles\":\r\n                            // Ignore, UI related.\r\n                            break;\r\n                        default:\r\n                            console.log(`Don't know how to parse ${child.nodeName} during NamedStyle reading.`);\r\n                            break;\r\n                    }\r\n                });\r\n            }\r\n            for (const name in this.named) {\r\n                if (this.named.hasOwnProperty(name)) {\r\n                    const style = this.named[name];\r\n                    style.applyNamedStyles(this);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public get docDefaults(): Style {\r\n        return this._docDefaultStyle;\r\n    }\r\n\r\n    public getNamedStyle(name: string): Style | undefined {\r\n        return this.named[name];\r\n    }\r\n\r\n    public printDebugInfo(): void {\r\n        for (const name in this.named) {\r\n            if (this.named.hasOwnProperty(name)) {\r\n                const style = this.named[name];\r\n                console.log(`${name}: ${style.toString()}`);\r\n                if (style.parStyle) {\r\n                    console.log(style.parStyle.toString());\r\n                }\r\n                if (style.runStyle) {\r\n                    console.log(style.runStyle.toString());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","import { DocumentX } from \"./document-x\";\r\nimport { Xml } from \"./utils/xml\";\r\nimport { Metrics } from \"./utils/metrics\";\r\n\r\nexport class Section {\r\n    private sectionNode: ChildNode;\r\n    private _pageHeight: number | undefined;\r\n    private _pageWidth: number | undefined;\r\n    private _marginTop: number | undefined;\r\n    private _marginLeft: number | undefined;\r\n    private _marginBottom: number | undefined;\r\n    private _marginRight: number | undefined;\r\n    // TODO: SectionType, PageOrientation and PageNumberFormat\r\n\r\n    constructor(_doc: DocumentX, sectionNode: ChildNode) {\r\n        this.sectionNode = sectionNode;\r\n    }\r\n\r\n    public get pageHeight(): number | undefined {\r\n        this.parseContent();\r\n        return this._pageHeight;\r\n    }\r\n\r\n    public get pageWidth(): number | undefined {\r\n        this.parseContent();\r\n        return this._pageWidth;\r\n    }\r\n\r\n    public get marginTop(): number | undefined {\r\n        this.parseContent();\r\n        return this._marginTop;\r\n    }\r\n\r\n    public get marginLeft(): number | undefined {\r\n        this.parseContent();\r\n        return this._marginLeft;\r\n    }\r\n\r\n    public get marginBottom(): number | undefined {\r\n        this.parseContent();\r\n        return this._marginBottom;\r\n    }\r\n\r\n    public get marginRight(): number | undefined {\r\n        this.parseContent();\r\n        return this._marginRight;\r\n    }\r\n\r\n    private parseContent(): void {\r\n        if (this._pageWidth === undefined) {\r\n            this.sectionNode.childNodes.forEach(child => {\r\n                switch(child.nodeName) {\r\n                    case \"w:pgSz\":\r\n                        const width = Xml.getAttribute(child, \"w:w\");\r\n                        if (width !== undefined) {\r\n                            this._pageWidth = Metrics.convertTwipsToPixels(parseInt(width, 10));\r\n                        }\r\n                        const height = Xml.getAttribute(child, \"w:h\");\r\n                        if (height !== undefined) {\r\n                            this._pageHeight = Metrics.convertTwipsToPixels(parseInt(height, 10));\r\n                        }\r\n                        break;\r\n                    case \"w:pgMar\":\r\n                        const top = Xml.getAttribute(child, \"w:top\");\r\n                        if (top !== undefined) {\r\n                            this._marginTop = Metrics.convertTwipsToPixels(parseInt(top));\r\n                        }\r\n                        const left = Xml.getAttribute(child, \"w:left\");\r\n                        if (left !== undefined) {\r\n                            this._marginLeft = Metrics.convertTwipsToPixels(parseInt(left));\r\n                        }\r\n                        const bottom = Xml.getAttribute(child, \"w:bottom\");\r\n                        if (bottom !== undefined) {\r\n                            this._marginBottom = Metrics.convertTwipsToPixels(parseInt(bottom));\r\n                        }\r\n                        const right = Xml.getAttribute(child, \"w:right\");\r\n                        if (right !== undefined) {\r\n                            this._marginRight = Metrics.convertTwipsToPixels(parseInt(right));\r\n                        }\r\n                        break;\r\n                    case \"w:textDirection\":\r\n                    case \"w:docGrid\":\r\n                    case \"w:pgNumType\":\r\n                    case \"w:formProt\":\r\n                    case \"w:type\":\r\n                    case \"w:headerReference\":\r\n                    case \"w:footerReference\":\r\n                    case \"w:titlePg\":\r\n                    case \"w:cols\":\r\n                        // TODO: Implement\r\n                        break;\r\n                    default:\r\n                        console.log(`Don't know how to parse ${child.nodeName} during Section reading.`);\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}","import { TableBorder } from \"./table-border\";\r\n\r\nexport class TableBorderSet {\r\n    public borderTop: TableBorder | undefined;\r\n    public borderStart: TableBorder | undefined;\r\n    public borderBottom: TableBorder | undefined;\r\n    public borderEnd: TableBorder | undefined;\r\n    public borderHorizontal: TableBorder | undefined;\r\n    public borderVertical: TableBorder | undefined;\r\n\r\n    constructor() {\r\n        this.borderTop = new TableBorder();\r\n        this.borderBottom = new TableBorder();\r\n        this.borderStart = new TableBorder();\r\n        this.borderEnd = new TableBorder();\r\n    }\r\n}","import { Metrics } from \"../utils/metrics\";\r\n\r\nexport class TableMarginSet {\r\n    public cellMarginTop: number;\r\n    public cellMarginStart: number;\r\n    public cellMarginBottom: number;\r\n    public cellMarginEnd: number;\r\n\r\n    constructor() {\r\n        const defaultHorPadding = Metrics.convertTwipsToPixels(115);\r\n        this.cellMarginBottom = 0;\r\n        this.cellMarginTop = 0;\r\n        this.cellMarginStart = defaultHorPadding;\r\n        this.cellMarginEnd = defaultHorPadding;\r\n    }\r\n}","import { Justification } from \"../paragraph/par-style\";\r\nimport { TableBorderSet } from \"./table-border-set\";\r\nimport { TableMarginSet } from \"./table-margin-set\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\n\r\nexport class TableStyle {\r\n    public higherStyle: TableStyle | undefined;\r\n    public width: number | undefined;\r\n    private _justification: Justification | undefined;\r\n    private _identation: number | undefined;\r\n    private _borders: TableBorderSet | undefined;\r\n    private _margins: TableMarginSet | undefined;\r\n    private _cellSpacing: number | undefined;\r\n    private _columnSpan: number | undefined;\r\n    private _rowSpan: InSequence | undefined;\r\n    private _shading: string | undefined;\r\n\r\n    public get justification(): Justification {\r\n        return this._getValue(Justification.left, (style) => style._justification);\r\n    }\r\n\r\n    public set justification(justification: Justification) {\r\n        this._justification = justification;\r\n    }\r\n\r\n    public get identation(): number {\r\n        return this._getValue(0, (style) => style._identation);\r\n    }\r\n\r\n    public set identation(indentation: number) {\r\n        this._identation = indentation;\r\n    }\r\n\r\n    public get borders(): TableBorderSet {\r\n        return this._getValue(new TableBorderSet(), (style) => style._borders);\r\n    }\r\n\r\n    public set borders(borders: TableBorderSet) {\r\n        this._borders = borders;\r\n    }\r\n\r\n    public get hasBordersDefined(): boolean {\r\n        return this._borders !== undefined;\r\n    }\r\n\r\n    public get margins(): TableMarginSet {\r\n        return this._getValue(new TableMarginSet(), (style) => style._margins);\r\n    }\r\n\r\n    public set margins(margins: TableMarginSet) {\r\n        this._margins = margins;\r\n    }\r\n\r\n    public get cellSpacing(): number {\r\n        return this._getValue(0, (style) => style._cellSpacing);\r\n    }\r\n\r\n    public set cellSpacing(cellSpacing: number) {\r\n        this._cellSpacing = cellSpacing;\r\n    }\r\n\r\n    public get columnSpan(): number {\r\n        return this._getValue(1, (style) => style._columnSpan);\r\n    }\r\n\r\n    public set columnSpan(columnSpan: number) {\r\n        this._columnSpan = columnSpan;\r\n    }\r\n\r\n    public get rowSpanOrder(): InSequence {\r\n        return this._getValue(InSequence.Only, (style) => style._rowSpan);\r\n    }\r\n\r\n    public set rowSpanOrder(rowSpan: InSequence) {\r\n        this._rowSpan = rowSpan;\r\n    }\r\n\r\n    public get shading(): string {\r\n        return this._getValue(\"\", (style) => style._shading);\r\n    }\r\n\r\n    public set shading(shading: string) {\r\n        this._shading = shading;\r\n    }\r\n\r\n    private _getValue<T>(defaultValue: T, cb: (style: TableStyle) => T | undefined): T {\r\n        let val: T | undefined = cb(this);\r\n        if (val === undefined && this.higherStyle !== undefined) {\r\n            val = cb(this.higherStyle);\r\n        }\r\n        if (val === undefined) {\r\n            val = defaultValue;\r\n        }\r\n        return val!;\r\n    }\r\n}\r\n","import { Paragraph } from \"../paragraph/paragraph\";\r\nimport { DocumentX } from \"../document-x\";\r\nimport { TableStyle } from \"./table-style\";\r\nimport { TableColumn } from \"./table-column\";\r\nimport { TableRow } from \"./table-row\";\r\nimport { ILayoutable } from \"../utils/i-layoutable\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\n\r\nexport class Table implements ILayoutable {\r\n    public columns: TableColumn[];\r\n    public rows: TableRow[];\r\n    public docx: DocumentX;\r\n    public style: TableStyle;\r\n\r\n    constructor(docx: DocumentX) {\r\n        this.docx = docx;\r\n        this.columns = [];\r\n        this.rows = [];\r\n        this.style = new TableStyle();\r\n    }\r\n\r\n    public getPars(): Paragraph[] {\r\n        const pars: Paragraph[] = [];\r\n        this.rows.forEach(row => {\r\n            pars.push(...row.getPars());\r\n        });\r\n        return pars;\r\n    }\r\n\r\n    public getHeight(): number {\r\n        let height = 0;\r\n        this.rows.forEach(row => {\r\n            height += row.maxHeight || 0;\r\n        });\r\n        return height;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow): void {\r\n        // Update row span\r\n        this.rows.forEach((row, rowIndex) => {\r\n            row.cells.forEach((cell, columnIndex) => {\r\n                if (cell.style.rowSpanOrder === InSequence.First) {\r\n                    this._updateRowSpan(columnIndex, rowIndex);\r\n                }\r\n            });\r\n        });\r\n        this.rows.forEach(row => {\r\n            row.performLayout(flow);\r\n        });\r\n        // Set height of span cells\r\n        this.rows.forEach((row, rowIndex) => {\r\n            row.cells.forEach((cell, cellIndex) => {\r\n                if ((cell.numRowsInSpan > 1) && cell.bounds !== undefined) {\r\n                    cell.bounds.height = this._getHeightOfRowSpan(cellIndex, rowIndex);\r\n                }\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    private _updateRowSpan(cellIndex: number, startRowIndex: number): void {\r\n        let numRows = 1;\r\n        for (let i = startRowIndex; i < this.rows.length; i++) {\r\n            const currentRow = this.rows[i + 1];\r\n            if (currentRow === undefined || currentRow.cells[cellIndex].style.rowSpanOrder !== InSequence.Middle) {\r\n                // Past the last row of the span, set previous as last of the span.\r\n                this.rows[i].cells[cellIndex].style.rowSpanOrder = InSequence.Last;\r\n                break;\r\n            }\r\n            currentRow.cells[cellIndex].numRowsInSpan = 0;\r\n            numRows++;\r\n        }\r\n        this.rows[startRowIndex].cells[cellIndex].numRowsInSpan = numRows;\r\n    }\r\n\r\n    private _getHeightOfRowSpan(cellIndex: number, startRowIndex: number): number {\r\n        let height = 0;\r\n        const numRows = this.rows[startRowIndex].cells[cellIndex].numRowsInSpan;\r\n        for (let i = 0; i < numRows; i++) {\r\n            height += this.rows[startRowIndex + i].maxHeight || 0;\r\n        }\r\n        return height;\r\n    }\r\n}","\r\nexport class TableColumn {\r\n    public width: number;\r\n    public start: number;\r\n\r\n    constructor(start: number, width: number) {\r\n        this.start = start;\r\n        this.width = width;\r\n    }\r\n}\r\n","import { Paragraph } from \"../paragraph/paragraph\";\r\nimport { TableCell } from \"./table-cell\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { Table } from \"./table\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\n\r\nexport class TableRow {\r\n    public table: Table;\r\n    public cells: TableCell[] = [];\r\n    public maxHeight: number | undefined;\r\n\r\n    constructor(table: Table) {\r\n        this.table = table;\r\n    }\r\n\r\n    public setOrder(order: InSequence) {\r\n        this.cells.forEach(cell => cell.rowOrder = order);\r\n    }\r\n\r\n    public getPars(): Paragraph[] {\r\n        const pars: Paragraph[] = [];\r\n        this.cells.forEach(cell => {\r\n            pars.push(...cell.pars);\r\n        });\r\n        return pars;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow): void {\r\n        let maxHeight = 0;\r\n        this.cells.forEach(cell => {\r\n            cell.performLayout(flow);\r\n            if (cell.style.rowSpanOrder === InSequence.Only) {\r\n                const cellHeight = cell.bounds!.height;\r\n                maxHeight = Math.max(cellHeight, maxHeight);\r\n            }\r\n        });\r\n        // Set the max height as height for all cells.\r\n        this.cells.forEach(cell => {\r\n            if (cell.style.rowSpanOrder === InSequence.Only) {\r\n                cell.bounds!.height = maxHeight;\r\n            }\r\n        });\r\n        this.maxHeight = maxHeight;\r\n        flow.advancePosition(maxHeight);\r\n    }\r\n}\r\n","import { TableColumn } from \"./table-column\";\r\nimport { Paragraph } from \"../paragraph/paragraph\";\r\nimport { TableStyle } from \"./table-style\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { Box } from \"../utils/geometry/box\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\n\r\nexport class TableCell {\r\n    public id: string | undefined = undefined;\r\n    public pars: Paragraph[] = [];\r\n    public style: TableStyle;\r\n    public bounds: Box | undefined;\r\n    public numRowsInSpan: number = 1;\r\n    public rowOrder: InSequence | undefined;\r\n    private _allColumns: TableColumn[];\r\n    private _startColumnIndex: number;\r\n    private _columns: TableColumn[] | undefined = undefined;\r\n    private _contentBounds: Box | undefined;\r\n\r\n    constructor(columns: TableColumn[], style: TableStyle, startColumnIndex: number) {\r\n        this.style = style;\r\n        this._allColumns = columns;\r\n        this._startColumnIndex = startColumnIndex;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow): void {\r\n        const x = flow.getX() + this._getColumns()[0].start;\r\n        const y = flow.getY();\r\n        const margins = this.style.margins;\r\n        const borders = this.style.borders;\r\n        this.bounds = new Box(x, y, this._getWidth(), 0);\r\n        const rowOrder = (this.rowOrder === undefined) ? InSequence.Only : this.rowOrder;\r\n        const columnOrder = this._getColumnOrder();\r\n        this._contentBounds = this.bounds.clone().subtractBordersAndMargins(borders, margins, rowOrder, columnOrder);\r\n        const contentHeight = this._performInnerLayout(flow, this._contentBounds);\r\n        this._contentBounds.height = contentHeight;\r\n        this.bounds = this._contentBounds.addBordersAndMargins(borders, margins, rowOrder, columnOrder);\r\n    }\r\n\r\n    public get numColumns(): number {\r\n        return this._getColumns().length;\r\n    }\r\n\r\n    private _getColumns(): TableColumn[] {\r\n        if (this._columns === undefined) {\r\n            const columnSpan = this.style.columnSpan;\r\n            this._columns = this._allColumns.slice(this._startColumnIndex, this._startColumnIndex + columnSpan);\r\n        }\r\n        return this._columns;\r\n    }\r\n\r\n    private _getWidth(): number {\r\n        let width = 0;\r\n        this._getColumns().forEach(col => {\r\n            width += col.width;\r\n        });\r\n        return width;\r\n    }\r\n\r\n    private _performInnerLayout(flow: VirtualFlow, bounds: Box): number {\r\n        const cellFlow = new VirtualFlow(bounds.left, bounds.right, bounds.top);\r\n        this.pars.forEach(par => {\r\n            par.performLayout(cellFlow);\r\n        });\r\n        flow.copyObstaclesFrom(cellFlow);\r\n        return cellFlow.getMaxY(false) - bounds.top;\r\n    }\r\n\r\n    private _getColumnOrder(): InSequence {\r\n        let order = InSequence.Middle;\r\n        const numAllColumns = this._allColumns.length;\r\n        if (numAllColumns === 1) {\r\n            order = InSequence.Only;\r\n        } else if (this._startColumnIndex === 0) {\r\n            order = InSequence.First;\r\n        } else if (this._startColumnIndex + this.numColumns === numAllColumns) {\r\n            order = InSequence.Last;\r\n        }\r\n        return order;\r\n    }\r\n}\r\n","import { Xml } from \"../utils/xml\";\r\nimport { Style } from \"./style\";\r\nimport { TextRun } from \"./text-run\";\r\nimport { RunStyle } from \"./run-style\";\r\nimport { ParStyle } from \"../paragraph/par-style\";\r\nimport { NamedStyles } from \"./named-styles\";\r\n\r\nexport class TextReader {\r\n    public static readTextRun(runNode: ChildNode, parStyle: ParStyle | undefined, namedStyles: NamedStyles | undefined): TextRun {\r\n        const run = new TextRun([], new Style());\r\n        const presentationNode = Xml.getFirstChildOfName(runNode, \"w:rPr\");\r\n        if (presentationNode !== undefined && presentationNode.hasChildNodes()) {\r\n            run.style.runStyle = RunStyle.fromPresentationNode(presentationNode);\r\n        }\r\n        if (parStyle !== undefined) {\r\n            run.style.parStyle = parStyle;\r\n        }\r\n        run.texts = TextReader._getTexts(runNode);\r\n        run.style.applyNamedStyles(namedStyles);\r\n        return run;\r\n    }\r\n\r\n    private static _getTexts(runNode: ChildNode): string[] {\r\n        const texts: string[] = [];\r\n        if (runNode.hasChildNodes()) {\r\n            runNode.childNodes.forEach((node) => {\r\n                switch(node.nodeName) {\r\n                    case \"w:t\":\r\n                        const content = node.textContent;\r\n                        if (content !== null) {\r\n                            texts.push(content);\r\n                        }\r\n                        break;\r\n                    case \"w:br\":\r\n                    case \"w:cr\":\r\n                        texts.push(\"\\n\");\r\n                        break;\r\n                    case \"w:tab\":\r\n                        texts.push(\"\\t\");\r\n                        break;\r\n                    default:\r\n                        // Ignore all other nodes\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n        return texts;\r\n    }\r\n}","import { DocumentX } from \"../document-x\";\r\nimport { Package } from \"../package/package\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { Box } from \"../utils/geometry/box\";\r\nimport { ILayoutable } from \"../utils/i-layoutable\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\n\r\ndeclare var UTIF: any;\r\ndeclare var WMFJS: any;\r\ndeclare var EMFJS: any;\r\n\r\nexport class Picture implements ILayoutable {\r\n    private _pack: Package;\r\n    private _name: string;\r\n    private _imageUrl: string | SVGElement | undefined;\r\n    public bounds: Box | undefined;\r\n\r\n    public static fromPicNode(picNode: ChildNode, docx: DocumentX): Picture | undefined {\r\n        let run: Picture | undefined = undefined;\r\n        const blipFill = Xml.getFirstChildOfName(picNode, \"pic:blipFill\");\r\n        if (blipFill !== undefined) {\r\n            const blip = Xml.getFirstChildOfName(blipFill, \"a:blip\");\r\n            if (blip !== undefined) {\r\n                const relId = Xml.getAttribute(blip, \"r:embed\");\r\n                let target: string | undefined = undefined;\r\n                if (docx.relationships !== undefined && relId !== undefined) {\r\n                    target = docx.relationships.getTarget(relId);\r\n                    run = new Picture(docx.pack, `word/${target}`);\r\n                }\r\n            }\r\n        }\r\n        return run;\r\n    }\r\n\r\n    constructor(pack: Package, name: string) {\r\n        this._pack = pack;\r\n        this._name = name;\r\n    }\r\n\r\n    public getImageUrl(): Promise<string | SVGElement> {\r\n        return new Promise<string | SVGElement>((resolve, reject) => {\r\n            if (this._imageUrl !== undefined) {\r\n                resolve(this._imageUrl);\r\n            } else {\r\n                const fileParts = this._name.split('.');\r\n                const fileExtension = fileParts[fileParts.length - 1];\r\n                let binaryProc: ((buffer: ArrayBuffer, bounds: Box) => Promise<string | SVGElement>) | undefined = undefined;\r\n                let mimeType: string | undefined = undefined;\r\n                switch(fileExtension) {\r\n                    case \"jpg\":\r\n                    case \"jpeg\":\r\n                        mimeType = 'image/jpeg';\r\n                        break;\r\n                    case \"png\":\r\n                        mimeType = 'image/png';\r\n                        break;\r\n                    case \"gif\":\r\n                        mimeType = 'image/gif';\r\n                        break;\r\n                    case \"bmp\":\r\n                        mimeType = 'image/bmp';\r\n                        break;\r\n                    case \"webp\":\r\n                        mimeType = 'image/webp';\r\n                        break;\r\n                    case \"tif\":\r\n                    case \"tiff\":\r\n                        if (this._hasTiffSupport) {\r\n                            binaryProc = this._getImageUrlForTiff;\r\n                        }\r\n                        break;\r\n                    case \"wmf\":\r\n                        if (this._hasWmfSupport) {\r\n                            binaryProc = this._getImageUrlForWmf;\r\n                        }\r\n                        break;\r\n                    case \"wmz\":\r\n                        // TODO: Implement decompression to WMF\r\n                        break;\r\n                    case \"emf\":\r\n                        if (this._hasEmfSupport) {\r\n                            binaryProc = this._getImageUrlForEmf;\r\n                        }\r\n                        break;\r\n                    case \"emz\":\r\n                        // TODO: Implement decompression to EMF\r\n                        break;\r\n                }\r\n                if (mimeType !== undefined) {\r\n                    this._pack.loadPartAsBase64(this._name).then(content => {\r\n                        this._imageUrl = `data:${mimeType};base64,${content}`;\r\n                        resolve(this._imageUrl);\r\n                    }).catch(error => {\r\n                        reject(error);\r\n                    });\r\n                } else if (binaryProc !== undefined && this.bounds !== undefined) {\r\n                    const bounds = this.bounds;\r\n                    this._pack.loadPartAsBinary(this._name).then(buffer => {\r\n                        binaryProc!(buffer, bounds).then((url) => {\r\n                            this._imageUrl = url;\r\n                            resolve(this._imageUrl);\r\n                        }).catch((err: any) => {\r\n                            reject(err);\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    public performLayout(_flow: VirtualFlow): void {\r\n    }\r\n\r\n    private get _hasTiffSupport(): boolean {\r\n        return UTIF !== undefined;\r\n    }\r\n\r\n    private _getImageUrlForTiff(buffer: ArrayBuffer, _bounds: Box): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            const ifds = UTIF.decode(buffer);\r\n            let vsns = ifds;\r\n            let ma = 0;\r\n            let page = vsns[0];\r\n            if (ifds[0].subIFD) {\r\n                vsns = vsns.concat(ifds[0].subIFD);\r\n            }\r\n            for (let i = 0; i < vsns.length; i++) {\r\n                const img = vsns[i];\r\n                if (img[\"t258\"] === null || img[\"t258\"].length < 3) {\r\n                    continue;\r\n                }\r\n                const ar = img[\"t256\"] * img[\"t257\"];\r\n                if (ar > ma) {\r\n                    ma = ar;\r\n                    page = img;\r\n                }\r\n            }\r\n            UTIF.decodeImage(buffer, page, ifds);\r\n            const rgba = UTIF.toRGBA8(page)\r\n            const width = page.width\r\n            const height = page.height;\r\n            const ind = 0; // TODO: Should we check for index??\r\n            UTIF._xhrs.splice(ind, 1);\r\n            var canvas = document.createElement(\"canvas\");\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            const context = canvas.getContext(\"2d\");\r\n            if (context !== null) {\r\n                const imgd = context.createImageData(width, height);\r\n                for (let i = 0; i < rgba.length; i++) {\r\n                    imgd.data[i] = rgba[i];\r\n                }\r\n                context.putImageData(imgd, 0, 0);\r\n                resolve(canvas.toDataURL());\r\n            } else {\r\n                reject(\"Unable to create offscreen Canvas element\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private get _hasEmfSupport(): boolean {\r\n        return EMFJS !== undefined;\r\n    }\r\n\r\n    private _getImageUrlForEmf(buffer: ArrayBuffer, bounds: Box): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            EMFJS.loggingEnabled(false);\r\n            const renderer = new EMFJS.Renderer(buffer);\r\n            const width = bounds.width;\r\n            const height = bounds.height;\r\n            const settings = {\r\n                width: width + \"pt\",\r\n                height: height + \"pt\",\r\n                xExt: width,\r\n                yExt: height,\r\n                mapMode: 8\r\n            }\r\n            const result = renderer.render(settings);\r\n            if (result !== undefined) {\r\n                resolve(result);\r\n            } else {\r\n                reject(\"Error during WMF parsing.\");  \r\n            }\r\n        });\r\n    }\r\n\r\n    private get _hasWmfSupport(): boolean {\r\n        return WMFJS !== undefined;\r\n    }\r\n\r\n    private _getImageUrlForWmf(buffer: ArrayBuffer, bounds: Box): Promise<string> {\r\n        return new Promise<string>((resolve, reject) => {\r\n            WMFJS.loggingEnabled(false);\r\n            const renderer = new WMFJS.Renderer(buffer);\r\n            const width = bounds.width;\r\n            const height = bounds.height;\r\n            const settings = {\r\n                width: width + \"pt\",\r\n                height: height + \"pt\",\r\n                xExt: width,\r\n                yExt: height,\r\n                mapMode: 8\r\n            }\r\n            const result = renderer.render(settings);\r\n            if (result !== undefined) {\r\n                resolve(result);\r\n            } else {\r\n                reject(\"Error during WMF parsing.\");  \r\n            }\r\n        });\r\n    }\r\n}","import { ChartSpace } from \"./chart-space\";\r\nimport { ChartSeries } from \"./chart-series\";\r\nimport { ChartValue } from \"./chart-value\";\r\nimport { ChartAxisCrossMode } from \"./chart-axis\";\r\nimport { ChartStyle } from \"./chart-style\";\r\n\r\nexport abstract class BaseChart {\r\n    public series: ChartSeries[] = [];\r\n    public space: ChartSpace;\r\n    private _rangeMin: number | undefined;\r\n    private _rangeMax: number | undefined;\r\n\r\n    constructor(space: ChartSpace) {\r\n        this.space = space;\r\n    }\r\n\r\n    public getCounts(): {numCats: number, numValues: number, numSeries: number} {\r\n        return {\r\n            numCats: this.series[0].categories.length,\r\n            numValues: this.series[0].values.length,\r\n            numSeries: this.series.length\r\n        };\r\n    }\r\n\r\n    public getValue(catIndex: number, seriesIndex: number): ChartValue {\r\n        return this.series[seriesIndex].values[catIndex];\r\n    }\r\n\r\n    public getValueRange(): { max: number, min: number } {\r\n        if (this._rangeMax !== undefined && this._rangeMin !== undefined) {\r\n            return { min: this._rangeMin, max: this._rangeMax };\r\n        }\r\n        let max = Number.MIN_VALUE;\r\n        let min = Number.MAX_VALUE;\r\n        this.series.forEach(series => {\r\n            series.values.forEach(val => {\r\n                const num = val.numeric;\r\n                if (num !== undefined) {\r\n                    max = Math.max(max, num);\r\n                    min = Math.min(min, num);\r\n                }\r\n            });\r\n        });\r\n        const valueAxis = this.space.plotArea.valueAxis;\r\n        if (valueAxis !== undefined && valueAxis.crossMode === ChartAxisCrossMode.AutoZero) {\r\n            min = 0;\r\n        }\r\n        this._rangeMin = min;\r\n        this._rangeMax = max;\r\n        return { max: max, min: min};\r\n    }\r\n\r\n    public setValueRange(min: number, max: number): void {\r\n        this._rangeMin = min,\r\n        this._rangeMax = max;\r\n    }\r\n\r\n    public getSeriesStyle(seriesIndex: number, categoryIndex: number): ChartStyle {\r\n        let style;\r\n        const cat = this.series[seriesIndex].categories[categoryIndex];\r\n        if (cat.style !== undefined) {\r\n            style = cat.style;\r\n        } else {\r\n            style = this.series[seriesIndex].style;\r\n        }\r\n        return style;\r\n    }\r\n}","import { ChartValue } from \"./chart-value\";\r\nimport { ChartStyle } from \"./chart-style\";\r\n\r\nexport class ChartSeries {\r\n    public categories: ChartValue[] = [];\r\n    public values: ChartValue[] = [];\r\n    public style: ChartStyle = new ChartStyle();\r\n    public name: string = \"\";\r\n\r\n    public get hasNumericValues(): boolean {\r\n        return this.values.length > 0 && this.values[0].numeric !== undefined;\r\n    }\r\n\r\n    public get hasNumericCategories(): boolean {\r\n        return this.categories.length > 0 && this.categories[0].numeric !== undefined;\r\n    }\r\n}","import { ChartStyle } from \"./chart-style\";\r\n\r\nexport class ChartValue {\r\n    public numeric: number | undefined = undefined;\r\n    public text: string | undefined = undefined;\r\n    public style: ChartStyle | undefined = undefined;\r\n\r\n    public toString(): string {\r\n        let str = \"\";\r\n        if (this.numeric !== undefined) {\r\n            str = this.numeric.toString();\r\n        } else if (this.text !== undefined) {\r\n            str = this.text;\r\n        }\r\n        return str;\r\n    }\r\n}","import { ChartSpace } from \"./chart-space\";\r\nimport { BaseChart } from \"./base-chart\";\r\n\r\nexport class LineChart extends BaseChart {\r\n    constructor(space: ChartSpace) {\r\n        super(space);\r\n    }\r\n\r\n}","import { ChartSpace } from \"./chart-space\";\r\nimport { BaseChart } from \"./base-chart\";\r\n\r\nexport class AreaChart extends BaseChart {\r\n    constructor(space: ChartSpace) {\r\n        super(space);\r\n    }\r\n\r\n}","import { ChartSpace } from \"./chart-space\";\r\nimport { BaseChart } from \"./base-chart\";\r\n\r\nexport class PieChart extends BaseChart {\r\n    public startAngle: number;\r\n\r\n    constructor(space: ChartSpace) {\r\n        super(space);\r\n        this.startAngle = 0;\r\n    }\r\n\r\n    public getValueSum(seriesIndex: number): number {\r\n        const values = this.series[seriesIndex].values;\r\n        let count = 0;\r\n        for (let i = 0; i < values.length; i++) {\r\n            const numeric = values[i].numeric;\r\n            if (numeric !== undefined) {\r\n                count += numeric;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}","import { Shape } from \"./shape\";\r\n\r\nexport class PresetShapeFactory {\r\n    private static creators: any = {};\r\n\r\n    public static defineShape(name: string, shape: Shape) {\r\n        this.creators[name] = () => shape.clone();\r\n    }\r\n\r\n    public createShape(name: string): Shape | undefined {\r\n        let shape: Shape | undefined = undefined;\r\n        const creator: () => Shape = PresetShapeFactory.creators[name];\r\n        if (creator !== undefined) {\r\n            shape = creator();\r\n        } else {\r\n            console.log(`Not sure how to draw a ${name}.`);\r\n        }\r\n        return shape;\r\n    }\r\n}","import { Shape } from \"./shape\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { PresetShapeFactory } from \"./preset-shape-factory\";\r\nimport { PointGuide } from \"./point-guide\";\r\n\r\nexport class ShapeReader {\r\n    private static _presetFactory = new PresetShapeFactory();\r\n\r\n    public readShape(shapeNode: Node): Shape | undefined {\r\n        let shape: Shape | undefined = new Shape();\r\n        let fillColor: string | undefined = undefined;\r\n        let lineColor: string | undefined = undefined;\r\n        const presentationNode = Xml.getFirstChildOfName(shapeNode, \"wps:spPr\");\r\n        if (presentationNode !== undefined) {\r\n            presentationNode.childNodes.forEach(child => {\r\n                switch(child.nodeName) {\r\n                    case \"a:custGeom\":\r\n                        shape = this._readCustomShape(child);\r\n                        break;\r\n                    case \"a:prstGeom\":\r\n                        shape = this._readPresetShape(child);\r\n                        break;\r\n                    case \"a:solidFill\":\r\n                        fillColor = this._readFillColor(child);\r\n                        break;\r\n                    case \"a:ln\":\r\n                        const firstChild = child.firstChild;\r\n                        if (firstChild !== null) {\r\n                            lineColor = this._readFillColor(child.firstChild!);\r\n                        }\r\n                        break;\r\n                    case \"a:noFill\":\r\n                        fillColor = undefined;\r\n                        break;\r\n                    case \"a:xfrm\":\r\n                        // Ignore\r\n                        break;\r\n                    default:\r\n                        console.log(`Don't know how to parse ${child.nodeName} during Shape reading.`);\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n        if (shape !== undefined) {\r\n            shape.lineColor = lineColor;\r\n            shape.fillColor = fillColor;\r\n        }\r\n        return shape;\r\n    }\r\n\r\n    public readPath(pathNode: Node, shape: Shape): void {\r\n        let filledIn = true;\r\n        let stroked = true;\r\n        const fill = Xml.getAttribute(pathNode, \"fill\");\r\n        if (fill !== undefined) {\r\n            filledIn = fill !== \"none\";\r\n        }\r\n        const stroke = Xml.getAttribute(pathNode, \"stroke\");\r\n        if (stroke !== undefined) {\r\n            stroked = Xml.attributeAsBoolean(stroke);\r\n        }\r\n        shape.addPath(filledIn, stroked);\r\n        pathNode.childNodes.forEach(segmentNode => {\r\n            if (segmentNode.nodeType === Node.ELEMENT_NODE) {\r\n                switch(segmentNode.nodeName) {\r\n                    case \"a:arcTo\":\r\n                    case \"arcTo\":\r\n                        this._addAngle(segmentNode, shape);\r\n                        break;\r\n                    case \"a:moveTo\":\r\n                    case \"moveTo\":\r\n                        const movePointNode = Xml.getFirstChildOfName(segmentNode, [\"pt\", \"a:pt\"]);\r\n                        if (movePointNode !== undefined) {\r\n                            shape.addSegmentMove(this._readPoint(movePointNode));\r\n                        } else {\r\n                            console.log(\"Invalid move-to path segment encountered.\");\r\n                        }\r\n                        break;\r\n                    case \"a:lnTo\":\r\n                    case \"lnTo\":\r\n                        const linePointNode = Xml.getFirstChildOfName(segmentNode, [\"pt\", \"a:pt\"]);\r\n                        if (linePointNode !== undefined) {\r\n                            shape.addSegmentLine(this._readPoint(linePointNode));\r\n                        } else {\r\n                            console.log(\"Invalid line-to path segment encountered.\");\r\n                        }\r\n                        break;\r\n                    case \"a:cubicBezTo\":\r\n                    case \"cubicBezTo\":\r\n                        this._addCubicBezier(segmentNode, shape);\r\n                        break;\r\n                    case \"a:quadBezTo\":\r\n                    case \"quadBezTo\":\r\n                        this._addQuadBezier(segmentNode, shape);\r\n                        break;\r\n                    case \"a:close\":\r\n                    case \"close\":\r\n                        shape.addSegmentClose();\r\n                        break;\r\n                    default:\r\n                        console.log(`Unknown path segment ${segmentNode.nodeName} encountered during reading of Shape`);\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _readPresetShape(presetNode: Node): Shape | undefined {\r\n        let shape: Shape | undefined = undefined;\r\n        const name = Xml.getAttribute(presetNode, \"prst\");\r\n        if (name !== undefined) {\r\n            shape = ShapeReader._presetFactory.createShape(name);\r\n        }\r\n        return shape;\r\n    }\r\n\r\n    private _readCustomShape(customNode: Node): Shape | undefined {\r\n        let shape: Shape | undefined = undefined;\r\n        const pathListNode = Xml.getFirstChildOfName(customNode, \"a:pathLst\");\r\n        if (pathListNode !== undefined) {\r\n            const pathNode = Xml.getFirstChildOfName(pathListNode, \"a:path\");\r\n            if (pathNode !== undefined) {\r\n                shape = new Shape();\r\n                this.readPath(pathNode, shape);\r\n                const widthAttr = Xml.getAttribute(pathNode, \"w\");\r\n                if (widthAttr !== undefined) {\r\n                    shape.width = parseInt(widthAttr);\r\n                }\r\n                const heightAttr = Xml.getAttribute(pathNode, \"h\");\r\n                if (heightAttr !== undefined) {\r\n                    shape.height = parseInt(heightAttr);\r\n                }\r\n            }\r\n        }\r\n        return shape;\r\n    }\r\n\r\n    private _readFillColor(fillNode: Node): string | undefined {\r\n        let color: string | undefined = undefined;\r\n        const colorNode = fillNode.firstChild;\r\n        if (colorNode !== null) {\r\n            color = Xml.getStringValue(colorNode);\r\n        }\r\n        return color;\r\n    }\r\n\r\n    private _addAngle(segmentNode: Node, shape: Shape): void {\r\n        const sweepAngle = Xml.getAttribute(segmentNode, \"swAng\");\r\n        const startAngle = Xml.getAttribute(segmentNode, \"stAng\");\r\n        const radiusX = Xml.getAttribute(segmentNode, \"wR\");\r\n        const radiusY = Xml.getAttribute(segmentNode, \"hR\");\r\n        if (sweepAngle !== undefined && startAngle !== undefined && radiusX !== undefined && radiusY !== undefined) {\r\n            shape.addSegmentArc(sweepAngle, startAngle, radiusX, radiusY);\r\n        }\r\n    }\r\n\r\n    private _addQuadBezier(segmentNode: Node, shape: Shape): void {\r\n        const childNodes = segmentNode.childNodes;\r\n        if (childNodes.length === 3) {\r\n            const endPoint = this._readPoint(childNodes[1]);\r\n            const control = this._readPoint(childNodes[0]);\r\n            shape.addSegmentQuadBezier(endPoint, control);\r\n        }\r\n    }\r\n\r\n    private _addCubicBezier(segmentNode: Node, shape: Shape): void {\r\n        const childNodes = segmentNode.childNodes;\r\n        if (childNodes.length === 3) {\r\n            const endPoint = this._readPoint(childNodes[1]);\r\n            const control1 = this._readPoint(childNodes[0]);\r\n            const control2 = this._readPoint(childNodes[2]);\r\n            shape.addSegmentCubicBezier(endPoint, control1, control2);\r\n        }\r\n    }\r\n\r\n    private _readPoint(pointNode: Node): PointGuide {\r\n        let x = \"0\";\r\n        let y = \"0\";\r\n        const xAttr = Xml.getAttribute(pointNode, \"x\");\r\n        const yAttr = Xml.getAttribute(pointNode, \"y\");\r\n        if (xAttr !== undefined) {\r\n            x = xAttr;\r\n        }\r\n        if (yAttr !== undefined) {\r\n            y = yAttr;\r\n        }\r\n        return new PointGuide(x, y);\r\n    }\r\n}","import { Xml } from \"../utils/xml\";\r\nimport { Metrics } from \"../utils/metrics\";\r\nimport { ShapeBounds, ShapeAnchorMode, ShapePositionReference, ShapePositionAlignMode } from \"./shape-bounds\";\r\n\r\nexport class ShapeBoundsReader {\r\n\r\n    public static fromShapePropertiesNode(shapePropNode: ChildNode): ShapeBounds {\r\n        const bounds = new ShapeBounds();\r\n        bounds.anchor = ShapeAnchorMode.Floating;\r\n        const frame = Xml.getFirstChildOfName(shapePropNode, \"a:xfrm\");\r\n        if (frame !== undefined) {\r\n            const flipH = Xml.getAttribute(frame, \"flipH\");\r\n            if (flipH !== undefined) {\r\n                bounds.flipHorizontal = true;\r\n            }\r\n            const flipV = Xml.getAttribute(frame, \"flipV\");\r\n            if (flipV !== undefined) {\r\n                bounds.flipVertical = true;\r\n            }\r\n            const rot = Xml.getAttribute(frame, \"rot\");\r\n            if (rot !== undefined) {\r\n                bounds.rotation = Metrics.convertRotationToRadians(parseInt(rot));\r\n            }\r\n            const offset = Xml.getFirstChildOfName(frame, \"a:off\");\r\n            if (offset !== undefined) {\r\n                const offsetX = Xml.getAttribute(offset, \"x\");\r\n                if (offsetX !== undefined) {\r\n                    bounds.offsetX = Metrics.convertEmuToPixels(parseInt(offsetX));\r\n                }\r\n                const offsetY = Xml.getAttribute(offset, \"y\");\r\n                if (offsetY !== undefined) {\r\n                    bounds.offsetY = Metrics.convertEmuToPixels(parseInt(offsetY));\r\n                }\r\n            }\r\n            ShapeBoundsReader._readExtent(frame, \"a:ext\", bounds);\r\n        }\r\n        return bounds;\r\n    }\r\n\r\n    public static fromInlineNode(inlineNode: ChildNode): ShapeBounds {\r\n        const bounds = new ShapeBounds();\r\n        bounds.anchor = ShapeAnchorMode.Inline;\r\n        ShapeBoundsReader._readExtent(inlineNode, \"wp:extent\", bounds);\r\n        ShapeBoundsReader._readHorizontalPosition(inlineNode, bounds);\r\n        ShapeBoundsReader._readVerticalPosition(inlineNode, bounds);\r\n        return bounds;\r\n    }\r\n\r\n    public static fromAnchorNode(anchorNode: ChildNode): ShapeBounds {\r\n        const bounds = new ShapeBounds();\r\n        bounds.anchor = ShapeAnchorMode.Floating;\r\n        ShapeBoundsReader._readExtent(anchorNode, \"wp:extent\", bounds);\r\n        ShapeBoundsReader._readHorizontalPosition(anchorNode, bounds);\r\n        ShapeBoundsReader._readVerticalPosition(anchorNode, bounds);\r\n        return bounds;\r\n    }\r\n\r\n    private static _readHorizontalPosition(parent: Node, bounds: ShapeBounds): void {\r\n        const horPos = Xml.getFirstChildOfName(parent, \"wp:positionH\");\r\n        if (horPos !== undefined) {\r\n            const reference = ShapeBoundsReader._readPositionReference(horPos);\r\n            if (reference !== undefined) {\r\n                bounds.referenceX = reference;\r\n            }\r\n            const referenceOffset = ShapeBoundsReader._readPositionReferenceOffset(horPos);\r\n            bounds.referenceOffsetX = referenceOffset;\r\n            const align = ShapeBoundsReader._readPositionAlignment(horPos);\r\n            if (align !== undefined) {\r\n                bounds.alignX = align;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _readVerticalPosition(parent: Node, bounds: ShapeBounds): void {\r\n        const vertPos = Xml.getFirstChildOfName(parent, \"wp:positionV\");\r\n        if (vertPos !== undefined) {\r\n            const reference = ShapeBoundsReader._readPositionReference(vertPos);\r\n            if (reference !== undefined) {\r\n                bounds.referenceY = reference;\r\n            }\r\n            const referenceOffset = ShapeBoundsReader._readPositionReferenceOffset(vertPos);\r\n            bounds.referenceOffsetY = referenceOffset;\r\n            const align = ShapeBoundsReader._readPositionAlignment(vertPos);\r\n            if (align !== undefined) {\r\n                bounds.alignY = align;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _readPositionReference(node: Node): ShapePositionReference | undefined {\r\n        let reference: ShapePositionReference | undefined = undefined;\r\n        const relativeFrom = Xml.getAttribute(node, \"relativeFrom\");\r\n        if (relativeFrom !== undefined) {\r\n            switch(relativeFrom.toLowerCase()) {\r\n                case \"character\":\r\n                case \"line\":\r\n                    reference = ShapePositionReference.Character;\r\n                    break;\r\n                case \"column\":\r\n                    reference = ShapePositionReference.Column;\r\n                    break;\r\n                case \"leftmargin\":\r\n                case \"topmargin\":\r\n                    reference = ShapePositionReference.StartMargin;\r\n                    break;\r\n                case \"rightmargin\":\r\n                case \"bottommargin\":\r\n                    reference = ShapePositionReference.EndMargin;\r\n                    break;\r\n                case \"insidemargin\":\r\n                    reference = ShapePositionReference.InsideMargin;\r\n                    break;\r\n                case \"outsidemargin\":\r\n                    reference = ShapePositionReference.OutsideMargin;\r\n                    break;\r\n                case \"margin\":\r\n                    reference = ShapePositionReference.Margin;\r\n                    break;\r\n                case \"page\":\r\n                    reference = ShapePositionReference.Page;\r\n                    break;\r\n                case \"paragraph\":\r\n                    reference = ShapePositionReference.Paragraph;\r\n                    break;\r\n            }\r\n        }\r\n        return reference;\r\n    }\r\n\r\n    private static _readPositionAlignment(node: Node): ShapePositionAlignMode | undefined {\r\n        let align: ShapePositionAlignMode | undefined = undefined;\r\n        const alignNode = Xml.getFirstChildOfName(node, \"wp:align\");\r\n        if (alignNode !== undefined && alignNode.textContent !== null) {\r\n            switch(alignNode.textContent.toLowerCase()) {\r\n                case \"left\":\r\n                case \"top\":\r\n                    align = ShapePositionAlignMode.Start;\r\n                    break;\r\n                case \"right\":\r\n                case \"bottom\":\r\n                    align = ShapePositionAlignMode.End;\r\n                    break;\r\n                case \"inside\":\r\n                    align = ShapePositionAlignMode.Inside;\r\n                    break;\r\n                case \"outside\":\r\n                    align = ShapePositionAlignMode.Outside;\r\n                    break;\r\n                case \"center\":\r\n                    align = ShapePositionAlignMode.Center;\r\n                    break;\r\n            }\r\n        }\r\n        return align;\r\n    }\r\n\r\n    private static _readPositionReferenceOffset(node: Node): number {\r\n        let offset: number = 0;\r\n        const offsetNode = Xml.getFirstChildOfName(node, \"wp:posOffset\");\r\n        if (offsetNode !== undefined && offsetNode.textContent !== null) {\r\n            offset = Metrics.convertEmuToPixels(parseInt(offsetNode.textContent));\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    private static _readExtent(parent: ChildNode, nodeName: string, bounds: ShapeBounds): void {\r\n        const extent = Xml.getFirstChildOfName(parent, nodeName);\r\n        if (extent !== undefined) {\r\n            const extentX = Xml.getAttribute(extent, \"cx\");\r\n            if (extentX !== undefined) {\r\n                bounds.sizeX = Metrics.convertEmuToPixels(parseInt(extentX));\r\n            }\r\n            const extentY = Xml.getAttribute(extent, \"cy\");\r\n            if (extentY !== undefined) {\r\n                bounds.sizeY = Metrics.convertEmuToPixels(parseInt(extentY));\r\n            }\r\n        }\r\n    }\r\n}","import { DocumentX } from \"../document-x\";\r\nimport { DrawingRun, WrapMode } from \"./drawing-run\";\r\nimport { ShapeBounds } from \"./shape-bounds\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { Picture } from \"./picture\";\r\nimport { ChartSpace } from \"../chart/chart-space\";\r\nimport { XmlPart } from \"../package/xml-part\";\r\nimport { ChartReader } from \"../chart/chart-reader\";\r\nimport { ShapeReader } from \"./shape-reader\";\r\nimport { ShapeBoundsReader } from \"./shape-bounds-reader\";\r\n\r\nexport class DrawingReader {\r\n    private static shapeReader = new ShapeReader();\r\n\r\n    public static readDrawingRun(drawingNode: ChildNode, docx: DocumentX): DrawingRun {\r\n        let bounds = new ShapeBounds();\r\n        let wrapMode = WrapMode.None;\r\n        const child = drawingNode.childNodes[0];\r\n        if (child.nodeName === \"wp:anchor\") {\r\n            bounds = ShapeBoundsReader.fromAnchorNode(child);\r\n            wrapMode = WrapMode.TopAndBottom;\r\n        } else if (child.nodeName === \"wp:inline\") {\r\n            bounds = ShapeBoundsReader.fromInlineNode(child);\r\n        }\r\n        const drawing = new DrawingRun(bounds, wrapMode);\r\n        const graphic = Xml.getFirstChildOfName(child, \"a:graphic\");\r\n        if (graphic !== undefined) {\r\n            const graphicData = Xml.getFirstChildOfName(graphic, \"a:graphicData\");\r\n            if (graphicData !== undefined) {\r\n                this._readGraphicData(drawing, graphicData, docx);\r\n            }\r\n        }\r\n        return drawing;\r\n    }\r\n\r\n    private static _readGraphicData(drawing: DrawingRun, graphicData: Node, docx: DocumentX): void {\r\n        graphicData.childNodes.forEach(childNode => {\r\n            switch (childNode.nodeName) {\r\n                case \"pic:pic\":\r\n                    drawing.picture = Picture.fromPicNode(childNode, docx);\r\n                    break;\r\n                case \"c:chart\":\r\n                    const relationship = Xml.getAttribute(childNode, \"r:id\");\r\n                    if (relationship !== undefined && docx.relationships !== undefined) {\r\n                        const chartTarget = docx.relationships.getTarget(relationship);\r\n                        drawing.chart = this.readChartFromPart(docx.pack.loadPartAsXml(`word/${chartTarget}`));\r\n                    }\r\n                    break;\r\n                case \"wps:wsp\":\r\n                    drawing.shape = this.shapeReader.readShape(childNode);\r\n                    break;\r\n                case \"wpg:wgp\":\r\n                    this._readGraphicData(drawing, childNode, docx);\r\n                    break;\r\n                case \"wpg:grpSpPr\":\r\n                case \"wpg:cNvGrpSpPr\":\r\n                    // TODO: Imeplement style for shape group.\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${childNode.nodeName} during Drawing reading.`);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    private static readChartFromPart(promise: Promise<XmlPart>): ChartSpace {\r\n        const space = new ChartSpace();\r\n        const readingPromise =\r\n            new Promise<void>((resolve, reject) => {\r\n                promise.then(part => {\r\n                    this.readChartFromDocument(part.document, space);\r\n                    resolve();\r\n                }).catch(err => {\r\n                    reject(err);\r\n                })\r\n            });\r\n        space.setPromise(readingPromise);\r\n        return space;\r\n    }\r\n\r\n    private static readChartFromDocument(doc: XMLDocument, space: ChartSpace): ChartSpace {\r\n        const chartSpaceNode = doc.getRootNode().firstChild;\r\n        if (chartSpaceNode !== null) {\r\n            return ChartReader.readChartFromNode(chartSpaceNode, space);\r\n        } else {\r\n            console.log('Failed to find chart');\r\n            return new ChartSpace();\r\n        }\r\n    }\r\n}","import { Xml } from \"../utils/xml\";\r\nimport { ChartSpace, ChartType } from \"./chart-space\";\r\nimport { BarChart } from \"./bar-chart\";\r\nimport { ChartSeries } from \"./chart-series\";\r\nimport { ChartValue } from \"./chart-value\";\r\nimport { ChartAxis, ChartAxisPosition, ChartAxisTickMode, ChartAxisLabelAlignment, ChartAxisCrossMode } from \"./chart-axis\";\r\nimport { ChartStyle } from \"./chart-style\";\r\nimport { Metrics } from \"../utils/metrics\";\r\nimport { ChartLegend } from \"./chart-legend\";\r\nimport { LineChart } from \"./line-chart\";\r\nimport { AreaChart } from \"./area-chart\";\r\nimport { PieChart } from \"./pie-chart\";\r\n\r\nexport class ChartReader {\r\n    public static readChartFromNode(chartSpaceNode: Node, space: ChartSpace): ChartSpace {\r\n        const chartNode = Xml.getFirstChildOfName(chartSpaceNode, \"c:chart\");\r\n        if (chartNode !== undefined) {\r\n            chartNode.childNodes.forEach(child => {\r\n                switch (child.nodeName) {\r\n                    case \"c:spPr\":\r\n                        space.style = this._readStyle(child);\r\n                        break;\r\n                    case \"c:plotArea\":\r\n                        this._readPlotArea(child, space);\r\n                        break;\r\n                    case \"c:legend\":\r\n                        this._readLegend(child, space);\r\n                        break;\r\n                }                \r\n            });\r\n        }\r\n        return space;\r\n    }\r\n\r\n    private static _readPlotArea(plotAreaNode: Node, space: ChartSpace): void {\r\n        plotAreaNode.childNodes.forEach(child => {\r\n            switch(child.nodeName) {\r\n                case \"c:areaChart\":\r\n                    space.setAreaChart(this._readAreaChart(child, space));\r\n                    break;\r\n                case \"c:lineChart\":\r\n                    space.setLineChart(this._readLineChart(child, space));\r\n                    break;\r\n                case \"c:barChart\":\r\n                    space.setBarChart(this._readBarChart(child, space));\r\n                    break;\r\n                case \"c:pieChart\":\r\n                    space.setPieChart(this._readPieChart(child, space));\r\n                    break;\r\n                case \"c:catAx\":\r\n                    space.plotArea.categoryAxis = this._readChartAxis(child, space, false);\r\n                    break;\r\n                case \"c:valAx\":\r\n                    space.plotArea.valueAxis = this._readChartAxis(child, space, true);\r\n                    break;\r\n                case \"c:spPr\":\r\n                    space.plotArea.style = this._readStyle(child);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    private static _readLegend(legendNode: Node, space: ChartSpace): void {\r\n        const legend = new ChartLegend(space);\r\n        legendNode.childNodes.forEach((child: ChildNode) => {\r\n            switch (child.nodeName) {\r\n                case \"c:spPr\":\r\n                    legend.style = this._readStyle(child);\r\n                    break;\r\n                case \"c:legendPos\":\r\n                    const posAttr = Xml.getAttribute(child, \"var\");\r\n                    if (posAttr !== undefined) {\r\n                        legend.position = this._parsePosition(posAttr);\r\n                    }\r\n                    break;\r\n                case \"c:overlay\":\r\n                    const overlay = Xml.getBooleanValueFromNode(child, \"var\");\r\n                    if (overlay !== undefined) {\r\n                        legend.overlayOnPlot = overlay;\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n        // Pie chart shows series 0 by default.\r\n        if (space.chartType === ChartType.Pie) {\r\n            legend.onlySeries = 0;\r\n        }\r\n        space.legend = legend;\r\n    }\r\n\r\n    private static _readAreaChart(lineChartNode: Node, space: ChartSpace): AreaChart {\r\n        const chart = new AreaChart(space);\r\n        lineChartNode.childNodes.forEach(child => {\r\n            if (child.nodeName === \"c:ser\") {\r\n                const series = this._readChartSeries(child);\r\n                chart.series.push(series);\r\n            }\r\n        });\r\n        return chart;\r\n    }\r\n\r\n    private static _readLineChart(lineChartNode: Node, space: ChartSpace): LineChart {\r\n        const chart = new LineChart(space);\r\n        lineChartNode.childNodes.forEach(child => {\r\n            if (child.nodeName === \"c:ser\") {\r\n                const series = this._readChartSeries(child);\r\n                chart.series.push(series);\r\n            }\r\n        });\r\n        return chart;\r\n    }\r\n\r\n    private static _readBarChart(barChartNode: Node, space: ChartSpace): BarChart {\r\n        const chart = new BarChart(space);\r\n        barChartNode.childNodes.forEach(child => {\r\n            if (child.nodeName === \"c:ser\") {\r\n                const series = this._readChartSeries(child);\r\n                chart.series.push(series);\r\n            }\r\n        });\r\n        return chart;\r\n    }\r\n\r\n    private static _readPieChart(pieChartNode: Node, space: ChartSpace): PieChart {\r\n        const chart = new PieChart(space);\r\n        pieChartNode.childNodes.forEach(child => {\r\n            if (child.nodeName === \"c:ser\") {\r\n                const series = this._readChartSeries(child);\r\n                chart.series.push(series);\r\n            }\r\n            if (child.nodeName === \"c:firstSliceAngle\") {\r\n                const angleAttr = Xml.getAttribute(child, \"val\");\r\n                if (angleAttr !== undefined) {\r\n                    chart.startAngle = parseInt(angleAttr);\r\n                }\r\n            }\r\n        });\r\n        return chart;\r\n    }\r\n\r\n    private static _readStyle(styleNode: Node): ChartStyle {\r\n        const style = new ChartStyle();\r\n        styleNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"a:noFill\":\r\n                    style.fillColor = undefined;\r\n                    break;\r\n                case \"a:solidFill\":\r\n                    style.fillColor = this._readFillColor(child);\r\n                    break;\r\n                case \"a:ln\":\r\n                    const firstChild = child.firstChild;\r\n                    if (firstChild !== null) {\r\n                        style.lineColor = this._readFillColor(firstChild);\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n        return style;\r\n    }\r\n\r\n    private static _readChartAxis(axisNode: Node, space: ChartSpace, isValueAxis: boolean): ChartAxis {\r\n        let pos: ChartAxisPosition = ChartAxisPosition.Bottom;\r\n        let style = new ChartStyle;\r\n        let majorTickMode: ChartAxisTickMode = ChartAxisTickMode.None;\r\n        let minorTickMode: ChartAxisTickMode = ChartAxisTickMode.None;\r\n        let majorGridStyle = new ChartStyle();\r\n        let minorGridStyle = new ChartStyle();\r\n        let labelAlignment: ChartAxisLabelAlignment = ChartAxisLabelAlignment.Center;\r\n        let crossMode: ChartAxisCrossMode = ChartAxisCrossMode.AutoZero;\r\n        let labelOffset = 0;\r\n        axisNode.childNodes.forEach(child => {\r\n            let valAttr: string | undefined = undefined;\r\n            switch (child.nodeName) {\r\n                case \"c:spPr\":\r\n                    style = this._readStyle(child);\r\n                    break;\r\n                case \"c:majorTickMark\":\r\n                    valAttr = Xml.getAttribute(child, \"val\");\r\n                    if (valAttr !== undefined) {\r\n                        majorTickMode = this._parseTickMode(valAttr);\r\n                    }\r\n                    break;\r\n                case \"c:minorTickMark\":\r\n                    valAttr = Xml.getAttribute(child, \"val\");\r\n                    if (valAttr !== undefined) {\r\n                        minorTickMode = this._parseTickMode(valAttr);\r\n                    }\r\n                    break;\r\n                case \"c:majorGridlines\":\r\n                    if (child.firstChild !== null) {\r\n                        majorGridStyle = this._readStyle(child.firstChild);\r\n                    }\r\n                    break;\r\n                case \"c:minorGridlines\":\r\n                    if (child.firstChild !== null) {\r\n                        minorGridStyle = this._readStyle(child.firstChild);\r\n                    }\r\n                    break;\r\n                case \"c:axPos\":\r\n                    valAttr = Xml.getAttribute(child, \"val\");\r\n                    if (valAttr !== undefined) {\r\n                        pos = this._parsePosition(valAttr);\r\n                    }\r\n                    break;\r\n                case \"c:lblAlgn\":\r\n                    valAttr = Xml.getAttribute(child, \"val\");\r\n                    if (valAttr !== undefined) {\r\n                        labelAlignment = this._parseLabelAlignment(valAttr);\r\n                    }\r\n                    break;\r\n                case \"c:lblOffset\":\r\n                    valAttr = Xml.getAttribute(child, \"val\");\r\n                    if (valAttr !== undefined) {\r\n                        labelOffset = Metrics.convertTwipsToPixels(parseInt(valAttr, 10));\r\n                    }\r\n                    break;\r\n                case \"c:crosses\":\r\n                    valAttr = Xml.getAttribute(child, \"val\");\r\n                    if (valAttr !== undefined) {\r\n                        crossMode = this._parseCrossMode(valAttr);\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n        const axis = new ChartAxis(space, style, pos, majorTickMode, minorTickMode, labelOffset, isValueAxis);\r\n        axis.labelAlignment = labelAlignment;\r\n        axis.crossMode = crossMode;\r\n        axis.majorGridStyle = majorGridStyle;\r\n        axis.minorGridStyle = minorGridStyle;\r\n        return axis;\r\n    }\r\n\r\n    private static _readChartSeries(seriesNode: Node): ChartSeries {\r\n        const series = new ChartSeries();\r\n        const catStyles: ChartStyle[] = [];\r\n        seriesNode.childNodes.forEach((child) => {\r\n            const firstChild = child.firstChild;\r\n            switch(child.nodeName) {\r\n                case \"c:tx\":\r\n                    if (firstChild !== null) {\r\n                        const names = this._readStringReference(firstChild);\r\n                        series.name = names[0];\r\n                    }        \r\n                    break;\r\n                case \"c:cat\":\r\n                    if (firstChild !== null) {\r\n                        const refName = firstChild.nodeName;\r\n                        if (refName === \"c:strRef\") {\r\n                            const stringCats = this._readStringReference(firstChild);\r\n                            stringCats.forEach(stringCat => {\r\n                                const cat = new ChartValue();\r\n                                cat.text = stringCat;\r\n                                series.categories.push(cat);\r\n                            });\r\n                        } else if (refName === \"c:numRef\") {\r\n                            const numValues = this._readNumericReference(firstChild);\r\n                            numValues.forEach(numValue => {\r\n                                const cat = new ChartValue();\r\n                                cat.numeric = numValue;\r\n                                series.categories.push(cat);\r\n                            });\r\n                        } else {\r\n                            console.log(`Don't know how to parse Chart Category from node: ${refName}`);\r\n                        }\r\n                    }\r\n                    break;\r\n                case \"c:val\":\r\n                    if (firstChild !== null) {\r\n                        const refName = firstChild.nodeName;\r\n                        if (refName === \"c:strRef\") {\r\n                            const stringValues = this._readStringReference(firstChild);\r\n                            stringValues.forEach(stringValue => {\r\n                                const val = new ChartValue();\r\n                                val.text = stringValue;\r\n                                series.values.push(val);\r\n                            });\r\n                        } else if (refName === \"c:numRef\") {\r\n                            const numValues = this._readNumericReference(firstChild);\r\n                            numValues.forEach(numValue => {\r\n                                const val = new ChartValue();\r\n                                val.numeric = numValue;\r\n                                series.values.push(val);\r\n                            });\r\n                        } else {\r\n                            console.log(`Don't know how to parse Chart Value from node: ${refName}`);\r\n                        }\r\n                    }\r\n                    break;\r\n                case \"c:spPr\":\r\n                    series.style = this._readStyle(child);\r\n                    break;\r\n                case \"c:dPt\":\r\n                    const index = Xml.getNumberValueFromNode(child, \"c:idx\");\r\n                    const styleNode = Xml.getFirstChildOfName(child, \"c:spPr\");\r\n                    if (index !== undefined && styleNode !== undefined) {\r\n                        catStyles[index] = this._readStyle(styleNode);\r\n                    }\r\n                    break;\r\n                case \"c:idx\":\r\n                case \"c:order\":\r\n                case \"c:invertIfNegative\":\r\n                case \"c:dLbls\":\r\n                case \"c:marker\":\r\n                case \"c:smooth\":\r\n                case \"c:explosion\":\r\n                    // Ignore\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Chart Series reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        catStyles.forEach((style: ChartStyle, i: number) => {\r\n            series.categories[i].style = style;\r\n        });\r\n        return series;\r\n    }\r\n\r\n    private static _readStringReference(strRefNode: Node): string[] {\r\n        const ref: string[] = [];\r\n        const strCacheNode = Xml.getFirstChildOfName(strRefNode, \"c:strCache\");\r\n        if (strCacheNode !== undefined) {\r\n            strCacheNode.childNodes.forEach(node => {\r\n                if (node.nodeName === \"c:pt\") {\r\n                    const index = Xml.getAttribute(node, \"idx\");\r\n                    const valueNode = Xml.getFirstChildOfName(node, \"c:v\");\r\n                    if (index !== undefined && valueNode !== undefined && valueNode.textContent !== null) {\r\n                        ref[parseInt(index, 10)] = valueNode.textContent;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return ref;\r\n        \r\n    }\r\n\r\n    private static _readNumericReference(numRefNode: Node): number[] {\r\n        const ref: number[] = [];\r\n        const numCacheNode = Xml.getFirstChildOfName(numRefNode, \"c:numCache\");\r\n        if (numCacheNode !== undefined) {\r\n            numCacheNode.childNodes.forEach(node => {\r\n                if (node.nodeName === \"c:pt\") {\r\n                    const index = Xml.getAttribute(node, \"idx\");\r\n                    const valueNode = Xml.getFirstChildOfName(node, \"c:v\");\r\n                    if (index !== undefined && valueNode !== undefined && valueNode.textContent !== null) {\r\n                        ref[parseInt(index, 10)] = parseFloat(valueNode.textContent);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        return ref;\r\n    }\r\n\r\n    private static _readFillColor(fillNode: Node): string | undefined {\r\n        let color: string | undefined = undefined;\r\n        const colorNode = fillNode.firstChild;\r\n        if (colorNode !== null && colorNode.nodeName === \"a:srgbClr\") {\r\n            const valAttr = Xml.getAttribute(colorNode, \"val\");\r\n            if (valAttr !== undefined) {\r\n                color = valAttr;\r\n            }\r\n        }\r\n        return color;\r\n    }\r\n\r\n    private static _parseTickMode(tickAttr: string): ChartAxisTickMode {\r\n        let tickMode = ChartAxisTickMode.None;\r\n        if (tickAttr === \"out\") {\r\n            tickMode = ChartAxisTickMode.Outwards\r\n        }\r\n        return tickMode;\r\n    }\r\n\r\n    private static _parsePosition(posAttr: string): ChartAxisPosition {\r\n        let posMode = ChartAxisPosition.Bottom;\r\n        switch(posAttr) {\r\n            case \"t\":\r\n                posMode = ChartAxisPosition.Top;\r\n                break;\r\n            case \"b\":\r\n                posMode = ChartAxisPosition.Bottom;\r\n                break;\r\n            case \"l\":\r\n                posMode = ChartAxisPosition.Left;\r\n                break;\r\n            case \"r\":\r\n                posMode = ChartAxisPosition.Right;\r\n                break;\r\n        }\r\n        return posMode;\r\n    }\r\n\r\n    private static _parseLabelAlignment(_alignAttr: string): ChartAxisLabelAlignment {\r\n        return ChartAxisLabelAlignment.Center;\r\n    }\r\n\r\n    private static _parseCrossMode(_crossAttr: string): ChartAxisCrossMode {\r\n        return ChartAxisCrossMode.AutoZero;\r\n    }\r\n}","import { TextRun } from \"../text/text-run\";\r\nimport { NumberingStyle } from \"./num-style\";\r\nimport { Style } from \"../text/style\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\n\r\nexport class NumberingRun extends TextRun {\r\n    private _style: NumberingStyle;\r\n\r\n    constructor(style: NumberingStyle) {\r\n        super([\"\"], style.style || new Style());\r\n        this._style = style;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow): void {\r\n        const indices = this._getIndices(flow);\r\n        super.texts = [this._style.getPrefixText(indices)];\r\n        this._advanceIndex(flow);\r\n        super.performLayout(flow);\r\n    }\r\n\r\n    private _getIndices(flow: VirtualFlow): number[] {\r\n        const indices: number[] = [];\r\n        const numId = this._style.numId;\r\n        const level = this._style.level;\r\n        if (level !== undefined) {\r\n            const maxIndex = level.index;\r\n            for(let i = 0; i <= maxIndex; i++) {\r\n                indices.push(flow.getNumbering(numId, i));\r\n            }\r\n        } else {\r\n            indices.push(0);\r\n        }\r\n        return indices;\r\n    }\r\n\r\n    private _advanceIndex(flow: VirtualFlow): void {\r\n        const numId = this._style.numId;\r\n        const level = this._style.level;\r\n        let levelIndex = 0;\r\n        if (level !== undefined) {\r\n            levelIndex = level.index;\r\n        }\r\n        flow.advanceNumbering(numId, levelIndex);\r\n    }\r\n}","import { MathObjectList } from \"./math-object\";\r\n\r\nexport class Equation {\r\n    public objects: MathObjectList;\r\n\r\n    constructor(objects: MathObjectList) {\r\n        this.objects = objects;\r\n    }\r\n}","\r\nexport class NAryStyle {\r\n    public char: string = \"\";\r\n    public hideSub: boolean = false;\r\n    public hideSuper: boolean = false;\r\n}","import { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { Size } from \"../utils/geometry/size\";\r\n\r\nexport abstract class MathObject {\r\n\r\n    public abstract getSize(): Size;\r\n\r\n    public abstract performLayout(flow: VirtualFlow, xPadding: number): number;\r\n\r\n    public abstract render(painter: IPainter): void;\r\n}\r\n\r\nexport class MathObjectList extends MathObject {\r\n    private _list: MathObject[] = [];\r\n\r\n    public add(obj: MathObject): void {\r\n        this._list.push(obj);\r\n    } \r\n\r\n    public unshift(obj: MathObject): void {\r\n        this._list.unshift(obj);\r\n    }\r\n\r\n    public get(index: number): MathObject {\r\n        return this._list[index];\r\n    }\r\n\r\n    public get length(): number {\r\n        return this._list.length;\r\n    }\r\n\r\n    public forEach(func: (obj: MathObject) => any): any {\r\n        return this._list.forEach(func);\r\n    }\r\n\r\n    public getSize(): Size {\r\n        let size = new Size(0, 0);\r\n        this._list.forEach(obj => {\r\n            size = size.addHorizontal(obj.getSize());\r\n        });\r\n        return size;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow, xPadding: number): number {\r\n        let padding = xPadding;\r\n        this._list.forEach(obj => padding = obj.performLayout(flow, padding));\r\n        return padding;\r\n    }\r\n    \r\n    public render(painter: IPainter): void {\r\n        this._list.forEach(obj => obj.render(painter));\r\n    }\r\n}\r\n","import { MathObject } from \"./math-object\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { Size } from \"../utils/geometry/size\";\r\nimport { Point } from \"../utils/geometry/point\";\r\nimport { Style } from \"../text/style\";\r\nimport { FontMetrics } from \"../utils/font-metrics\";\r\nimport { Justification } from \"../paragraph/par-style\";\r\n\r\nexport class CharacterObject extends MathObject {\r\n    private _char: string;\r\n    private _style: Style;\r\n    private _pos: Point | undefined;\r\n\r\n    constructor(char: string, style: Style) {\r\n        super();\r\n        this._char = char;\r\n        this._style = style;\r\n    }\r\n\r\n    public getSize(): Size {\r\n        const height = this._style.lineSpacing;\r\n        return new Size(this._getWidth(), height);\r\n    }\r\n    \r\n    public performLayout(flow: VirtualFlow, xPadding: number): number {\r\n        this._pos = new Point(flow.getX() + xPadding, flow.getY());\r\n        return xPadding + this._getWidth();\r\n    }\r\n    \r\n    public render(painter: IPainter): void {\r\n        if (this._pos !== undefined) {\r\n            painter.paintText(this._pos.x, this._pos.y, 100, false, this._char, this._style.color, Justification.left, this._style.fontFamily, this._style.fontSize, this._style.bold, this._style.italic);\r\n        }\r\n    }\r\n\r\n    private _getWidth(): number {\r\n        return FontMetrics.averageCharWidth(this._style) * this._char.length;\r\n    }\r\n}","import { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { MathObject } from \"./math-object\";\r\nimport { NAryStyle } from \"./n-ary-style\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { Size } from \"../utils/geometry/size\";\r\nimport { CharacterObject } from \"./character-object\";\r\nimport { Style } from \"../text/style\";\r\n\r\nexport class NAryObject extends MathObject {\r\n    private _sub: MathObject | undefined;\r\n    private _super: MathObject | undefined;\r\n    private _elem: MathObject | undefined;\r\n    private _char: MathObject;\r\n    private _style: NAryStyle;\r\n\r\n    constructor(sub: MathObject | undefined, sup: MathObject | undefined, elem: MathObject | undefined, style: NAryStyle) {\r\n        super();\r\n        this._sub = sub;\r\n        this._super = sup;\r\n        this._elem = elem;\r\n        this._char = new CharacterObject(style.char, new Style());\r\n        this._style = style;\r\n    }\r\n\r\n    public getSize(): Size {\r\n        let elemSize = (this._elem !== undefined)  ? this._elem.getSize() : new Size(0, 0);\r\n        let superSize = (this._super !== undefined)  ? this._super.getSize() : new Size(0, 0);\r\n        let subSize = (this._sub !== undefined)  ? this._sub.getSize() : new Size(0, 0);\r\n        const size = superSize.addVertical(elemSize).addVertical(subSize);\r\n        return size;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow, xPadding: number): number {\r\n        if (this._sub !== undefined && !this._style.hideSub) {\r\n            this._sub.performLayout(flow, xPadding);\r\n        }\r\n        if (this._super !== undefined && !this._style.hideSuper) {\r\n            this._super.performLayout(flow, xPadding);\r\n        }\r\n        let padding = xPadding;\r\n        padding = this._char.performLayout(flow, padding) || padding;\r\n        padding = this._elem?.performLayout(flow, padding) || padding;\r\n        return padding;\r\n    }\r\n    \r\n    public render(painter: IPainter): void {\r\n        if (this._sub !== undefined && !this._style.hideSub) {\r\n            this._sub.render(painter);\r\n        }\r\n        if (this._super !== undefined && !this._style.hideSuper) {\r\n            this._super.render(painter);\r\n        }\r\n        this._char.render(painter);\r\n        this._elem?.render(painter);\r\n    }\r\n}\r\n","import { MathObject } from \"./math-object\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { DelimiterStyle } from \"./delimiter-style\";\r\nimport { Size } from \"../utils/geometry/size\";\r\nimport { CharacterObject } from \"./character-object\";\r\nimport { Style } from \"../text/style\";\r\n\r\nexport class DelimiterObject extends MathObject {\r\n    private _begin: MathObject | undefined;\r\n    private _end: MathObject | undefined;\r\n    private _elem: MathObject | undefined;\r\n\r\n    constructor(elem: MathObject | undefined, delimiterStyle: DelimiterStyle, style: Style) {\r\n        super();\r\n        this._elem = elem;\r\n        this._begin = new CharacterObject(delimiterStyle.beginChar, style);\r\n        this._end = new CharacterObject(delimiterStyle.endChar, style);\r\n    }\r\n\r\n    public getSize(): Size {\r\n        let size = this._elem?.getSize() || new Size(0, 0);\r\n        size.addHorizontal(this._begin?.getSize() || new Size(0, 0));\r\n        size.addHorizontal(this._end?.getSize() || new Size(0, 0));\r\n        return size;\r\n    }\r\n    \r\n    public performLayout(flow: VirtualFlow, xPadding: number): number {\r\n        let padding = xPadding;\r\n        padding = this._begin?.performLayout(flow, padding) || padding;\r\n        padding = this._elem?.performLayout(flow, padding) || padding;\r\n        padding = this._end?.performLayout(flow, padding) || padding;\r\n        return padding;\r\n    }\r\n    \r\n    public render(painter: IPainter): void {\r\n        this._begin?.render(painter);\r\n        this._elem?.render(painter);\r\n        this._end?.render(painter);\r\n    }\r\n}\r\n","import { MathObject } from \"./math-object\";\r\nimport { TextRun } from \"../text/text-run\";\r\nimport { RunStyle } from \"../text/run-style\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { Style } from \"../text/style\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { TextRenderer } from \"../text/text-renderer\";\r\nimport { Size } from \"../utils/geometry/size\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\n\r\nexport class RunObject extends MathObject {\r\n    private _run: TextRun;\r\n\r\n    constructor(text: string, style: RunStyle) {\r\n        super();\r\n        this._run = new TextRun([text], new Style(undefined, style));\r\n        this._run.inParagraph = InSequence.Middle;\r\n    }\r\n\r\n    public getSize(): Size {\r\n        return this._run.getSize();\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow, xPadding: number): number {\r\n        this._run.previousXPos = (xPadding !== 0) ? xPadding : undefined;\r\n        this._run.performLayout(flow);\r\n        return this._run.lastXPos;\r\n    }\r\n    \r\n    public render(painter: IPainter): void {\r\n        const renderer = new TextRenderer(painter);\r\n        renderer.renderTextRun(this._run);\r\n    }\r\n}\r\n","\r\nexport class DelimiterStyle {\r\n    public beginChar: string = \"\";\r\n    public endChar: string = \"\";\r\n}","import { MathObject } from \"./math-object\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { FractionStyle } from \"./fraction-style\";\r\nimport { Size } from \"../utils/geometry/size\";\r\n\r\nexport class FractionObject extends MathObject {\r\n    private _numerator: MathObject | undefined;\r\n    private _denumerator: MathObject | undefined;\r\n    public style: FractionStyle;\r\n\r\n    constructor(numerator: MathObject | undefined, denumerator: MathObject | undefined, style: FractionStyle) {\r\n        super();\r\n        this._numerator = numerator;\r\n        this._denumerator = denumerator;\r\n        this.style = style;\r\n    }\r\n\r\n    public getSize(): Size {\r\n        let denominatorSize: Size;\r\n        if (this._denumerator !== undefined) {\r\n            denominatorSize = this._denumerator.getSize();\r\n        } else {\r\n            denominatorSize = new Size(0, 0);\r\n        }\r\n        let numeratorSize: Size;\r\n        if (this._numerator !== undefined) {\r\n            numeratorSize = this._numerator.getSize();\r\n        } else {\r\n            numeratorSize = new Size(0, 0);\r\n        }\r\n        return denominatorSize.addVertical(numeratorSize, 20);\r\n    }\r\n    \r\n    public performLayout(flow: VirtualFlow, xPadding: number): number {\r\n        const numPadding = this._numerator?.performLayout(flow, xPadding) || xPadding;\r\n        const denPadding = this._denumerator?.performLayout(flow, xPadding) || xPadding;\r\n        return Math.max(numPadding, denPadding);\r\n    }\r\n    \r\n    public render(painter: IPainter): void {\r\n        this._numerator?.render(painter);\r\n        this._denumerator?.render(painter);\r\n    }   \r\n}","import { MathObject, MathObjectList } from \"./math-object\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { MatrixStyle } from \"./matrix-style\";\r\nimport { Size } from \"../utils/geometry/size\";\r\n\r\nexport class MatrixObject extends MathObject {\r\n    public rows: MathObjectList;\r\n    public style: MatrixStyle;\r\n\r\n    constructor(rows: MathObjectList, style: MatrixStyle) {\r\n        super();\r\n        this.rows = rows;\r\n        this.style = style;\r\n    }\r\n\r\n    public getSize(): Size {\r\n        const rowSize = this.rows.get(0).getSize().clone();\r\n        rowSize.height = (rowSize.height + 20) * this.rows.length - 20;\r\n        return rowSize;\r\n    }\r\n\r\n    public performLayout(_flow: VirtualFlow, _xPadding: number): number {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    \r\n    public render(_painter: IPainter): void {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}","\r\nexport class FunctionStyle {\r\n}","import { MathObject } from \"./math-object\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { FunctionStyle } from \"./function-style\";\r\nimport { Size } from \"../utils/geometry/size\";\r\n\r\nexport class FunctionObject extends MathObject {\r\n    private _functionName: MathObject | undefined;\r\n    private _elem: MathObject | undefined;\r\n    public style: FunctionStyle;\r\n\r\n    constructor(functionName: MathObject | undefined, elem: MathObject | undefined, style: FunctionStyle) {\r\n        super();\r\n        this._functionName = functionName;\r\n        this._elem = elem;\r\n        this.style = style;\r\n    }\r\n\r\n    public getSize(): Size {\r\n        let elemSize: Size;\r\n        if (this._elem !== undefined) {\r\n            elemSize = this._elem.getSize();\r\n        } else {\r\n            elemSize = new Size(0, 0);\r\n        }\r\n        let nameSize: Size;\r\n        if (this._functionName !== undefined) {\r\n            nameSize = this._functionName.getSize();\r\n        } else {\r\n            nameSize = new Size(0, 0);\r\n        }\r\n        const size = nameSize.addVertical(elemSize);\r\n        return size;\r\n    }\r\n    \r\n    public performLayout(flow: VirtualFlow, xPadding: number): number {\r\n        let padding = this._functionName?.performLayout(flow, xPadding) || xPadding;\r\n        return this._elem?.performLayout(flow, padding) || padding;\r\n    }\r\n    \r\n    public render(painter: IPainter): void {\r\n        this._functionName?.render(painter);\r\n        this._elem?.render(painter);\r\n    }   \r\n}","\r\nexport class RadicalStyle {\r\n    public hideDegree: boolean = false;\r\n}","import { MathObject } from \"./math-object\";\r\nimport { VirtualFlow } from \"../utils/virtual-flow\";\r\nimport { IPainter } from \"../painting/i-painter\";\r\nimport { RadicalStyle } from \"./radical-style\";\r\nimport { Size } from \"../utils/geometry/size\";\r\nimport { CharacterObject } from \"./character-object\";\r\nimport { Style } from \"../text/style\";\r\n\r\nexport class RadicalObject extends MathObject {\r\n    private _degree: MathObject | undefined;\r\n    private _elem: MathObject | undefined;\r\n    private _radical: MathObject;\r\n    public style: RadicalStyle;\r\n\r\n    constructor(degree: MathObject | undefined, elem: MathObject | undefined, style: RadicalStyle) {\r\n        super();\r\n        this._degree = degree;\r\n        this._elem = elem;\r\n        this._radical = new CharacterObject(\"U0x221A\", new Style());\r\n        this.style = style;\r\n    }\r\n\r\n    public getSize(): Size {\r\n        let elemSize : Size;\r\n        if (this._elem !== undefined) {\r\n            elemSize = this._elem.getSize();\r\n        } else {\r\n            elemSize = new Size(0, 0);\r\n        }\r\n        elemSize.width += 20;\r\n        elemSize.height += 20;\r\n        return elemSize;\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow, xPadding: number): number {\r\n        let padding = xPadding;\r\n        padding = this._degree?.performLayout(flow, padding) || padding;\r\n        padding = this._radical?.performLayout(flow, padding) || padding;\r\n        padding = this._elem?.performLayout(flow, padding) || padding;\r\n        return padding;\r\n    }\r\n    \r\n    public render(painter: IPainter): void {\r\n        this._degree?.render(painter);\r\n        this._radical?.render(painter);\r\n        this._elem?.render(painter);\r\n    }   \r\n}","import { MatrixColumnXAlign } from \"./matrix-style\";\r\n\r\nexport class MatrixColumnStyle {\r\n    public count: number = 0;\r\n    public justification: MatrixColumnXAlign = MatrixColumnXAlign.Center;\r\n\r\n    public setJustification(jcStr: string | undefined): void {\r\n        switch (jcStr) {\r\n            case \"left\":\r\n                this.justification = MatrixColumnXAlign.Left;\r\n                break;\r\n            case \"right\":\r\n                this.justification = MatrixColumnXAlign.Right;\r\n                break;\r\n            case \"inside\":\r\n                this.justification = MatrixColumnXAlign.Inside;\r\n                break;\r\n            case \"outside\":\r\n                this.justification = MatrixColumnXAlign.Outside;\r\n                break;\r\n            case \"center\":\r\n            default:\r\n                this.justification = MatrixColumnXAlign.Center;\r\n                break;\r\n        }\r\n    }\r\n}\r\n","import { Xml } from \"../utils/xml\";\r\nimport { Paragraph, IRun } from \"./paragraph\";\r\nimport { TextRun } from \"../text/text-run\";\r\nimport { TextReader } from \"../text/text-reader\";\r\nimport { DocumentX } from \"../document-x\";\r\nimport { ParStyle } from \"./par-style\";\r\nimport { DrawingReader } from \"../drawing/drawing-reader\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\nimport { NumberingRun } from \"../numbering/numbering-run\";\r\nimport { MathReader } from \"../math/math-reader\";\r\n\r\nexport class ParagraphReader {\r\n    public static readStructuredDocumentTag(docx: DocumentX, sdtNode: Node): Paragraph[] {\r\n        const pars: Paragraph[] = [];\r\n        const contentNode = Xml.getFirstChildOfName(sdtNode, \"w:sdtContent\");\r\n        if (contentNode !== undefined) {\r\n            contentNode.childNodes.forEach(child => {\r\n                switch (child.nodeName) {\r\n                    case \"w:p\":\r\n                        pars.push(ParagraphReader.readParagraph(docx, child));\r\n                        break;\r\n                    default:\r\n                        // Ignore\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n        return pars;\r\n    }\r\n\r\n    public static readParagraph(docx: DocumentX, pNode: Node): Paragraph {\r\n        let numberingRun: NumberingRun | undefined;\r\n        let linkTarget: string | undefined = undefined;\r\n        const runs: IRun[] = [];\r\n        const parStyle = this.readStyle(docx, pNode);\r\n        if (parStyle !== undefined && parStyle.numStyle !== undefined) {\r\n            numberingRun = new NumberingRun(parStyle.numStyle);\r\n        }\r\n        const textStyle = parStyle.clone();\r\n        textStyle.numStyle = undefined;\r\n        pNode.childNodes.forEach(node => {\r\n            linkTarget = undefined;\r\n            if (node.nodeName === \"w:hyperlink\") {\r\n                const linkId = Xml.getAttribute(node, \"r:id\");\r\n                if (linkId !== undefined) {\r\n                    linkTarget = docx.relationships!.getTarget(linkId);\r\n                }\r\n                const firstChild = node.firstChild;\r\n                if (firstChild !== null) {\r\n                    node = firstChild;\r\n                }\r\n            }\r\n            if (node.nodeName === \"w:r\") {\r\n                node.childNodes.forEach(child => {\r\n                    if (child.nodeName === \"w:drawing\") {\r\n                        const drawing = DrawingReader.readDrawingRun(child, docx);\r\n                        runs.push(drawing);    \r\n                    }\r\n                    if (child.nodeName === \"mc:AlternateContent\") {\r\n                        const choiceNode = Xml.getFirstChildOfName(child, \"mc:Choice\");\r\n                        if (choiceNode !== undefined) {\r\n                            const chosenNode = Xml.getFirstChildOfName(choiceNode, \"w:drawing\");\r\n                            if (chosenNode !== undefined) {\r\n                                runs.push(DrawingReader.readDrawingRun(chosenNode, docx));\r\n                            }\r\n                        }                                    \r\n                    }\r\n                });\r\n                // Try to load text.\r\n                const run = TextReader.readTextRun(node, textStyle, docx.styles);\r\n                run.inParagraph = InSequence.Middle;\r\n                run.linkTarget = linkTarget;\r\n                runs.push(run);\r\n            }\r\n            if (node.nodeName === \"m:oMath\") {\r\n                const mathRun = MathReader.fromMathNode(node);\r\n                runs.push(mathRun);\r\n            }\r\n        });\r\n        const firstRun = numberingRun || runs[0];\r\n        if (runs.length == 1 && firstRun instanceof TextRun) {\r\n            firstRun.inParagraph = InSequence.Only;\r\n        } else if (runs.length > 0) {\r\n            if (firstRun instanceof TextRun) {\r\n                firstRun.inParagraph = InSequence.First;\r\n            }\r\n            const lastRun = runs[runs.length - 1];\r\n            if (lastRun instanceof TextRun) {\r\n                lastRun.inParagraph = InSequence.Last;\r\n            }\r\n        }\r\n        return new Paragraph(runs, numberingRun);\r\n    }\r\n\r\n    private static readStyle(docx: DocumentX, pNode: Node): ParStyle {\r\n        const parPrNode = Xml.getFirstChildOfName(pNode, \"w:pPr\");\r\n        if (parPrNode !== undefined) {\r\n            const parStyle = ParStyle.fromParPresentationNode(parPrNode);\r\n            parStyle.applyNamedStyles(docx.styles);\r\n            parStyle.applyNumberings(docx.numberings);\r\n            return parStyle;\r\n        }\r\n        return new ParStyle();\r\n    }\r\n}","import { Equation } from \"./equation\";\r\nimport { MathRun } from \"./math-run\";\r\nimport { RunStyle } from \"../text/run-style\";\r\nimport { NAryStyle } from \"./n-ary-style\";\r\nimport { MathObject, MathObjectList } from \"./math-object\";\r\nimport { NAryObject } from \"./n-ary-object\";\r\nimport { DelimiterObject } from \"./delimiter-object\";\r\nimport { RunObject } from \"./run-object\";\r\nimport { DelimiterStyle } from \"./delimiter-style\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { FractionObject } from \"./fraction-object\";\r\nimport { FractionStyle } from \"./fraction-style\";\r\nimport { MatrixStyle, MatrixSpacingRule } from \"./matrix-style\";\r\nimport { MatrixObject } from \"./matrix-object\";\r\nimport { FunctionStyle } from \"./function-style\";\r\nimport { FunctionObject } from \"./function-object\";\r\nimport { RadicalStyle } from \"./radical-style\";\r\nimport { RadicalObject } from \"./radical-object\";\r\nimport { MatrixColumnStyle } from \"./matrix-column-style\";\r\nimport { Style } from \"../text/style\";\r\n\r\nexport class MathReader {\r\n\r\n    public static fromMathNode(mathNode: Node): MathRun {\r\n        const equation = new Equation(this._readMathElement(mathNode));\r\n        return new MathRun(equation);\r\n    }\r\n\r\n    private static _readNAryObject(naryNode: Node): NAryObject {\r\n        let style: NAryStyle = new NAryStyle();\r\n        let sub: MathObject | undefined = undefined;\r\n        let sup: MathObject | undefined = undefined;\r\n        let elem: MathObject | undefined = undefined;\r\n        let grandChild: Node | null = null;\r\n        naryNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:naryPr\":\r\n                    style = this._readNAryStyle(child);\r\n                    break;\r\n                case \"m:sub\":\r\n                    grandChild = child.firstChild;\r\n                    if (grandChild !== null) {\r\n                        sub = this._readMathElement(grandChild);\r\n                    }\r\n                    break;\r\n                case \"m:sup\":\r\n                    grandChild = child.firstChild;\r\n                    if (grandChild !== null) {\r\n                        sup = this._readMathElement(grandChild);\r\n                    }\r\n                    break;\r\n                case \"m:e\":\r\n                    elem = this._readMathElement(child);\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during N-Ary Object reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return new NAryObject(sub, sup, elem, style);\r\n    }\r\n\r\n    private static _readNAryStyle(presentationNode: Node): NAryStyle {\r\n        const style = new NAryStyle();\r\n        presentationNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:chr\":\r\n                    style.char = Xml.getStringValue(child) || \"\";\r\n                    break;\r\n                case \"m:subHide\":\r\n                    style.hideSub = Xml.getBooleanValue(child) || false;\r\n                    break;\r\n                case \"m:supHide\":\r\n                    style.hideSuper = Xml.getBooleanValue(child) || false;\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during N-Ary Style reading.`);\r\n                    break;\r\n            }\r\n        })\r\n        return style;\r\n    }\r\n\r\n    private static _readDelimiterObject(delNode: Node): DelimiterObject {\r\n        let style: DelimiterStyle = new DelimiterStyle();\r\n        let elem: MathObject | undefined = undefined;\r\n        delNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:dPr\":\r\n                    style = this._readDelimiterStyle(child);\r\n                    break;\r\n                case \"m:e\":\r\n                    elem = this._readMathElement(child);\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Delimiter reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return new DelimiterObject(elem, style, new Style());\r\n    }\r\n\r\n    private static _readDelimiterStyle(presentationNode: Node): DelimiterStyle {\r\n        const style = new DelimiterStyle();\r\n        presentationNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:begChr\":\r\n                    style.beginChar = Xml.getStringValue(child) || \"\";\r\n                    break;\r\n                case \"m:endChr\":\r\n                    style.endChar = Xml.getStringValue(child) || \"\";\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Delimiter style reading.`);\r\n                    break;\r\n            }\r\n        })\r\n        return style;\r\n    }\r\n\r\n    private static _readFractionObject(fracNode: Node): FractionObject {\r\n        let style: FractionStyle = new FractionStyle();\r\n        let numerator: MathObject | undefined = undefined;\r\n        let denumerator: MathObject | undefined = undefined;\r\n        fracNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:fPr\":\r\n                    style = this._readFractionStyle(child);\r\n                    break;\r\n                case \"m:num\":\r\n                    numerator = this._readMathElement(child);\r\n                    break;\r\n                case \"m:den\":\r\n                    denumerator = this._readMathElement(child);\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Fraction reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return new FractionObject(numerator, denumerator, style);\r\n    }\r\n\r\n    private static _readFractionStyle(presentationNode: Node): FractionStyle {\r\n        const style = new FractionStyle();\r\n        presentationNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:type\":\r\n                    style.setType(Xml.getStringValue(child));\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Delimiter style reading.`);\r\n                    break;\r\n            }\r\n        })\r\n        return style;\r\n    }\r\n\r\n    private static _readFunctionObject(fracNode: Node): FunctionObject {\r\n        let style = new FunctionStyle();\r\n        let functionName: MathObject | undefined = undefined;\r\n        let elem: MathObject | undefined = undefined;\r\n        fracNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:funcPr\":\r\n                    style = this._readFunctionStyle(child);\r\n                    break;\r\n                case \"m:fName\":\r\n                    functionName = this._readMathElement(child);\r\n                    break;\r\n                case \"m:e\":\r\n                    elem = this._readMathElement(child);\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Fraction reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return new FunctionObject(functionName, elem, style);\r\n    }\r\n\r\n    private static _readFunctionStyle(presentationNode: Node): FunctionStyle {\r\n        const style = new FunctionStyle();\r\n        presentationNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:ctrlPr\":\r\n                    // Ignore for now.\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Delimiter style reading.`);\r\n                    break;\r\n            }\r\n        })\r\n        return style;\r\n    }\r\n\r\n    private static _readMatrixObject(matrixNode: Node): MatrixObject {\r\n        let style = new MatrixStyle();\r\n        let rows = new MathObjectList();\r\n        matrixNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:mPr\":\r\n                    style = this._readMatrixStyle(child);\r\n                    break;\r\n                case \"m:mr\":\r\n                    const row = new MathObjectList();\r\n                    child.childNodes.forEach(grandChild => \r\n                        row.add(this._readMathElement(grandChild))\r\n                    );\r\n                    rows.add(row);\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Fraction reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return new MatrixObject(rows, style);\r\n    }\r\n\r\n    private static _readMatrixStyle(presentationNode: Node): MatrixStyle {\r\n        const style = new MatrixStyle();\r\n        presentationNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:baseJc\":\r\n                    style.setJustification(Xml.getStringValue(child));\r\n                    break;\r\n                case \"m:plcHide\":\r\n                    style.hidePlaceholder = Xml.getBooleanValue(child) || false;\r\n                    break;\r\n                case \"m:rSp\":\r\n                    style.rowSpacing = Xml.getNumberValue(child) || 1;\r\n                    break;\r\n                case \"m:rSpRule\":\r\n                    style.rowSpacingRule = this._readMatrixSpacingRule(child);\r\n                    break;\r\n                case \"m:cSp\":\r\n                    style.columnMinimalWidth = Xml.getNumberValue(child) || 0;\r\n                    break;\r\n                case \"m:cGp\":\r\n                    style.columnGap = Xml.getNumberValue(child) || 1;\r\n                    break;\r\n                case \"m:cGpRule\":\r\n                    style.columnGapRule = this._readMatrixSpacingRule(child);\r\n                    break;\r\n                case \"m:mcs\":\r\n                    style.columnStyles = this._readMatrixColumnStyleList(child);\r\n                    break;\r\n                case \"m:ctrlPr\":\r\n                    // Ignore for now.\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Delimiter style reading.`);\r\n                    break;\r\n            }\r\n        })\r\n        return style;\r\n    }\r\n\r\n    private static _readMatrixSpacingRule(_ruleNode: Node): MatrixSpacingRule {\r\n        return MatrixSpacingRule.Single;\r\n    }\r\n\r\n    private static _readMatrixColumnStyleList(columnsNode: Node): MatrixColumnStyle[] {\r\n        const columns: MatrixColumnStyle[] = [];\r\n        columnsNode.childNodes.forEach(child => {\r\n            if (child.nodeName === \"m:mc\") {\r\n                columns.push(this._readMatrixColumnStyle(child));\r\n            }\r\n        });\r\n        return columns;\r\n    }\r\n\r\n    private static _readMatrixColumnStyle(columnNode: Node): MatrixColumnStyle {\r\n        const style = new MatrixColumnStyle();\r\n        columnNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:count\":\r\n                    style.count = Xml.getNumberValue(child) || 0;\r\n                    break;\r\n                case \"m:mcJc\":\r\n                    style.setJustification(Xml.getStringValue(child));\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Matrix Column Style reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return style;\r\n    }\r\n\r\n    private static _readRadicalObject(delNode: Node): RadicalObject {\r\n        let style = new RadicalStyle();\r\n        let degree: MathObject | undefined = undefined;\r\n        let elem: MathObject | undefined = undefined;\r\n        delNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:radPr\":\r\n                    style = this._readRadicalStyle(child);\r\n                    break;\r\n                case \"m:deg\":\r\n                    degree = this._readMathElement(child);\r\n                    break;\r\n                case \"m:e\":\r\n                    elem = this._readMathElement(child);\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Radical reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return new RadicalObject(degree, elem, style);\r\n    }\r\n\r\n    private static _readRadicalStyle(presentationNode: Node): RadicalStyle {\r\n        const style = new RadicalStyle();\r\n        presentationNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:degHide\":\r\n                    style.hideDegree = Xml.getBooleanValue(child) || false;\r\n                    break;\r\n                case \"m:ctrlPr\":\r\n                    // Ignore for now.\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Delimiter style reading.`);\r\n                    break;\r\n            }\r\n        })\r\n        return style;\r\n    }\r\n\r\n    private static _readRunObject(runNode: Node): RunObject {\r\n        let style: RunStyle | undefined = undefined;\r\n        let text: string = \"\";\r\n        runNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:t\":\r\n                    text = child.textContent || \"\";\r\n                    break;\r\n                case \"w:rPr\":\r\n                    style = RunStyle.fromPresentationNode(child);\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Math Run reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return new RunObject(text, style || new RunStyle());\r\n    }\r\n\r\n    private static _readMathElement(node: Node): MathObjectList {\r\n        const objects = new MathObjectList();\r\n        node.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"m:e\":\r\n                    objects.add(this._readMathElement(child));\r\n                    break;\r\n                case \"m:nary\":\r\n                    objects.add(this._readNAryObject(child));\r\n                    break;\r\n                case \"m:d\":\r\n                    objects.add(this._readDelimiterObject(child));\r\n                    break;\r\n                case \"m:r\":\r\n                    objects.add(this._readRunObject(child));\r\n                    break;\r\n                case \"m:f\":\r\n                    objects.add(this._readFractionObject(child));\r\n                    break;\r\n                case \"m:m\":\r\n                    objects.add(this._readMatrixObject(child));\r\n                    break;\r\n                case \"m:func\":\r\n                    objects.add(this._readFunctionObject(child));\r\n                    break;\r\n                case \"m:rad\":\r\n                    objects.add(this._readRadicalObject(child));\r\n                    break;\r\n                case \"m:acc\":\r\n                case \"m:bar\":\r\n                case \"m:box\":\r\n                case \"m:borderBox\":\r\n                case \"m:eqArr\":\r\n                case \"m:groupChr\":\r\n                case \"m:limLow\":\r\n                case \"m:limUpp\":\r\n                case \"m:phant\":\r\n                case \"m:sPre\":\r\n                case \"m:sSub\":\r\n                case \"m:sSubSup\":\r\n                case \"m:sSup\":\r\n                    console.log(`Math Object ${child.nodeName} not implemented yet`);\r\n                    break;\r\n                default:\r\n                    console.log(`Unknown node ${child.nodeName} encountered during reading of Math Objects`);\r\n                    break;\r\n            }\r\n        });\r\n        return objects;\r\n    }\r\n}","import { XmlPart } from \"./package/xml-part\";\r\nimport { Xml } from \"./utils/xml\";\r\nimport { Paragraph } from \"./paragraph/paragraph\";\r\nimport { NamedStyles } from \"./text/named-styles\";\r\nimport { Section } from \"./section\";\r\nimport { AbstractNumberings } from \"./numbering/abstract-numberings\";\r\nimport { Table } from \"./table/table\";\r\nimport { Relationships } from \"./package/relationships\";\r\nimport { Package } from \"./package/package\";\r\nimport { ILayoutable } from \"./utils/i-layoutable\";\r\nimport { VirtualFlow } from \"./utils/virtual-flow\";\r\nimport { TableReader } from \"./table/table-reader\";\r\nimport { ParagraphReader } from \"./paragraph/paragraph-reader\";\r\nimport { CoreProperties } from \"./fields/core-properties\";\r\n\r\nexport class DocumentX implements ILayoutable {\r\n    private part: XmlPart;\r\n    private pars: (Paragraph | Table)[] = [];\r\n    private _section: Section | undefined;\r\n    private _styles: NamedStyles | undefined;\r\n    private _numberings: AbstractNumberings | undefined;\r\n    private _rels: Relationships | undefined;\r\n    private _coreProperties: CoreProperties | undefined;\r\n\r\n    public pack: Package;\r\n\r\n    constructor(pack: Package, part: XmlPart) {\r\n        this.pack = pack;\r\n        this.part = part;\r\n    }\r\n\r\n    public parseContent(): void {\r\n        if (this.pars.length === 0) {\r\n            const doc = Xml.getFirstChildOfName(this.part.document, \"w:document\");\r\n            if (doc !== undefined) {\r\n                const body = Xml.getFirstChildOfName(doc, \"w:body\");\r\n                if (body !== undefined) {\r\n                    body.childNodes.forEach(node => {\r\n                        switch(node.nodeName) {\r\n                            case \"w:p\":\r\n                                this.pars.push(ParagraphReader.readParagraph(this, node));\r\n                                break;\r\n                            case \"w:tbl\":\r\n                                this.pars.push(TableReader.readTable(this, node));\r\n                                break;\r\n                            case \"w:sectPr\":\r\n                                this._section = new Section(this, node);\r\n                                break;\r\n                            case \"w:sdt\":\r\n                                const sdtPars = ParagraphReader.readStructuredDocumentTag(this, node);\r\n                                this.pars.push(...sdtPars);\r\n                                break;\r\n                            default:\r\n                                console.log(`Don't know how to parse ${node.nodeName} during Document reading.`);\r\n                                break;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public performLayout(flow: VirtualFlow): void {\r\n        this.parseContent();\r\n        this.pars.forEach(par => {\r\n            par.performLayout(flow);\r\n        })\r\n    }\r\n\r\n    public get relationships(): Relationships | undefined {\r\n        return this._rels;\r\n    }\r\n\r\n    public get styles(): NamedStyles | undefined {\r\n        return this._styles;\r\n    }\r\n\r\n    public get numberings(): AbstractNumberings | undefined {\r\n        return this._numberings;\r\n    }\r\n\r\n    public get coreProperties(): CoreProperties | undefined {\r\n        return this._coreProperties;\r\n    }\r\n\r\n    public setRelationships(relationships: Relationships): void {\r\n        this._rels = relationships;\r\n    }\r\n\r\n    public setNamedStyles(styles: NamedStyles): void {\r\n        this._styles = styles;\r\n    }\r\n\r\n    public setNumberings(numberings: AbstractNumberings): void {\r\n        this._numberings = numberings;\r\n    }\r\n\r\n    public setCoreProperties(coreProperties: CoreProperties): void {\r\n        this._coreProperties = coreProperties;\r\n    }\r\n\r\n    public get paragraphs(): (Paragraph | Table)[] {\r\n        return this.pars;\r\n    }\r\n\r\n    public get section(): Section | undefined {\r\n        return this._section;\r\n    }\r\n}","import { DocumentX } from \"../document-x\";\r\nimport { Table } from \"./table\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { Metrics } from \"../utils/metrics\";\r\nimport { TableColumn } from \"./table-column\";\r\nimport { TableRow } from \"./table-row\";\r\nimport { TableStyle } from \"./table-style\";\r\nimport { TableCell } from \"./table-cell\";\r\nimport { ParagraphType } from \"../paragraph/paragraph\";\r\nimport { TableBorder, TableBorderType } from \"./table-border\";\r\nimport { Justification } from \"../paragraph/par-style\";\r\nimport { ParagraphReader } from \"../paragraph/paragraph-reader\";\r\nimport { TableBorderSet } from \"./table-border-set\";\r\nimport { TableMarginSet } from \"./table-margin-set\";\r\nimport { InSequence } from \"../utils/in-sequence\";\r\n\r\nexport class TableReader {\r\n    public static readTable(docx: DocumentX, tableNode: ChildNode): Table {\r\n        const table = new Table(docx);\r\n        let rowOrder = InSequence.First;\r\n        tableNode.childNodes.forEach(child => {\r\n            switch(child.nodeName) {\r\n                case \"w:tr\":\r\n                    const row = this.readTableRow(child, table);\r\n                    row.setOrder(rowOrder);\r\n                    table.rows.push(row);\r\n                    rowOrder = InSequence.Middle;\r\n                    break;\r\n                case \"w:tblPr\":\r\n                    table.style = this.readTableStyle(child);\r\n                    break;\r\n                case \"w:tblGrid\":\r\n                    let start = 0;\r\n                    child.childNodes.forEach(col => {\r\n                        if (col.nodeName === \"w:gridCol\") {\r\n                            const w = Xml.getAttribute(col, \"w:w\");\r\n                            if (w !== undefined) {\r\n                                const width = Metrics.convertTwipsToPixels(parseInt(w));\r\n                                table.columns.push(new TableColumn(start, width));\r\n                                start += width;\r\n                            }\r\n                        }\r\n                    });\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Table reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        if (table.rows.length === 1) {\r\n            table.rows[0].setOrder(InSequence.Only);\r\n        } else {\r\n            table.rows[table.rows.length - 1].setOrder(InSequence.Last);\r\n        }\r\n        return table;\r\n    }\r\n\r\n    private static readTableRow(rowNode: ChildNode, table: Table): TableRow {\r\n        const row = new TableRow(table);\r\n        const rowStyle = new TableStyle();\r\n        rowStyle.higherStyle = table.style;\r\n        let colIndex = 0;\r\n        rowNode.childNodes.forEach(cellNode => {\r\n            if (cellNode.nodeName === \"w:tc\") {\r\n                const cell = this.readTableCell(cellNode, table, rowStyle, colIndex);\r\n                colIndex += cell.numColumns;\r\n                row.cells.push(cell);\r\n            }\r\n        });\r\n        return row;\r\n    }\r\n\r\n    private static readTableCell(cellNode: ChildNode, table: Table, rowStyle: TableStyle, colIndex: number): TableCell {\r\n        const style = new TableStyle();\r\n        const cell = new TableCell(table.columns, style, colIndex);\r\n        cellNode.childNodes.forEach(child => {\r\n            switch(child.nodeName) {\r\n                case \"w:p\":\r\n                    const par = ParagraphReader.readParagraph(table.docx, child);\r\n                    par.type = ParagraphType.TableCell;\r\n                    cell.pars.push(par);\r\n                    break;\r\n                case \"w:tcPr\":\r\n                    this.readTableCellPresentation(child, rowStyle, style);\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during TableCell reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        const id = Xml.getAttribute(cellNode, \"w:id\");\r\n        if (id !== undefined) {\r\n            cell.id = id;\r\n        }\r\n        return cell;\r\n    }\r\n\r\n    private static readTableCellPresentation(cellPrNode: ChildNode, rowStyle: TableStyle, cellStyle: TableStyle): void {\r\n        cellStyle.higherStyle = rowStyle;\r\n        cellPrNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"w:tcW\":\r\n                    const w = Xml.getAttribute(child, \"w:w\");\r\n                    if (w !== undefined) {\r\n                        cellStyle.width = Metrics.convertTwipsToPixels(parseInt(w));\r\n                    }\r\n                    break;\r\n                case \"w:gridSpan\":\r\n                    const columnSpan = Xml.getStringValue(child);\r\n                    if (columnSpan !== undefined) {\r\n                        cellStyle.columnSpan = parseInt(columnSpan);\r\n                    }\r\n                    break;\r\n                case \"w:tcBorders\":\r\n                    cellStyle.borders = this.readBorders(child);\r\n                    break;\r\n                case \"w:tcMar\":\r\n                    cellStyle.margins = this.readCellMargins(child);\r\n                    break;\r\n                case \"w:shd\":\r\n                    const shading = Xml.getAttribute(child, \"w:fill\");\r\n                    if (shading !== undefined) {\r\n                        cellStyle.shading = shading;\r\n                    }\r\n                    break;\r\n                case \"w:vMerge\":\r\n                    let rowSpan = InSequence.Middle;\r\n                    const vMerge = Xml.getStringValue(child);\r\n                    if (vMerge !== undefined && vMerge === \"restart\") {\r\n                        rowSpan = InSequence.First;\r\n                    }\r\n                    cellStyle.rowSpanOrder = rowSpan;\r\n                    break;\r\n                case \"w:vAlign\":\r\n                    // TODO: Implement.\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Table Cell Style reading.`);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    private static readBorders(bordersNode: ChildNode): TableBorderSet {\r\n        const borders = new TableBorderSet();\r\n        bordersNode.childNodes.forEach(node => {\r\n            const name = node.nodeName;\r\n            switch (name) {\r\n                case \"w:left\":\r\n                case \"w:start\":\r\n                    borders.borderStart = this.readTableBorder(node);\r\n                    break;\r\n                case \"w:right\":\r\n                case \"w:end\":\r\n                    borders.borderEnd = this.readTableBorder(node);\r\n                    break;\r\n                case \"w:top\":\r\n                    borders.borderTop = this.readTableBorder(node);\r\n                    break;\r\n                case \"w:bottom\":\r\n                    borders.borderBottom = this.readTableBorder(node);\r\n                    break;\r\n                case \"w:insideH\":\r\n                    borders.borderHorizontal = this.readTableBorder(node);\r\n                    break;\r\n                case \"w:insideV\":\r\n                    borders.borderVertical = this.readTableBorder(node);\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${node.nodeName} during Table Borders reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return borders;\r\n    }\r\n\r\n    private static readCellMargins(cellMarginNode: ChildNode): TableMarginSet {\r\n        const margins = new TableMarginSet();\r\n        cellMarginNode.childNodes.forEach(node => {\r\n            const name = node.nodeName;\r\n            switch (name) {\r\n                case \"w:left\":\r\n                    const left = Xml.getAttribute(node, \"w:w\");\r\n                    if (left !== undefined) {\r\n                        margins.cellMarginStart = Metrics.convertTwipsToPixels(parseInt(left));\r\n                    }\r\n                    break;\r\n                case \"w:start\":\r\n                    const start = Xml.getAttribute(node, \"w:w\");\r\n                    if (start !== undefined) {\r\n                        margins.cellMarginStart = Metrics.convertTwipsToPixels(parseInt(start));\r\n                    }\r\n                    break;\r\n                case \"w:right\":\r\n                    const right = Xml.getAttribute(node, \"w:w\");\r\n                    if (right !== undefined) {\r\n                        margins.cellMarginEnd = Metrics.convertTwipsToPixels(parseInt(right));\r\n                    }\r\n                    break;\r\n                case \"w:end\":\r\n                    const end = Xml.getAttribute(node, \"w:w\");\r\n                    if (end !== undefined) {\r\n                        margins.cellMarginEnd = Metrics.convertTwipsToPixels(parseInt(end));\r\n                    }\r\n                    break;\r\n                case \"w:top\":\r\n                    const top = Xml.getAttribute(node, \"w:w\");\r\n                    if (top !== undefined) {\r\n                        margins.cellMarginTop = Metrics.convertTwipsToPixels(parseInt(top));\r\n                    }\r\n                    break;\r\n                case \"w:bottom\":\r\n                    const bottom = Xml.getAttribute(node, \"w:w\");\r\n                    if (bottom !== undefined) {\r\n                        margins.cellMarginBottom = Metrics.convertTwipsToPixels(parseInt(bottom));\r\n                    }\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${node.nodeName} during Table Cell Margins reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return margins;\r\n    }\r\n\r\n    private static readTableBorder(borderNode: ChildNode): TableBorder {\r\n        // TODO: Handle frame, shadow\r\n        const border = new TableBorder();\r\n        const val = Xml.getAttribute(borderNode, \"w:val\");\r\n        if (val !== undefined) {\r\n            border.type = this.parseTableBorderType(val);\r\n        }\r\n        const sz = Xml.getAttribute(borderNode, \"w:sz\");\r\n        if (sz !== undefined) {\r\n            // Border size is in quarter points.\r\n            border.size = Metrics.convertPointToPixels(parseInt(sz, 10) / 4);\r\n        }\r\n        const space = Xml.getAttribute(borderNode, \"w:space\");\r\n        if (space !== undefined) {\r\n            border.spacing = Metrics.convertTwipsToPixels(parseInt(space, 10));\r\n        }\r\n        const color = Xml.getAttribute(borderNode, \"w:color\");\r\n        if (color !== undefined) {\r\n            border.color = color;\r\n        }\r\n        return border;\r\n    }\r\n\r\n    private static parseTableBorderType(input: string): TableBorderType {\r\n        let borderType = TableBorderType.None;\r\n        switch(input) {\r\n            case \"single\":\r\n                borderType = TableBorderType.Single;\r\n                break;\r\n            case \"dashDotStroked\":\r\n                borderType = TableBorderType.DashDotStroked;\r\n                break;\r\n            case \"dashed\":\r\n                borderType = TableBorderType.Dashed;\r\n                break;\r\n            case \"dashSmallGap\":\r\n                borderType = TableBorderType.DashSmallGap;\r\n                break;\r\n            case \"dotDash\":\r\n                borderType = TableBorderType.DotDash;\r\n                break;\r\n            case \"dotDotDash\":\r\n                borderType = TableBorderType.DotDotDash;\r\n                break;\r\n            case \"dotted\":\r\n                borderType = TableBorderType.Dotted;\r\n                break;\r\n            case \"double\":\r\n                borderType = TableBorderType.Double;\r\n                break;\r\n            case \"doubleWave\":\r\n                borderType = TableBorderType.DoubleWave;\r\n                break;\r\n            case \"inset\":\r\n                borderType = TableBorderType.Inset;\r\n                break;\r\n            case \"outset\":\r\n                borderType = TableBorderType.Outset;\r\n                break;\r\n            case \"thick\":\r\n                borderType = TableBorderType.Thick;\r\n                break;\r\n            case \"thickThinLargeGap\":\r\n                borderType = TableBorderType.ThickThinLargeGap;\r\n                break;\r\n            case \"thickThinMediumGap\":\r\n                borderType = TableBorderType.ThickThinMediumGap;\r\n                break;\r\n            case \"thickThinSmallGap\":\r\n                borderType = TableBorderType.ThickThinSmallGap;\r\n                break;\r\n            case \"thinThickLargeGap\":\r\n                borderType = TableBorderType.ThinThickLargeGap;\r\n                break;\r\n            case \"thinThickMediumGap\":\r\n                borderType = TableBorderType.ThinThickMediumGap;\r\n                break;\r\n            case \"thinThickSmallGap\":\r\n                borderType = TableBorderType.ThinThickSmallGap;\r\n                break;\r\n            case \"thinThickThinLargeGap\":\r\n                borderType = TableBorderType.ThinThickThinLargeGap;\r\n                break;\r\n            case \"thinThickThinMediumGap\":\r\n                borderType = TableBorderType.ThinThickThinMediumGap;\r\n                break;\r\n            case \"thinThickThinSmallGap\":\r\n                borderType = TableBorderType.ThinThickThinSmallGap;\r\n                break;\r\n            case \"threeDEmboss\":\r\n                borderType = TableBorderType.Emboss3D;\r\n                break;\r\n            case \"threeDEngrave\":\r\n                borderType = TableBorderType.Engrave3D;\r\n                break;\r\n            case \"triple\":\r\n                borderType = TableBorderType.Triple;\r\n                break;\r\n            case \"wave\":\r\n                borderType = TableBorderType.Wave;\r\n                break;\r\n            case \"none\":\r\n            case \"nil\":\r\n            default:\r\n                borderType = TableBorderType.None;\r\n                break;\r\n        }\r\n        return borderType;\r\n    }\r\n\r\n    private static readTableStyle(tblPrNode: ChildNode): TableStyle {\r\n        const style = new TableStyle();\r\n        tblPrNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"w:tblBorders\":\r\n                    style.borders = this.readBorders(child);\r\n                    break;\r\n                case \"w:tblCellMar\":\r\n                    style.margins = this.readCellMargins(child);\r\n                    break;\r\n                case \"w:jc\":\r\n                    const justification = Xml.getStringValue(child);\r\n                    if (justification !== undefined) {\r\n                        style.justification = Justification[justification as keyof typeof Justification];\r\n                    }\r\n                    break;\r\n                case \"w:tblInd\":\r\n                    const w = Xml.getAttribute(child, \"w:w\");\r\n                    if (w !== undefined) {\r\n                        style.identation = Metrics.convertTwipsToPixels(parseInt(w, 10));\r\n                    }\r\n                    break;\r\n                case \"w:cellSpacing\":\r\n                    const spacing = Xml.getAttribute(child, \"w:w\");\r\n                    if (spacing !== undefined) {\r\n                        style.cellSpacing = Metrics.convertTwipsToPixels(parseInt(spacing, 10));\r\n                    }\r\n                    break;\r\n                case \"w:tblW\":\r\n                case \"w:tblStyle\":\r\n                case \"w:tblLook\":\r\n                    // Ignore\r\n                    break;\r\n                default:\r\n                    console.log(`Don't know how to parse ${child.nodeName} during Table Style reading.`);\r\n                    break;\r\n            }\r\n        });\r\n        return style;\r\n    }\r\n}","import { NamedStyles } from \"../text/named-styles\";\r\nimport { NumberingLevel } from \"./numbering-level\";\r\n\r\nexport class Numbering {\r\n    private _levels: NumberingLevel[] = [];\r\n\r\n    /**\r\n     * Parse a Numbering from a w:abstractNum Node.\r\n     */\r\n    public static fromAbstractNumNode(styles: NamedStyles | undefined, node: ChildNode): Numbering {\r\n        const numbering = new Numbering();\r\n        node.childNodes.forEach(levelNode => {\r\n            if (levelNode.nodeName === \"w:lvl\") {\r\n                const level = NumberingLevel.fromLevelNode(styles, levelNode);\r\n                if (level !== undefined) {\r\n                    numbering._levels[level.index] = level;\r\n                }\r\n            }\r\n        });\r\n        return numbering;\r\n    }\r\n\r\n    public getLevel(index: number): NumberingLevel {\r\n        return this._levels[index];\r\n    }\r\n}","import { XmlPart } from \"../package/xml-part\";\r\nimport { Numbering } from \"./numbering\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { NamedStyles } from \"../text/named-styles\";\r\n\r\nexport class AbstractNumberings {\r\n\r\n    private doc: Document;\r\n    private _numberings: Numbering[] = [];\r\n\r\n    constructor(part: XmlPart) {\r\n        this.doc = part.document;\r\n    }\r\n\r\n    public parseContent(styles: NamedStyles | undefined): void {\r\n        if (this._numberings.length === 0) {\r\n            const root = Xml.getFirstChildOfName(this.doc, \"w:numbering\");\r\n            if (root !== undefined) {\r\n                const abstractNumberings: Numbering[] = [];\r\n                root.childNodes.forEach(node => {\r\n                    if (node.nodeName === \"w:abstractNum\") {\r\n                        const abstractNumId = Xml.getAttribute(node, \"w:abstractNumId\");\r\n                        if (abstractNumId !== undefined) {\r\n                            const numbering = Numbering.fromAbstractNumNode(styles, node);\r\n                            abstractNumberings[parseInt(abstractNumId)] = numbering;\r\n                        }\r\n                    }\r\n                });\r\n                root.childNodes.forEach(numNode => {\r\n                    if (numNode.nodeName === \"w:num\") {\r\n                        const numId = Xml.getAttribute(numNode, \"w:numId\");\r\n                        const abstractNumId = Xml.getNumberValueFromNode(numNode, \"w:abstractNumId\");\r\n                        if (numId !== undefined && abstractNumId !== undefined) {\r\n                            this._numberings[parseInt(numId)] = abstractNumberings[abstractNumId];\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    public getNumberingById(numId: number): Numbering {\r\n        return this._numberings[numId];\r\n    }\r\n}\r\n","import { Xml } from \"../utils/xml\";\r\n\r\nexport class Relationships {\r\n    private relations: { [id: string]: {target: string, type: string}} = {};\r\n\r\n    public static fromDocument(doc: XMLDocument): Relationships {\r\n        const relationships = new Relationships();\r\n        doc.getRootNode().childNodes.forEach(relsNode => {\r\n            relsNode.childNodes.forEach(relNode => {\r\n                if (relNode.nodeName === \"Relationship\") {\r\n                    const id = Xml.getAttribute(relNode, \"Id\");\r\n                    const target = Xml.getAttribute(relNode, \"Target\");\r\n                    const type = Xml.getAttribute(relNode, \"Type\");\r\n                    if (id !== undefined && target !== undefined && type !== undefined) {\r\n                        relationships.relations[id] = { target: target, type: type };\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        return relationships;\r\n    }\r\n\r\n    public getTarget(id: string): string {\r\n        return this.relations[id].target;\r\n    }\r\n}","import { Shape } from \"./shape\";\r\nimport { Xml } from \"../utils/xml\";\r\nimport { ShapeReader } from \"./shape-reader\";\r\nimport { PresetShapeFactory } from \"./preset-shape-factory\";\r\n\r\n\r\nexport class PresetShapeReader {\r\n    private _shapeReader = new ShapeReader();\r\n\r\n    public readPresetShapeDefinitions(doc: XMLDocument): void {\r\n        doc.getRootNode().firstChild!.childNodes.forEach((child) => {\r\n            if (child.nodeType === Node.ELEMENT_NODE) {\r\n                this.readPresetShapeDefinition(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    public readPresetShapeDefinition(defNode: Node): void {\r\n        const shape = new Shape();\r\n        defNode.childNodes.forEach(child => {\r\n            switch (child.nodeName) {\r\n                case \"avLst\":\r\n                    this._readShapeGuideList(child, shape);\r\n                    break;\r\n                case \"gdLst\":\r\n                    this._readShapeGuideList(child, shape);\r\n                    break;\r\n                case \"pathLst\":\r\n                    this._readPathList(child, shape);\r\n                    break;\r\n                case \"ahLst\":\r\n                case \"rect\":\r\n                case \"cxnLst\":\r\n                case \"#text\":\r\n                    // Ignore, only used for editing shapes.\r\n                    break;\r\n                default:\r\n                    console.log(`Unknown node ${child.nodeName} encountered during reading of Shape definitions`);\r\n                    break;\r\n            }\r\n        });\r\n        PresetShapeFactory.defineShape(defNode.nodeName, shape);\r\n    }\r\n\r\n    private _readShapeGuideList(shapeGuideListNode: Node, shape: Shape): void {\r\n        shapeGuideListNode.childNodes.forEach(child => {\r\n            if (child.nodeType === Node.ELEMENT_NODE) {\r\n                this._readShapeGuide(child, shape);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _readShapeGuide(shapeGuideNode: Node, shape: Shape): void {\r\n        const fmla = Xml.getAttribute(shapeGuideNode, \"fmla\");\r\n        const name = Xml.getAttribute(shapeGuideNode, \"name\");\r\n        if (fmla !== undefined && name !== undefined) {\r\n            shape.guide.addFormula(fmla, name);\r\n        }\r\n    }\r\n\r\n    private _readPathList(pathListNode: Node, shape: Shape): void {\r\n        pathListNode.childNodes.forEach(pathNode => {\r\n            if (pathNode.nodeType === Node.ELEMENT_NODE) {\r\n                this._shapeReader.readPath(pathNode, shape);\r\n            }\r\n        });\r\n    }\r\n}","\r\nexport class CoreProperties {\r\n    public creator: string | undefined = undefined;\r\n    public created: Date | undefined = undefined;\r\n    public description: string | undefined = undefined;\r\n    public language: string | undefined = undefined;\r\n    public lastModifiedBy: string | undefined = undefined;\r\n    public lastModified: Date | undefined = undefined;\r\n    public lastPrinted: Date | undefined = undefined;\r\n    public revision: number | undefined = undefined;\r\n    public subject: string | undefined = undefined;\r\n    public title: string | undefined = undefined;\r\n    public keywords: string | undefined = undefined;\r\n\r\n    public static fromDocument(doc: XMLDocument): CoreProperties {\r\n        const coreProperties = new CoreProperties();\r\n        doc.getRootNode().childNodes.forEach(propsNode => {\r\n            propsNode.childNodes.forEach(propNode => {\r\n                const text = (propNode.textContent === null) ? \"\" : propNode.textContent;\r\n                switch (propNode.nodeName) {\r\n                    case \"dcterms:created\":\r\n                        coreProperties.created = CoreProperties._parseDateString(text);\r\n                        break;\r\n                    case \"dc:creator\":\r\n                        coreProperties.creator = text;\r\n                        break;\r\n                    case \"dc:description\":\r\n                        coreProperties.description = text;\r\n                        break;\r\n                    case \"dc:language\":\r\n                        coreProperties.language = text;\r\n                        break;\r\n                    case \"cp:lastModifiedBy\":\r\n                        coreProperties.lastModifiedBy = text;\r\n                        break;\r\n                    case \"dcterms:modified\":\r\n                        coreProperties.lastModified = CoreProperties._parseDateString(text);\r\n                        break;\r\n                    case \"cp:lastPrinted\":\r\n                        coreProperties.lastPrinted = CoreProperties._parseDateString(text);\r\n                        break;\r\n                    case \"cp:revision\":\r\n                        coreProperties.revision = parseInt(text);\r\n                        break;\r\n                    case \"dc:subject\":\r\n                        coreProperties.subject = text;\r\n                        break;\r\n                    case \"dc:title\":\r\n                        coreProperties.title = text;\r\n                        break;\r\n                    case \"cp:keywords\":\r\n                        coreProperties.keywords = text;\r\n                        break;\r\n                    default:\r\n                        console.log(`Unknown core property ${propNode.nodeName} encountered during reading.`);\r\n                        break;\r\n                }\r\n            });\r\n        });\r\n        return coreProperties;\r\n    }\r\n\r\n    private static _parseDateString(text: string): Date | undefined {\r\n        // Expecting formats: \r\n        // YYYY\r\n        // YYYY-MM\r\n        // YYYY-MM-DD\r\n        // YYYY-MM-DDThh:mmZ\r\n        // YYYY-MM-DDThh:mm:ssZ\r\n        // YYYY-MM-DDThh:mm:ss.sZ\r\n        // Where T is literal and Z can be literal Z or a time zone offset (+hh:mm or -hh:mm).\r\n        const year = parseInt(text.substr(0, 4));\r\n        const month = (text.length <= 4) ? 0 : parseInt(text.substr(5, 2));\r\n        const day = (text.length <= 7) ? 0 : parseInt(text.substr(8, 2));\r\n        let hour = 0;\r\n        let min = 0;\r\n        let sec = 0;\r\n        const milli = 0;\r\n        if (text.length > 10) {\r\n            hour = parseInt(text.substr(11, 2));\r\n            min = parseInt(text.substr(14, 2));\r\n            sec = parseInt(text.substr(17, 2));\r\n        }\r\n        return new Date(Date.UTC(year, month - 1, day, hour, min, sec, milli));\r\n    }\r\n}","import { Renderer } from \"./painting/renderer\";\r\nimport { Package } from \"./package/package\";\r\nimport { NamedStyles } from \"./text/named-styles\";\r\nimport { DocumentX } from \"./document-x\";\r\nimport { AbstractNumberings } from \"./numbering/abstract-numberings\";\r\nimport { Relationships } from \"./package/relationships\";\r\nimport { Metrics } from \"./utils/metrics\";\r\nimport { PresetShapeReader } from \"./drawing/preset-shape-reader\";\r\nimport { Xml } from \"./utils/xml\";\r\nimport { CoreProperties } from \"./fields/core-properties\";\r\n\r\nexport class Potlood {\r\n    private renderer: Renderer;\r\n\r\n    constructor(element: HTMLElement) {\r\n        this.renderer = new Renderer(element);\r\n    }\r\n\r\n    public loadDocxFromUrl(url: string): void {\r\n        this._init();\r\n        Package.loadFromUrl(url).then((pack) => {\r\n            this._loadFromPackage(pack);\r\n        }).catch((err) => {\r\n            console.log(`Failed to load ${url}: ${err}`);\r\n        });\r\n    }\r\n\r\n    public loadDocxFromFiles(files: FileList): void {\r\n        this._init();\r\n        Package.loadFromFile(files).then((pack) => {\r\n            this._loadFromPackage(pack);\r\n        });\r\n    }\r\n\r\n    private _loadFromPackage(pack: Package): void {\r\n        pack.loadPartAsXml('word/_rels/document.xml.rels').then(relPart => {\r\n            const relationships = Relationships.fromDocument(relPart.document);\r\n            pack.loadPartAsXml('word/styles.xml').then(stylePart => {\r\n                const styles = new NamedStyles(stylePart);\r\n                styles.parseContent();\r\n                pack.loadPartAsXml('docProps/core.xml').then(core => {\r\n                    const coreProperties = CoreProperties.fromDocument(core.document);\r\n                    if (pack.hasPart('word/numbering.xml')) {\r\n                        pack.loadPartAsXml('word/numbering.xml').then(numPart => {\r\n                            const numberings = new AbstractNumberings(numPart);\r\n                            numberings.parseContent(styles);\r\n                            this._loadDocument(pack, relationships, styles, coreProperties, numberings);\r\n                        });\r\n                    } else {\r\n                        this._loadDocument(pack, relationships, styles, coreProperties, undefined);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadDocument(\r\n        pack: Package,\r\n        relationships: Relationships,\r\n        styles: NamedStyles,\r\n        coreProperties: CoreProperties,\r\n        numberings: AbstractNumberings | undefined\r\n    ) {\r\n        pack.loadPartAsXml('word/document.xml').then(part => {\r\n            const docx = new DocumentX(pack, part);\r\n            docx.setRelationships(relationships);\r\n            docx.setNamedStyles(styles);\r\n            docx.setCoreProperties(coreProperties);\r\n            if (numberings !== undefined) {\r\n                docx.setNumberings(numberings);\r\n            }\r\n            docx.parseContent();\r\n            const posY = this.renderer.renderDocument(docx);\r\n            this.renderer.ensureHeight(posY);\r\n        });\r\n    }\r\n\r\n    private _init() {\r\n        Metrics.init();\r\n        this.renderer.clear();\r\n        Xml.loadFromUrl('./presetShapeDefinitions.xml').then(doc => {\r\n            new PresetShapeReader().readPresetShapeDefinitions(doc);\r\n        }).catch(() => {\r\n            console.log('Unable to load preset shapes');\r\n        });\r\n    }\r\n}"],"sourceRoot":""}